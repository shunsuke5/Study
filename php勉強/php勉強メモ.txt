php勉強メモ

・phpでは、変数名は常にドル記号で始まる。

・phpの定義済み変数の中には「スーパーグローバル」というものがある。これは、スクリプト全体を通して全てのスコープで使用可能な変数のこと。
　関数やメソッドの内部からアクセスする際にも global $variable; などとする必要はない。

・phpの最も強力な機能の1つは、HTMLフォームを処理する手段。理解するべき重要な基本概念は、あるフォームの中の全てのフォーム要素が、
　自動的にPHPスクリプトで利用可能になるということ。

・phpはファイルを解析して開始タグを終了タグ(<?php と ?>)を探す。タグが見つかると、phpはコードの実行を開始したり終了したりする。
　このような仕組みにより、phpを他のあらゆる形式のドキュメント中に埋め込むことができる。つまり、開始タグと終了タグで囲まれている
　箇所以外の全ての部分は、phpパーサに無視される。(phpパーサとは、parse(構文を解析する)もののこと。)

・ファイルがphpコードのみを含む場合は、ファイルの最後の終了タグは省略するのがおすすめとなっている。
　なぜかというと、終了タグの後に余分な空白や改行があると、予期せぬ挙動を引き起こす場合があるから。
　余分な空白や改行のせいでphpが出力バッファリングを開始し、その時点の内容を意図せず出力してしまうことになる。

・phpインタプリタは ?>終了タグを見つけると、それ以降新たに開始タグを見つけるまでの内容をなんでも出力する。
　(終了タグ直後の改行は別。)しかし、phpが条件文の中にいる場合は話が別。その場合は、まず条件式の結果を判定してから
　何をスキップするかを判断する。

・ステートメントを区切るにはセミコロンが必要となる。

・コメントは/**/　か // か # となる。

・phpにおける単一の式はそれぞれ、その値に応じて、以下の組み込み型のうちのひとつを持つ。

    null
    bool
    int
    float
    string
    array
    object
    callable
    resource

　phpは動的に型付けを行う言語。しかし、型宣言と使うことで、その一部に静的に型を指定することができる。
　型はそれに対して行える操作を制限するが、式や変数に対して型がサポートしていない操作を行うと、phpはその操作をサポートする型に
　「変換しようと」する。

・php8.0.0より前のバージョンでは、get_debug_type()が使えない。代わりにgettype()を使えるが、この関数は正規化された型の名前を使う。

・phpの型システムは、様々な基本型(atomic typr)をサポートしており、それらを組み合わせてより複雑な型を作ることができる。
　そうした複雑な型の一部については、型宣言時に記述できる。phpの型を以下にまとめる。

    基本型
      組み込みの型
        null
        
        スカラー型
          bool
          int
          float
          string

        array
        object
        resource
        never
        void
        クラス内での関係を示す相対型:self,parent,static

      Value型
        false
        true

      ユーザー定義型(一般的に、クラス型とも呼ぶ)
        インターフェイス
        クラス
        列挙型(Enum)

      callable

    複合型
      (インターフェイスやクラスの)交差型
      union型

　基本型の一部は言語に強く統合されている組み込み型であり、ユーザー定義の型として再現できない。
　複合型は、複数の基本型を組み合わせて作ることができる。交差型は、宣言した腹腔のクラス型を(単一ではなく)すべて満たす値を受け入れる
　ことができる。交差型を構成する個別の型は、&記号で結合する。よって、型T,U,Vの交差型はT&U&V と書く。
　union型は、ひとつではなく、複数の異なる型を値として受け入れることができる。union型を構成する個別の型は、| 記号で結合する。
　よって、型T,U,Vのunion型は T|U|Vと書く。型の一つが交差型の場合、DNFで記すために括弧で囲む必要がある。つまり、T|(X&Y)と書く必要がある。

・phpでboolに変換する場合、以下の値はfalseとみなされる。

    booleanのfalse
    integerの0
    floatの0.0及び-0.0(ゼロ)
    空の文字列""、および文字列の"0"
    要素の数がゼロである配列
    uint型NULL(値がセットされていない変数を含む)
    bool型へキャストするように動作がオーバーロードされた内部オブジェクト。
    　属性が無い空要素から作成されたSimpleXMLオブジェクト。

　その他の値は全てtrueとみなされる。

・各進数の表記は以下の通り。16進数の先頭には0xを、8進数は0,0oを、2進数は0bをつける。

    1234 = 10進数
    0123 = 8進数(10進数の83)
    0o123 = 8進数(php8.1.0以降)
    0x1A = 16進数
    0b11111111 = 2進数

・php7.4.0以降では、可読性を向上させるために整数リテラルの間にアンダースコアを含めることができるようになった。
　1234567 を 1_234_567 のようにして従来のカンマ区切りの場所でアンダースコアを用いることで見やすくすることができる。
　アンダースコアはphpのscannerが除去する。

・int型の範囲外の値を指定した場合、かわりにfloatとして解釈される。また、結果がint型の範囲外の数となるような
　計算を行うとfloatが代わりに返される。

・phpには整数の割り算を行う演算子は無い。整数の割り算を行うには intdiv()関数を使用する。

・resource を int に変換すると、その結果は一意なリソース番号となる。これは、そのresourceに対してphpが実行時に割り当てた番号。

・floatが整数の範囲を超える場合、結果はundefinedとなる。この場合、警告も通知も発生しないので注意する。

・文字列をキャストする際、その文字列が数値形式の文字列の場合は対応する整数値に解決され、そうでない場合は0に変換される。
　nullは常に0に変換される。

・浮動小数点の制度は有限。システムに依存するが、phpは通常IEEE754倍精度フォーマットを使う。この形式は、1.11e-16のオーダーでの丸め処理で
　誤差が発生する。より高い精度が必要な場合には、「任意精度数学関数」または gmp 関数を使用する。
　https://www.php.net/manual/ja/ref.bc.php
　https://www.php.net/manual/ja/ref.gmp.php

・数値演算の結果が、定数 NAN で表される値になることがある。この定数は、浮動小数点演算における未定義の値あるいは表現不能な値を表す。
　この値を他の値と比較すると、緩い比較及び厳密な比較のいずれでも結果はfalseになる。自分自身と比較した場合も含むが、
　trueと比較した場合は除く。NANは様々な値の数を表すものなので、他の値と比較してはいけない。たとえ自分自身とであっても。
　チェックをする場合には必ずis_nan()を使う。

・ヒアドキュメント構文(<<<)は、あるIDを<<<の後に指定し、文字列を置いた後で同じIDをくくりを閉じるために置く。

・phpで改行を反映させたい場合、出力先によってその方法が異なる。「コンソールやソースファイルに出力する場合」と
　「ブラウザに表示する場合」にわけてそれぞれの方法を行う。それについては以下の通り。

    コンソールやソースファイルに出力する場合
    　→ 改行コード、PHP_EOL、ヒアドキュメントの3つの方法がある。

    ブラウザに表示する場合
    　→ brタグ、nl2br()関数の2つの方法がある。

　ヒアドキュメントを記述し、ブラウザ上では改行されていなかったが出力先のファイル上では想定通りに改行されていることを確認した。

・phpが実行されるタイミングはWebページを読み込む時。test.txtがいつ作成されるかを試したところ、ページのリロードを押すと
　test.txtが作成された。

・Nowdocはヒアドキュメントと同じように<<<を使用する。しかし、そのあとに続く識別子をシングルクォートで囲む。
　ヒアドキュメントがダブルクォートで囲んだ文字列として扱われるのに対して、Nowdocはシングルクォートで囲んだ文字列として扱われる。

・文字列が二重引用符でくくられるか、ヒアドキュメントで指定された場合、その中の変数はパースされる。$記号を付けると、
　パーサは有効な変数名を形成することが可能な最長のトークンを取得する。変数名の終わりを明示的に指定したい場合は、変数名を波括弧でくくる。

    "He drank some $juice.";
    "He drank some juice made of {juice}s.";

　上記のような変数の埋め込み方は「簡単な構文」と呼ばれる。

・複雑な構文では、どんなスカラー変数、配列の要素あるいはオブジェクトのプロパティの文字列表現であってもこの構文で含めることができる。
　例としては以下の通り。

    "This is {$great}";
    "This square is {$square->width}00 centimeters broad.";
    "This works: {$arr['key']}";
    "This works: {$arr[4][3]}";
    "This works: {$arr['foo'][3]}";
    "This works: " . $arr['foo'][3];
    "You can even write {$obj->values[3]->name}";
    "This is the value of the var named by the return value of getName(): {${getName()}}";
    "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";

　参照は次のURL。https://www.php.net/manual/ja/language.types.string.php

・{$}の内部における関数やメソッドのコール、staticなクラス変数、クラス定数からアクセスする値は、文字列が定義されたスコープにおける
　変数名として解釈する。一つの波括弧では、関数やメソッドの戻り値、クラス定数やstaticなクラス変数の値にはアクセスできない。

・$str[42]のように、角かっこを使用してゼロから始まるオフセットを指定すると、文字列内の任意の文字にアクセスし、修正することが可能。
　つまり、文字列を文字の配列として考えるわけである。範囲外のオフセットに書き込んだ場合は、空いた部分に空白文字が埋められる。
　内部的にはphpの文字列はバイト配列である。そのため、角かっこを使った配列形式での文字列へのアクセスは、マルチバイト対応ではない。
　この方法は、ISO-8859-1のようなシングルバイトエンコーディングの文字列に対してだけしか使えない。

・文字列はドット結合演算子(.)で結合することが可能。+演算子ではないことに注意。

・objectをstringへ変換するには、マジックメソッド __toStringを使用する。
　マジックメソッドとは、ある動作がオブジェクトに対して行われた場合に、phpのデフォルトの動作を上書きする特別なメソッドのこと。
　アンダースコア2つから始まる。

・バイト列を文字列に変換する方法についてはphpは何の情報も持っておらず、完全にプログラマ任せとなっている。

・Unicodeを使うプログラムをきちんと書くには、上手く動かない関数を使わないよう注意するしかない。

・「2E1」は 2 * 10 ^ 1 となる。つまり〇E△は、〇 * 10 ^ △ と言った式になる。
　そして、文字列リテラルの中にこの E を数値と共に記述すると、上記で説明した科学的記法で記された数値と見なされてしまうので注意する。

・phpの配列は、実際には順番づけられたマップ。マップは型の一種で、値をキーに関連付ける。この型は様々な使い道に合わせて最適化される。
　配列としてだけでなく、リスト(ベクター)、ハッシュテーブル、辞書、コレクション、スタック、キューなどとして使用することが可能。
　phpの配列には他のphp配列を値として保持することができるため、非常に簡単にツリー構造を表現することが可能。

・リファレンスとは、変数の中のアドレスを参照して変数に格納すること。
　デリファレンスとは、リファレンス下変数の中身を取り出すという意味。

・配列で文字列以外のスカラー値をデリファレンスした場合は、返される結果はnullとなる。php7.4.0より前のバージョンでは、
　何もエラーは発生しなかった。php7.4.0以降では、E_NOTICEが、php8.0.0以降ではE_WARNINGが発生する。

・配列にキーを省略して追加する際、その配列内の添え字が負の数である場合、新たに追加されるキーは0となる

・配列は、言語構造[]または、list()を使って分解することができる。

・配列の分解を使うと、以下のように2つの変数を簡単に入れ替えることができる。

    $a = 1; $b = 2;
    [$b, $a] = [$a, $b];

・int,float,string.bool,resourceのいずれの型においても、arrayに変換する場合、最初のスカラー値が割り当てられている1つの要素(添え字は0)
　を持つ配列を得ることになる。

　objectを配列にする場合には、配列の要素としてオブジェクトの属性(メンバ変数)を持つ配列を得ることになる。添え字はメンバ変数名となるが、
　いくつか注意すべき例外がある。整数のプロパティはアクセス不能になる。private変数の場合、変数名の頭にクラス名がつく。
　また、protected変数の場合は、変数名の頭に * がつく。このとき、頭に追加される値の前後に NUL バイトがついてくる。
　未初期化の「型付きプロパティ」は暗黙に捨てられる。

・array_diff()と配列演算子を用いると、配列を比較することができる。

・配列をリファレンスでコピーする場合には、リファレンス演算子を使う必要がある。

・phpのアロー演算子(->)は、クラスから生成されたインスタンスで、「プロパティやメソッドにアクセスする」場合に用いられる
　(Javaで言うbrave.attack() の . みたいなもん)

・リソースは特別な変数であり、外部リソースへのリファレンスを保持している。リソースは、特別な関数により作成され、使用される。

・コールバックは、callable型で表される。コールバック関数は、単純な関数だけでなく、オブジェクトのメソッドあるいは
　クラスのstaticメソッドであってもかまわない。

・オブジェクトのインスタンスを渡すには配列を使う。配列の0番目の要素にオブジェクトを、1番目の要素にメソッド名を指定する。
　staticメソッドの場合、オブジェクトのインスタンスは不要。0番目の要素として、オブジェクトの代わりにクラス名を指定する。
　'className::methodName'形式で指定することもできる。一般的なユーザー定義関数とは異なり、無名関数とアロー関数もパラメータとして渡せる。

・クロージャは、無名関数が定義された時点での状態を保持し、後から呼び出される際にその状態を引き継ぐ特殊な無名関数。
　外部の変数を利用しつつ、その変数の値を後から変更したり参照したりできる。

・phpが標準で持っている多くの関数と言語構造の他にもコンパイル済みの特定のphp拡張モジュールを必要とする関数がある。
　それらはもしコンパイルされていなければ undefined function として致命的エラーを発してしまうだろう。例えば、 imagecreatetruecolor()
　のような画像関数を使用するには、GDサポートを有効にしてphpをコンパイルしておく必要がある。また、mysqli_connect()を使う場合も、
　やはりMySQLサポートを有効にしてphpがコンパイルされている必要がある。

・header()関数を使うと、Authentication Required メッセージをクライアントブラウザに送ることができる。これにより、クライアントブラウザでは
　ユーザー名とパスワードの入力要求ウィンドウがポップアップ表示される。一度、ユーザーがユーザー名とパスワードを入力すると、
　phpスクリプトを含むそのURLは、次回以降、定義済みの変数 PHP_AUTH_USER , PHP_AUTH_PW , PHP_AUTH_TYPE にそれぞれユーザー名、パスワード、
　認証型が代入された状態で呼ばれる。定義済みの変数は配列 $_SERVER でアクセス可能。Basic認証とDigest認証のみがサポートされている。

・php設定の変更について

　phpをApacheモジュールとして使用している場合、Apache設定ファイル(例:httpd.conf)もしくは.htaccessファイルにディレクティブを
　記述することでphpの設定の変更を行うことができる。.htaccessを使用する場合は恐らくAllowOvverrideの設定をnoneから変更する必要がある。
　
・mixedはあらゆる値を受け入れる型。これは、以下のunion型と同等である。

    object,resource,array,string,float,int,bool,null

　この型はphp8.0.0以降で利用可能。mixed型は、型理論の用語で言うと、トップ型に当たる。つまり、他の全ての型はこの型の部分型になる。

・ユーザー定義の関数の中では、変数の有効範囲は「ローカル関数の中」となる。つまり、グローバルスコープをローカル関数内で参照すると、
　未定義の変数があるというE_WARNINGを生成する。C言語ではグローバル変数をローカル関数内でもそのまま使えるが、
　phpだと使えないことに注意する。phpでは、グローバル変数を関数の内部で使用する場合、global $a, $b; のように
　関数の内部でグローバルとして宣言する必要がある。

・static変数には、定数式の結果としての値を代入できるが、関数呼び出しのような動的な式の結果を代入するとパースエラーになる。
　0 や 1 + 2 は問題ないが、sqrt(121)はエラーが起こる。

・剰余演算子(%)の結果の符号は、被除数の符号と同じになる。つまり、$a % $b の結果の符号は $a と同じになる、ということである。

・breakでは、オプションの引数でネストしたループ構造を抜ける数を指定することができる。
　例えば、break 2;　のような形。

・デフォルト引数値は引数が指定されなかった場合に使われるが、nullを渡した場合はデフォルト値を代入しないことに注意する。

・phpで有効な命名は、先頭が文字あるいはアンダースコアで始まり、その後に任意の数の文字、数字、アンダースコアが続くものである。

・もしかしてphpは自分がjavaでやりたかったnew 変数名(); としてクラスのインスタンスを作ることができるのでは？

・echo (new DateTime())->format('Y'); のように、インスタンスを作成した式の中でそのオブジェクトのメンバーにアクセスすることもできる。

・parent::がjavaでいうsuper.みたいなもの？

・phpでは親クラスのコンストラクタを暗黙の内にコールしないことに注意する。もし親クラスのコンストラクタを実行する時は、
　子クラスのコンストラクタの中でparent::__construct() をコールしなければならない。子クラスでコンストラクタを定義していない場合は、
　親クラスのコンストラクタを継承する(ただし、private宣言されている場合は除く)。

・phpではコンストラクタを1つだけサポートしているが、staticメソッドをコンストラクタのラッパーとして使うことができる。
　staticキーワードはコードが存在するクラスの名前として解釈される。例えば、Productクラス内で $new = new static(); と記述される場合、
　これは $new = new Product(); と同じである。

・アクセス権はpublic,protected,privateの3つ。protectedはクラス自身、継承したクラス、および親クラスからアクセスできる。
　クラスのプロパティもこの3つから定義でき、明示的に指定しない場合はpublicとして定義される。

・どうやら親クラスのprivateプロパティは再定義できない？

・インスタンスからクラスフィールドにアクセスする際は -> ではなく :: を用いる。

・「トレイト」とは、いくつかのメソッド群を異なるクラス階層にある独立したクラスで再利用できるようにする仕組み。
　トレイトからもトレイトを使うことができる。

・「転送コール」とは、self::,parent::,static::による::演算子を使ったコールのこと。
　あるいはクラス階層の中でのforward_static_call()によるコールのこと。

・phpでは名前空間の区切りを / で表現する。foo/bar::method(); のような形。

・

================================================================================================================================

エラーやミスなど

・Warning: Array to string conversion in C:\Apache24\htdocs\example.php on line 15 Array　のようにエラーが発生した。
　　→ 配列を文字列として出力しようとしているのが原因。配列の内容を出力する時はforeachを使用する。

・

================================================================================================================================

phpで作れるもの一覧

・問い合わせフォーム

・予約システム

・検索機能

・ログイン機能

・WordPress

・ECサイト、EC-CUBE

・SNS

・グループウェア(企業で使うスケジュール管理システム)

・社内管理システム全般

・ファイル操作

・