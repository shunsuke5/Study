JavaScript プログラムなど

let myVariable;
　→ 変数の宣言。myVariableを宣言している。

myVariable;
　→ 変数の値を呼び出している。

===
　→ 厳密等価。2つの値が等しくかつデータ型が同じであるかどうかを調べる。論理値の結果(true/false)を返す。

!,!==
　→ 否定、非等価。

function multiply(num1, num2)
　→ 関数の定義。引数にnum1とnum2の2つの数字を取る、multiplyという関数を宣言している。

for (const 項目 of 配列) {
    ...
}
　→ 配列内の要素に対してループ処理内のプログラムを適用できる。拡張for文みたいなもの？

let myNameArray = ["Chris", "Bob", "Jim"];
　→ 配列の宣言。

let dog = { name: "ポチ", breed: "ダルメシアン" };
　→ オブジェクトを定義し、情報を格納している。

switch (式) {
    case 選択肢1:
        実行コード
        break;

    default:
        実行コード
        break;
}
　→ switch文。

条件式 ? trueの時に実行するコード : falseの時に実行するコード
　→ 三項演算子。条件式を制定し、その結果に応じて2つの値または式の内、どちらか一方を返す。
　　単純にtrue/falseで判定可能な2つの選択肢の内より片方を選ぶという場合には三項演算子を使った方がif...elseブロックよりも
　　多くのコードを節約できる。

初期化処理
while (条件) {
    ...

    最後の式(i++など)
}
　→ whileループ。

const objectName = {
    member1Name: member1Value,
    member2Name: member2Value,
    method1: function() {
        ...
    },
    method2() {
        ...
    },
};

　→ オブジェクトを宣言し、メンバを実装している。member1Value,member2Valueのようにデータ項目を表すメンバは「プロパティ」と呼ばれる。
　　関数は「メソッド」と呼ばれる。メソッドの宣言にはmethod1とmethod2の2通りの宣言方法があるが、method2の方が簡略的でよい。
　　このようなオブジェクトは「オブジェクトリテラル」と呼ばれ、作成することになったオブジェクトのコンテンツを文字通り書きだしたもの。

const person = {
    name: {
        first: "Bob",
        last: "Smith",
    },
    ...
}

　→ オブジェクトのメンバがさらにオブジェクトとなっている。



=================================================================================================================================

関数

alert
　→ ポップアップボックスを表示する。

addEventListener(イベント, イベント発生時に実行する関数)
　→ 要素にイベントハンドラーを取り付ける。イベントと、そのイベントが発生したときに実行する関数を引数に指定する。

removeEventListener(イベント,イベント発生時に実行する関数)
　→ イベントハンドラーを除去する。

prompt()
　→ ダイアログボックスを表示する。alert()と異なる点は、ユーザーに入力を求めること。

localStorage.setItem("name", myName)
　→ name を作成し、myNameに入っているデータを格納する。

Stringオブジェクト

    length
　    → 文字列の長さを返す。

    includes(部分文字列);
　    → 文字列に部分文字列が含まれているかを調べる。

    startWith(部分文字列)
　    → 指定した部分文字列で始まるかどうかを調べる。

    endsWith(部分文字列)
　    → 指定した部分文字列で終わるかどうかを調べる。

    indexOf(部分文字列, [検索開始点])
　    → 文字列が部分文字列を含む場合、最初の出現位置のインデックスを返す。
　　　　文字列が部分文字列を含まない場合、-1を返す。

    slice(開始, 終了)
　    → 部分文字列を抽出する。開始から終了 - 1 までの文字数を抽出する。

    toLowerCase(文字列);
    　→ 文字列を全て小文字にする。

    toUpperCase(文字列);
    　→ 文字列を全て大文字にする。

    replace(対象文字列,置換文字列)
    　→ 最初に出現した対象文字列を置換文字列に置換した文字列を返す。

    replaceAll(対象文字列,置換文字列)
    　→ 全ての対象文字列を置換文字列に置換した文字列を返す。

    split(区切り文字);
    　→ 文字列を区切り文字の場所で区切り、配列を返す。

配列オブジェクト

    length
    　→ 配列の要素数を調べる。

    indexOf(アイテム);
    　→ アイテムが格納されているインデックスを返す。アイテムが格納されていない場合は-1を返す。

    push(要素);
    　→ 要素を末尾に追加する。新しい配列の長さを返す。

    unshift(要素);
    　→ 要素を先頭に追加する。新しい配列の長さを返す？

    pop();
    　→ 最後の項目を削除する。削除された項目を返す。

    shift();
    　→ 最初の項目を削除する。削除された項目を返す？

    splice(インデックス,削除数);
    　→ 指定したインデックスから削除数分だけ要素を削除する。

    map(関数);
    　→ 配列の各項目に関数を実行する。関数が実行された配列を返す。

    filter(テスト(真偽値を返す関数));
    　→ テストに適合する項目のみを含む新しい配列を返す。

    join(区切り文字);
    　→ 配列の要素を区切り文字で区切った形で文字列にして返す。

    toString();
    　→ 配列を文字列にする。

Eventオブジェクト

    stopPropagation()
    　→ イベントハンドラーの中で呼び出されると、イベントが他の要素にバブリングするのを防ぐ。

Object

    assign(target, source1)
    　→ すべての列挙可能な自身のプロパティの値を、1つ以上のコピー元オブジェクトからコピー先オブジェクトにコピーする。

JSONオブジェクト

    parse(JSON文字列)
    　→ JSON文字列を引数に取り、それに対するJavaScriptオブジェクトを返す。
    　　await response.text();で取得したJSON文字列を使用することが多い？

    stringify(JavaScriptオブジェクト)
    　→ オブジェクトを引数に取り、等価なJSON文字列を返す。

Canvas要素

    getContext()
    　→ キャンバスの描画可能領域を取得する。

CanvasRenderingContext2D

    beginPath()
    　→ 新しいパスを開始する。なんか形を描画するよという宣言みたいなもので、この後に描画する形の座標などを指定していく。

    fillStyle
    　→ beginPath()で宣言した形の色を指定する。

    arc(x, y, 半径, 円弧の開始点角度, 円弧の終了点角度)
    　→ 描画領域に円括弧をなぞる。円弧の開始点/終了点角度は、とりあえず一周した円を描きたいなら 0, 2 * Math.PI とすればよい。
    　　この場合は0度から2 * Math.PI、つまりラジアンで表した360度になる(ラジアンで指定しなければならない？)
    　　1 * Math.PI とした場合は180度になるため、半円が描かれることになる。

    fill()
    　→ 「beginPath()から描き始めた線描を終了し、描いた領域を前にfillStyleで指定していた色で塗りつぶせ」という指示。

Window

    innerWidth
    　→ ブラウザの幅。

    innerHeight
    　→ ブラウザの高さ。

    requestAnimationFrame(関数)
    　→ アニメーションを行いたいことをブラウザに知らせる。引数には次の再描画でアニメーションを更新する時に呼び出す関数を指定する。

Documentオブジェクト

    querySelector(要素)
    　→ htmlファイルの指定した要素を取得する。複数ある場合は、最初に現れる要素を選択する。

    querySelectorAll(要素)
    　→ htmlファイルの指定したすべての要素を取得する。それらへの参照を配列風のオブジェクトであるNodeListに格納する。

    createElement(要素)
    　→ 要素を作成する。

    getElementById(ID)
    　→ 指定したid属性値を持つ要素を選択する。

Elementオブジェクト

    setAttribute(属性, その値)
    　→ 要素に属性とその値を設定する。

Nodeインターフェイス

    appenChild(要素)
    　→ 指定した要素をこの要素の子として入れる。既に存在する要素に対して行った場合は、2つ目のコピーを作るのではなく、
    　　セクションの一番下に移動させる。もしコピーを作成してそれも追加したい場合は、代わりにNode.cloneNode()を使用する。

Arrayインスタンス

    push()
    　→ 配列の末尾に指定された要素を追加する。戻り値として配列の新しい長さを返す。

Promiseオブジェクト

    then()
    　→ プロミスに履行ハンドラーと拒否ハンドラーを追加し、呼び出されたハンドラーの戻り値で解決する新しいプロミスを返す。
    　　プロミスが処理されなかった場合(すなわち、関連するハンドラー ofFulfilled または onrejected が関数ではない場合)は、
    　　元の解決値を返す。

    catch()
    　→ プロミスに拒否ハンドラーコールバックを追加し、コールバックが呼び出されたときの戻り値で解決する、またはプロミスが履行された場合は
    　　元の履行結果で解決する新しいプロミスを返す。

    all()
    　→ プロミスの配列を受け取り、単一のプロミスを返す。

    any()
    　→ プロミスの配列のいずれかが履行されるとすぐに履行され、すべてが拒否されると拒否される。



=================================================================================================================================