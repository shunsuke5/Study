JavaScript 勉強メモ

・JavaScriptは、ウェブサイトに対話性を追加するプログラミング言語。ゲーム、ボタンを押した時の反応、フォームへのデータ入力、
　動的なスタイル付け、アニメーションなどがこれにあたる。

・データ型には、文字列、数値、論理型、配列、オブジェクトがある。JavaScriptのすべてがオブジェクトであり、変数に格納することができる。

・コメントは/**/　か　// で記述する。

・イベント

　ウェブサイトをインタラクティブにするには、「イベント」が必要。イベントは、ブラウザの中で起きていることを検出し、その応答として
　コードを実行するコード構造。最もわかりやすい例はclickイベントで、マウスで何かをクリックするとブラウザによって発行されるもの。
　これを実行するには、以下のようなプログラムを記述する。

    document.querySelector("html").addEventListenr("click", function () {
        alert("痛っ！つつかないで！");
    });

　要素にイベントハンドラーを取り付ける方法はいくつもある。ここでは<html>要素を選択している。そして、addEventListener()関数を呼び出し、
　待ち受けるイベントの名前("click")とイベントが発生したときに実行する関数を渡す。
　上記でaddEventListener()に渡している関数は、名前を持たないので「無名関数」と呼ばれる。無名関数の書き方として、「アロー関数」と
　呼ばれるものがある。アロー関数は () => を function ()　の代わりに使用する。

    addEventListener("click", () => 
    {
        alert("痛っ！つつかないで！");
    })

・文字列内で変数を埋め込むにはバッククォート(シングルクォートではない点に注意)で文字列を囲み、その中で${変数名} とすればよい。

・APIは大まかに以下の2種類に分けられる。

    ブラウザAPI
    　→ webブラウザに組み込まれており、コンピュータを取り巻く環境からデータを取り出したり、複雑で便利なことをしてくれたりする。
    　　例えば以下のようなものがある。

        DOM API
        　→ HTMLとCSSの操作を行うことができる。HTMLを生成し、削除し、変更し、動的にページの見た目を変更することなどができる。
        　　例えば、ページにポップアップウィンドウが現れたり、新しいコンテンツが表示されたりするのは、すべてDOMの動きによるもの。

        位置情報 API
        　→ 地理的な情報を取得する。これはGoogleマップが現在の所在地を見つけて地図上にプロットする場合に使用されている。

        Canvas,WebGL API
        　→ 2Dや3Dグラフィックでのアニメーションを可能とする。

        音声と動画のAPI
        　→ 適切な音声・動画をwebページで再生したり、webカメラの動画を撮って他の人のコンピュータで流したりするような、
        　　マルチメディアの可能性を示してくれる。

    サードパーティ API
    　→ ブラウザには組み込まれておらず、さらに普通はweb上のどこかからそのコードと情報を探さなければならない。例えば、

        Twitter API
        　→ webサイトに細心のツイートを表示させることができる。

        GoogleマップAPI　や　OpenStreetMap API
        　→ webサイトに専用の地図を埋め込み、付加機能をつけることもできる。

・JavaScriptのごく一般的な用途は、DOM APIを介して動的にHTMLとCSSを変更し、ユーザーインターフェイスを更新することである。

・ブラウザのそれぞれのタブは、コードを実行するための入れ物を個別に持つ(この入れ物を技術的用語では「実行環境」と呼ぶ。)
　つまり、それぞれのタブ内でコードは完全に分かれて実行されており、あるタブで動いているコードは他のタブや他のwebサイトのコードに
　直接的には干渉できない。これは良いセキュリティ対策である。

　メモ：他のwebサイトやタブに、安全にデータや実行可能なコードを送る方法もある。しかし高度な技術のためここでは扱わない。

・インタープリターとコンパイルコード

　インタープリター言語では、コードが上から下に実行されてコードの実行結果がすぐに返ってくる。
　ブラウザが実行する前にコードを何らかの形に変換する必要はない。
　一方、コンパイル言語はコンピュータで実行する前に他の形式に変換(コンパイル)しなければならない。

　JavaScriptは軽量なインタープリター型プログラミング言語である。webブラウザは元のテキストの形でJavaScriptコードを受け取り、
　それからスクリプトを実行する。たいていのJavaScriptインタープリターは「実行時コンパイル」という技術を使ってパフォーマンスを向上させている。
　スクリプトが使われる時に、JavaScriptコードが速いバイナリーフォーマットにコンパイルされて、可能な限り高速に実行される。
　しかし、JavaScriptは事前ではなく実行時にコンパイルされるために、インタープリター言語と考えられている。

・サーバーサイドコードとクライアントサイドコード

　クライアントサイドコードはユーザーのコンピュータ上で実行されるコード。webページを見ている時、ページのクライアントサイドコードが
　ダウンロードされて、ブラウザで実行されて表示される。このモジュールのことを明示的に「クライアントサイドJavaScript」と言う。

　一方、サーバーサイドコードはサーバー上で実行され、結果がブラウザにダウンロードされて表示される。webで人気のあるサーバーサイドの言語は
　PHP,Python,Ruby,ASP.NETなど。そして、JavaScript。JavaScriptはサーバーサイドの言語としても使われる。
　人気のあるNode.js環境がその例である。

・動的コードと静的コード

　クライアントサイドのJavaScriptと、サーバーサイドの言語を説明するのに「動的」という言葉を使う。これはwebページやwebアプリが必要に応じて
　コンテンツを生成し、異なる状況において異なる表示ができるという能力を指している。サーバーサイドのコードはデータベースから
　データを取得して動的にコンテンツを生成する。一方、クライアントサイドのJavaScriptはクライアント上のブラウザでHTMLのテーブルを生成したり、
　そのテーブルにサーバーから指示を受け、データを追加したり、webページ上でユーザーにテーブルを表示したりするなどして、
　動的にコンテンツを生成する。それぞれの文脈で少し異なる意味合いではあるが、関連している。

　動的に更新されるコンテンツを含まないwebページは「静的」と表現される。静的なwebページとは常に同じコンテンツを表示するページのこと。

・スクリプトの読み込み方針

　document.addEventListener("DOMContentLoaded", () =>) {
    ...
}

　上記のプログラムは、ブラウザのDOMContentLoaded イベントを待ち受けするイベントリスナーで、HTMLの本体が完全に読み込まれて
　解釈されたことを示す。このブロック内のJavaScriptは、そのイベントが発生するまで実行されないため、エラーは回避される。これは内蔵の例。
　外部の例では、defer属性を使用して問題を解決している。

　こういったJavaScriptの読み込みに対する昔ながらの解決策は、すべてのHTMLが解釈された後に読み込まれるように、bodyの一番下にscript要素を
　書くことであった。しかしこの方法では、HTML DOMが読み込まれるまでスクリプトの読み込みと解釈が完全にブロックされてしまうため、
　JavaScriptがたくさんある大規模なサイトでは、これは大きなパフォーマンス上の問題を引き起こす可能性があり、サイトを遅くする。

・async と defer

　実際には、スクリプトのブロッキングの問題を回避できる現代的な機能が2つある。それらの違いは以下の通り。

    async属性
    　→ スクリプトを取得する間、ページをブロックすることなくスクリプトをダウンロードする。しかし、ダウンロードが完全に完了すると、
    　　スクリプトが実行され、ページのレンダリングがブロックされる。これは、スクリプトの実行が完了するまで、webページの残りのコンテンツが
    　　処理されず、ユーザーに表示されないことを意味する。スクリプトが特定の順序で実行される保証はない。ページ内のスクリプトが
    　　互いに独立して実行し、ページ上の他のスクリプトに依存しない場合に async を使用するのが最善。

    defer属性
    　→ ページに表示されている順番に読み込まれる。ページのコンテンツがすべて読み込まれるまで実行されない。これは、スクリプトがDOMに
    　　依存している場合(例えば、ページ上の1つ以上の要素を変更する場合)に便利。

　例えば、以下のスクリプト要素があるとする。

    <script async src="js/vendor/jquery.js"></script>
    <script async src="js/script2.js"></script>
    <script async src="js/script3.js"></script>

　スクリプトが読み込まれる順序に頼ることはできない。jquery.jsが読み込まれるのはscript2.jsとscript3.jsよりも前かもしれないし、
　後かもしれない。この場合、これらのスクリプトの関数がjqueryに依存していると、スクリプトの実行時にjqueryが定義されないため、
　エラーが発生する。

　読み込むバックグラウンドスクリプトがいくつもあって、それらをできるだけ早く実行したい場合にはasyncを使用するべき。
　例えば、ゲームを実際に開始する時に必要になるいくつかの読み込むべきゲームデータファイルがあるとして、今のところは、
　スクリプトを読み込むことによってブロックされずに、ゲームのイントロ、タイトル、ロビーを表示したいだけ、というような場合。

　それに対し、defer属性付きのスクリプト(以下のようなもの)は、ページに現れた順序でスクリプトを実行し、スクリプトとコンテンツが
　ダウンロードされるとすぐにスクリプトを実行する。

    <script defer src="js/vendor/jquery.js"></script>
    <script defer src="js/script2.js"></script>
    <script defer src="js/script3.js"></script>

　ページコンテンツが全て読み込まれるまでは実行せず、これはスクリプトがDOM配置に依存している場合に便利である。(例:ページの要素を変更)

・バッククォーテーションを用いて宣言された文字列は「テンプレートリテラル」と呼ばれ、いくつかの特別なプロパティがある。
　文字列の中にも変数や発生した式を埋め込むことができる、など。

・for (const fruit of fruits) は以下のような意味。

    1．fruitsの最初の項目を取得する。

    2．その項目を変数fruitに設定し、ループ内の処理を実行する。

    3．fruitsの中の次の項目を取得し、fruitsの末尾に達するまで2を繰り返す。

　ここで注意するのは、たとえfruitsが定数であっても、.textContent のような内部プロパティは変更できる、と言った点。

・JavaScriptでは、すべてのものはオブジェクト。オブジェクトとは、1か所に関連する機能をまとめたもの。例えば以下のプログラムを見ると、

    const guessField = document.querySelector(".guessField);

　これは、HTMLのテキスト入力フィールドを参照するために、最初にguessField 変数を作成し、
　documentオブジェクトのquerySelector()メソッドを使用している。querySelector()はある情報を受け取る。
　guessFieldに<input>要素の参照が得られたので、これでたくさんのプロパティとメソッドにアクセスできるようになる。
　この後に以下のようにinput要素のメソッドの1つであるfocus()メソッドを使ってテキストフィールドにフォーカスを当てられる。

    guessField.focus();

・ページ内に存在する全ての要素は style プロパティを持っており、そのオブジェクトを介してCSSのインラインスタイルで要素に適用される
　すべてのプロパティにアクセスすることができる。これを使うことで、JavaScriptから動的に要素のCSSのスタイルを設定できるのである。

・constを使って宣言したオブジェクトのプロパティは更新したり、追加したり、削除することができるので注意する。

・JavaScriptには2つ目の数値型である「BigInt」がある。これはとても大きな整数に使う。

・myNumberに"74"が格納されているとき、myNumber += 3; としても、743になってしまう。これを数字で計算したい場合は、
　myNumber = Number(myNumber) + 3; のようにNumber()コンストラクタを呼び出して計算すれば解決できる。

・JavaScriptではべき乗ができる。5 ** 2 は5の2乗を表し、25を返す。つまり、5 * 5と同じ。

・==や!=は値が同様であるかどうかだけを判定し、データ型が同様かどうかは判定しない。データ型まで同様か判定したいなら===,!==を使う。

・テンプレートリテラル内では変数だけでなく、式を含むこともできる。また、ソースコードの改行を反映する。

・文字列にしたい時はString()コンストラクターを呼ぶ。

・文字列に対して「角かっこ記法」を使用することで、文字列中の任意の1文字が得られる。また、lengthを用いて最後の文字を取得するなどもできる。
　例は以下。

    browserType[0];
    browserType[browserType.length - 1];

・配列の中には文字列、数値、オブジェクト、さらには他の配列など、様々なデータ型を格納することができる。

・多次元配列の宣言方法は以下のような形。

    const random = ["tree", 795, [0, 1, 2]];

・配列の全ての項目にアクセスしたい時にfor...of文を使用する。

・CSSのvisibilityでhiddenが設定されており、そのせいで見えない状況に陥ったのでCSSもちゃんとチェックする。

・条件文で何らかの値が検査される場合、false,undefined,null,0,NaN,""　以外であれば true となる。

    if (cheese) {
        abc
    } else {
        def
    }

　つまり上記の例では、cheese変数に何かしら値が入っていれば abc が実行され、falseやundefinedなどであれば def が実行される。

・関数の内、オブジェクトの一部であるものは「メソッド」と呼ばれる。

・JavaScriptには、「変数の巻き上げ」という概念が存在する。これはなかなか厄介なもので、簡単に言うと、
　「関数内で宣言されたローカル変数は、すべてその関数の先頭で宣言されたものとみなされる。」といったことである。
　例えば以下のようなコードがあったとする。

    var myName = "global";

    function func() {
        console.log(myName);
        var myName = "local";
        console.log(myName);
    }

　この時、func()内で出力されるmyNameの値はどうなるだろうか？1回目が global で、2回目が local だと思うかもしれない。
　しかし、JavaScriptでは違う結果が出力される。正解は1回目が undefined で、2回目が local となる。
　つまり上記のコードは以下のコードと同じふるまいをするのである。

    var myName = "global";

    function func() {
        var myName;

        console.log(myName);
        myName = "local";
        console.log(myName);
    }

　myName = local;　の部分が巻き上げられ、関数の先頭で宣言されたように扱われる。ただし、「巻き上げられるのは宣言部分のみ」なので、
　この時点ではその中身(=local)は変数に代入が行われない。よって関数の先頭部分では var myName; となり、これは var myName = undefined;
　と同じ意味なので、最初のconsole.logでは「undefined」が出力される、ということになる。

・無名関数は、ある関数が他の関数を引数として受け取ることを想定している場合に多く見られる。
　無名関数の形で関数を作成することは、「関数式」とも呼ばれる。関数宣言とは異なり、関数式は巻き上げが行われない。

・無名関数を渡す場合、「アロー関数」という別の形式を使用することができる。function(event)の代わりに、(event) => と書く。
　つまり、今まで書いていた() => のような形は、引数を取らない無名関数を定義していた、ということ。なお引数を1つしかとらない関数の場合、
　(event) => ではなく event => のように引数を囲む括弧は省略できる。
　最後に、関数の中身がreturn文の1行だけであれば、中括弧とreturnキーワードを省略して式の形を暗黙的に返すこともできる。例としては以下。

    const originals = [1, 2, 3];
    const doubled = oiriginals.map(item => item * 2);

　最後に、それぞれについて例でまとめていく。

    関数を定義する形
        function logKey(event) {
            console.log(`${event.key}を押しました。`);
        }
        textBox.addEventListener("keydown", logKey);

    無名関数
        textBox.addEventListener("keydown", function (event) {
            console.log(`${event.key}を押しました。`);
        });

    アロー関数
        textBox.addEventListener("keydown", event => {
            console.log(`${event.key}を押しました。`);
        })

・btn.addEventListener("click", displayMessage);　のように、関数名の後に括弧をつけない理由として、
　関数をすぐに呼び出したくないから、と言う理由がある。つまり、クリックしてからこの関数を呼び出してほしいときに
　括弧をつけないこの形を用いる。このときdispleyMessage()のようにしてしまうと、クリックしなくても関数が実行されてしまうため、
　想定している挙動と違う挙動をする場合があるため注意する。

　このコンテキストでの括弧は「関数呼び出し演算子」と呼ばれることもある。それに対して無名関数の中のコードは、関数スコープの中にあるので
　すぐに実行されるわけではない。

　このときもう一点注意したいのが、呼び出す関数が引数を持っている場合は括弧で引数を囲まなければならない、
　つまりdispleyMessage(msgText)　のような場合だと、直接関数名を指定すると括弧がついてしまうため、すぐに関数が呼び出されてしまう。
　引数を持つ関数をすぐに呼び出したくない場合は、以下のように無名関数の中に入れて、すぐに呼び出されないようにする必要がある。

    btn.addEventListener("click", () =>
      displayMessage("abc"),
    );

　上記のようにすれば、displayMessageは引数を指定する括弧をつけても、ボタンがクリックされるまでは呼び出されない。

・イベントは、あなたがプログラミングしているシステムで発生するもの。イベントが発生すると、システムは何らかのシグナルを発生(または発火)
　させ、イベントが発生したときに自動的にアクションが実行されるメカニズムを提供する。イベントはブラウザウィンドウの内部で発生し、
　そこに存在する特定のアイテムに結び付けられる傾向がある。これは、単一の要素であったり、要素の集合であったり、現在のタブ内に読み込まれた
　HTML文書であったり、ブラウザウィンドウ全体であったりする。例えば、以下のようなイベントがある。

    ユーザーが特定の要素を選択したり、クリックしたり、カーソルを当てたりする。

    ユーザーがキーボードのキーを押す。

    ユーザーがブラウザーウィンドウをリサイズしたり閉じたりする。

    webページの読み込みが完了する。

    フォームが送信される。

    動画が再生される、停止される、再生が終わる。

    エラーが発生する。

　このようにイベントには様々なものがある。一覧を見たい場合は以下のイベントリファレンスへ。
　https://developer.mozilla.org/ja/docs/Web/Events

・イベントに反応するには、イベントに「イベントハンドラー」を取り付ける。これは、イベントが発行されたときに実行するコードのブロック
　(通常はプログラマーである自身が作成するJavaScript関数)である。このようなコードのブロックが、イベントに応答して実行するように
　定義されている場合、「イベントハンドラーを登録している」と言う。なお、イベントハンドラーは時に「イベントリスナー」と呼ばれることがある。
　厳密に言うと、イベントリスナーはイベントの発生を待ち受けし、イベントハンドラーは発生したイベントに応じて動作するコード。

・addEventListener()メソッドは、イベントハンドラーを追加するための推奨メカニズム。

・イベントハンドラーは AbortSignal を addEventListener()に渡して、後で abort() を呼び出すことでも除去できる。使い方の例は以下の通り。

    const controller = new AbortController();
    { signal: controller.signal } // このハンドラーにAbortSignalを渡す

　上記のコードで作成したイベントハンドラーは、controller.abort(); のように除去される。
　これは、このコントローラーに関連付けられたすべてのイベントを除去する。

・以下のようにaddEventListener()に複数の呼び出しを行うことで、異なるハンドラーを提供し、単一のイベントに複数のハンドラーを
　持たせることができる。

    myElement.addEventListener("click", functionA);
    myElement.addEventListener("click", functionB);

・イベントハンドラーの登録にはaddEventListener()が推奨されるが、イベントハンドラーを登録する方法としては他にも2種類ある。
　それぞれについての説明は以下の通り。

    イベントハンドラープロパティ
    　→ イベントを発行することができるオブジェクト(ボタンなど)は通常、on にイベント名が続くプロパティを持っている。
    　　例えば、要素には onclick というプロパティがある。これは、イベントハンドラープロパティと呼ばれる。これを用いて
    　　イベントを待ち受けるには、ハンドラー関数をプロパティに割り当てることで実現できる。例としては以下。

        btn.onclick = () => {
            ...
        };

    　　ハンドラープロパティには名前付き関数を設定することもできる。

        btn.onclick = bgChange;

        イベントハンドラープロパティでは、単一のイベントに複数のハンドラーを追加することはできない。イベントハンドラープロパティでは
        後からプロパティを設定しようとすると、それ以前のものが上書きされてしまうため、不可能となっている。

    イベントオブジェクト
    　→ イベントハンドラー関数内でevent,evt,e などと名づけられた引数を見かけることがあるかもしれない。これらはイベントオブジェクトと
    　　呼ばれ、イベントの追加機能や情報を提供する目的でイベントハンドラーに自動的に渡される。例えば以下のようなコードがあるとき、

        function bgChange(e) {
            e.target.style.backgroundColor = rndCol;
        }
        btn.addEventListener("click", bgChange);

        e.target というのはボタン自身を参照している。つまりこのコードでは、ボタンの背景色をランダムに変えるコードとなっている。
        イベントオブジェクトのtargetプロパティは、常にイベントが生じた要素への参照となっている。イベントオブジェクトには好きな名前が
        使える。イベントハンドラー関数の括弧の中に使いたい名前を書くだけ。e,evt,event が開発者の間では人気。

        イベントオブジェクトの中には、そのイベントの特定の種類に関連するプロパティを追加する物がある。例えば、keydownイベントは、
        ユーザーがキーを押した時に発行される。そのイベントオブジェクトは keyboardEvent で、どのキーが押されたかを指示する
        keyプロパティを持ったEventオブジェクトである。

・既定の動作の抑制

　時々、あるイベントで規定で行われることを抑止したくなるような場合がある。例えば、登録フォームでは詳細を入力して送信ボタンを
　クリックすると、データは処理のためにサーバー上の指定したページに送信され、ブラウザは何らかの「成功メッセージ」ページ
　(または別ページが指定されていない場合は同じページ)にリダイレクトされる。

　ここで、ユーザーが適切なデータを送信しなかった場合に問題が発生する。サーバーへのデータ送信を防止し、どこに問題があって
　データを適切なものにするにはどうすればよいのか示す、エラーメッセージを表示したい。

・「イベントのバブリング」は、ブラウザが入れ子になった要素を対象とするイベントをどのように処理するかを記述している。
　以下のようなwebページがあったとする。

    <div id="container">
        <button>クリック</button>
    </div>
    <pre id="output"></pre>

　ここではボタンは別の要素<div>の中にある。この場合、<div>要素が、内包する要素の「親」であるという。
　以下のように、親要素にクリックイベントハンドラーを追加し、ボタンをクリックするとどうなるだろうか？
　handleClick関数は、クリックした要素を<pre>要素に表示させる、といった動きをする。

    container.addEventListener("click", handleClick);

　この場合、「div要素をクリックしました」と表示される。つまりユーザーがボタンをクリックすると、親がクリックイベントを発生させることが
　わかる。ボタンは<div>の中にあるので、ボタンをクリックすると、その中にある要素も暗黙のうちにクリックしたことになるのである。

　では、ボタンと親の両方にイベントリスナーを追加したらどうなるか？ボタンとその親、そしてどちらも内包する<body>要素に
　上記のようなクリックイベントハンドラーを追加してみる。

    document.body.addEventListener("click", handleClick);
    container.addEventListener("click", handleClick);
    button.addEventListener("click", handleClick);

　この場合、button要素をクリックしました、div要素をクリックしました、body要素をクリックしました、の順で3つの文が表示される。
　つまり起こる順番としては、

    1．最初にボタン上でclickが発生する。
    2．続いてclickが親(div要素)で発生する。
    3．続いて<div>要素の親(body要素)で発生する。

　これを、クリックされた最も内側の要素からイベントが「バブルアップ」するという。
　この動作は有益なこともあれば、予期せぬ問題を発生させることもある。

・EventオブジェクトにはstopPropagation()と呼ばれる関数があり、イベントハンドラーの中で呼び出されると、イベントが他の要素にバブリング
　するのを防ぐ。

・イベントのキャプチャ

　イベントの伝播の別の形式として、「イベントキャプチャ」がある。これはイベントバブリングとは逆の順序になっている。
　つまり、入れ子の元も浅い要素で最初に発生し、対象とする要素に到達するまで深い要素に向けて発生していく形となる。
　イベントのキャプチャは既定では無効。有効にするにはaddEventListener()でcaptureオプションを渡す必要がある。

・イベントバブリングは「イベントの委譲」を可能にする。この方法では、ユーザーが多数の子要素のいずれかを操作した時に何らかのコードを
　実行したい場合、子要素に個別にイベントリスナーを設定するのではなく、子要素の親要素にイベントリスナーを設定し、子要素で発生した
　イベントが親要素にバブリングされるようにする。

・イベントはJavaScriptのコアには属さず、ブラウザのwebAPIに属する。

・オブジェクトとは、関連するデータや機能の集合体。これらは通常、いくつかの変数や関数(オブジェクトの中にある場合はプロパティやメソッド
　と呼ばれる)で構成されている。

・オブジェクトリテラルを使用してオブジェクトを作成するのは、構造化された関連のある一連のデータアイテムを何らかの方法で転送したい
　場合、例えば、データベースに入れるリクエストをサーバーに送信するような場合にとても一般的。単一のオブジェクトを送信することは、
　複数のアイテムを個別に送信するよりも遥かに効率的であり、個々のアイテムを名前で識別したい場合には、配列よりも扱いやすいときがある。

・オブジェクト.メンバ　のようにドットを用いてオブジェクトのメンバにアクセスする記法を「ドット記法」という。
　オブジェクト名は「名前空間」として機能する。オブジェクト内に「カプセル化」されたものにアクセスするには、これを用いる。

・オブジェクトの内部に更に他のオブジェクトを持つことも可能。

・「ブラケット記法」は、オブジェクトのプロパティにアクセスするための別の方法を提供する。以下のようにドット記法を用いる代わりに

    person.age;
    person.name.first;

　角かっこを使用して以下のようにすることができる。

    person["age"];
    person["name"]["first"];

　これは配列のアイテムにアクセスする方法ととても似ていて、基本的には同じこと。アイテムを選択するためにインデックス番号を使用する
　代わりに、各メンバーの値に関連付けられた名前を使用している。オブジェクトが「連想配列」と呼ばれるのも当然で、配列が数値と値を
　対応付けるのと同じように、文字列と値を対応付ける。

　一般にドット記法が用いられるが、ブラケット記法を使用しなければならない用途もある。例えば、オブジェクトのプロパティ名が
　変数で管理されている場合、ドット記法を使用して値にアクセスすることはできないが、ブラケット記法を使用して値にアクセスする事は可能。
　以下の例では、logProperty()関数はperson[propertyName]を使用して、propertyNameで指定されたプロパティの値を取得することができる。

    const person = {
        name: ["Bob", "Smith"],
        age: 32,
    };

    function logProperty(propertyName) {
        console.log(person[propertyName]);
    }

    logProperty("name");
    logProperty("age");

・ブラケット記法の良いところは、動的にメンバーの値を設定できるだけでなく、メンバーの名前も追加できるところ。
　例えば、ユーザーの情報として2つのテキストフィールドに名前と値を入力してもらい、人によって個別のデータを設定したい場合に、
　そういった値を以下のように取得するとする。

    const myDataName = nameInput.value;
    const myDataValue = nameValue.value;

　こうして取得したメンバー名と値を以下のようにpersonオブジェクトに設定する。

    person[myDataName] = myDataValue;

　上記のコードはpersonオブジェクトに新しくmyDataNameメンバを追加するのと同時に、その値をmyDataValueに設定する、
　といったことを行っている。この方法を使用してオブジェクトにプロパティを追加することはドット記法ではできない。
　ドット記法は、名前を指す変数ではなく、書いた通りのメンバー名のみ受け入れることができる。

・コンストラクタとは、newキーワードを使って呼び出される関数に過ぎない。コンストラクタを呼び出すと、以下のようなことが行われる。

    新しいオブジェクトを作成する。

    新しいオブジェクトに this を結び付け、コンストラクタのコードで this を参照することができるようにする。

    コンストラクタでコードを実行する。

    その新しいオブジェクトを返す。

　コンストラクタは慣習上、大文字で始められ、作成するオブジェクトの種類に応じた名前を付ける。
　書き方の例としては以下の通り。

    function Person(name) {
        this.name = name;
        this.introduceSelf = function () {
            console.log(`Hi! I'm ${this.name}.`;
        };
    }

　Person()をコンストラクタとして呼び出すにはnewを使用する。

    const salva = new Person("Salva");

・「プロトタイプ」は、JavaScriptオブジェクトが他のものから機能を継承する仕組み。

・JavaScriptで全てのオブジェクトは、プロトタイプと呼ばれる組み込みプロパティを持っている。プロトタイプはそれ自体がオブジェクトなので
　プロトタイプは自分自身でプロトタイプを持ち、「プロトタイプチェーン」と呼ばれるものを持つ。自分自身でプロトタイプにnullを持つ
　プロトタイプに到達すると、その連鎖は終わる。

　メモ:オブジェクトのプロトタイプを指し示すプロパティは prototype と言う名前ではない。実際にはすべてのブラウザが __proto__を使用している。
　オブジェクトのプロトタイプにアクセスする標準的な方法は Object.getPrototypeOf() メソッドである。

　オブジェクトのプロパティにアクセスしようとした時、オブジェクト自身にプロパティが見つからない場合は、プロトタイプを検索して
　プロパティを探す。それでもプロパティが見つからない場合は、プロトタイプのプロトタイプが検索され、プロパティが得られるか、
　チェーンの終わりに達するか、その場合はundefinedを返すまで、そのような具合に繰り返す。
　つまり、myObject.toString() を呼び出すと、ブラウザは以下の流れで動く。

    1．toStringをmyObjectで探す。

    2．見つからない場合は、myObjectのプロトタイプオブジェクトでtoStringを探す。

    3．見つかったら、それを呼び出す。

　myObjectのプロトタイプは何か？それを探すには Object.getPrototypeOf()関数を使用することができる。
　これはObject.prototypeと呼ばれるオブジェクトで、既定では全てのオブジェクトが持つ、最も基本的なプロトタイプである。
　Object.prototypeのプロトタイプは null であり、プロトタイプの連鎖の終わりにある。

・プロパティのシャドウ化

　オブジェクトにプロパティを定義した場合、そのオブジェクトのプロトタイプに同じ名前のプロパティが定義されているとどうなるのか？
　この場合、プロトタイプチェーンの説明から予想できるように、ブラウザはまずそのオブジェクトにその名前のプロパティが無いか探し、
　定義されていなかった場合にのみプロトタイプを調べるので、オブジェクトにプロトタイプのプロパティを追加すると、
　そのオブジェクトのバージョンであるプロパティが呼ばれることになる(Javaのオーバーライドみたいな感じ)
　これはプロパティの「シャドウ化」と呼ばれる。

・プロトタイプの設定

　JavaScriptでオブジェクトのプロトタイプを設定する様々な方法がある。ここではObject.create()とコンストラクタの2つの方法について説明。

    Object.create
    　→ Object.create()メソッドは、新しいオブジェクトを作成し、新しいオブジェクトのプロトタイプとして使用するオブジェクトを
    　　指定することができる。以下に例を示す。

        const personPrototype = {
            greet() {
                console.log("hello!");
            },
        };
        const carl = Object.create(personPrototype);
        carl.greet();   // hello!

    　　ここでは、greet()メソッドを持つオブジェクトpersonPrototypeを作成している。次に、Object.create()を使用して、
    　　personPrototypeをプロトタイプとする新しいオブジェクトを作成する。これで新しいオブジェクトに対してgreet()を
    　　名づけることができ、プロトタイプはその実装を提供することになる。

・JavaScriptでは、全ての関数がprototypeという名前のプロパティを持っている。関数をコンストラクターとして呼び出すと、このプロパティが
　新しく構築されるオブジェクトのプロトタイプとして設定される(規約では__proto__というプロパティに設定されている)。
　つまり、コンストラクタのprototypeを設定すれば、そのコンストラクタで作成する全てのオブジェクトに、確実にそのプロトタイプを
　持たせることができる。

    const personPrototype = {
        greet() {
        console.log(`hello, my name is ${this.name}!`);
        },
    };

    function Person(name) {
        this.name = name;
        }

    Object.assign(Person.prototype, personPrototype);

　ここではpersonPrototypeオブジェクトとPerson()コンストラクタ関数を生成している。
　次に、personPrototypeで定義したメソッドをPerson関数のprototypeプロパティにObject.assignで記述している。
　このコードの後、Person()を使用して作成したオブジェクトは、そのプロトタイプとしてPerson.prototypeを取得し、その中にgreetメソッドが
　自動的に格納される。

    const reuden = new Person("Reuden");
    reuden.greet(); // hello, my name is Reuden!

・独自プロパティ

　上記のPersonコンストラクタを使用して作成したオブジェクトは2つのプロパティを持つ。

    nameプロパティ
    　→ コンストラクタで設定されるため、Personオブジェクトに直接現れる。
    greet()メソッド
    　→ プロトタイプに設定されている。

　メソッドはプロトタイプで定義し、データプロパティはコンストラクタで定義する、というパターンはよく見かける。
　これは、メソッドは作成するオブジェクトごとに同じものを使うのが普通だが、データプロパティはオブジェクトごとに自分自身で値を示したい
　場合が多いから。

　ここでいうnameのように、オブジェクトに直接定義するプロパティは「独自プロパティ」と呼ばれ、あるプロパティが独自プロパティであるか
　どうかは静的メソッドObject.hasOwn()を使って調べることができる。

・プロトタイプはJavaScriptの強力でとても柔軟な機能であり、コードの再利用やオブジェクトの結合を可能にする。
　具体的には、プロトタイプは「継承」のバージョンに対応している。

・JavaScriptのコンストラクタは、クラス定義のようなもので、オブジェクトの「形状」を定義することができ、そのオブジェクトに格納する
　メソッドも含めて、単一の場所で定義することができる。しかし、ここでもプロトタイプを使用することができる。例えば、あるメソッドが
　コンストラクタのprototypeプロパティで定義されている場合、そのコンストラクタを使用して作成された全てのオブジェクトは、そのプロトタイプ
　を介してそのメソッドを取得するので、コンストラクタの中でメソッドを定義する必要はない。

　プロトタイプチェーンは、継承を実装するために自然な方法であるように思える。例えば、プロトタイプがPersonであるStudentオブジェクトがあれば
　nameを継承してintroduceSelf()をオーバーライドすることができる。

・クラスはclassキーワードを使用して宣言することができる。

・プロパティをプライベートにしたい時(Javaでいうprivate)は、#year のようにプロパティ名の前に# をつける。
　これでオブジェクトの外のコードが#yearにアクセスしようとすると、ブラウザはエラーを報告する。注意点として、#yearと宣言した後も
　プログラム内ではyearではなく#yearとし続けなければならない。
　同様に、プライベートメソッドも#をつける。

・「JSON(JavaScript Object Notation)」は、構造化データを表現するための標準のテキストベースの形式で、JavaScriptのオブジェクト構文に
　基づいている。webアプリケーションでデータを転送する場合によく使われる(例えば、複数のデータをサーバからクライアントへ送信して、
　webページ上に表示する場合などで、その逆もある)。頻繁に見かけるデータ形式のため、覚えた方が良い。

・JSONはJavaScriptオブジェクトの構文に似ているが、JavaScriptとは独立して扱われることがあり、多くのプログラミング言語環境には
　JSONを読み取ったり(解釈したり)生成したりする機能がある。

　JSONは文字列として存在する。そのため、ネットワークを通してデータを転送したい場合に便利。JSONデータへアクセスしたい場合は、
　JavaScriptオブジェクトへ変換する必要がある。JavaScriptにはこれらを相互に変換できるメソッドを持ったJSONというグローバルなオブジェクトが
　あるので、変換は難しくない。

　メモ:文字列をネイティブオブジェクトへ変換することは「デシリアライズ」と呼ばれ、ネイティブオブジェクトをネットワークを通して転送
　できるように文字列へ変換することは「シリアライズ」と呼ばれる。
　JSON文字列はそれ自身をファイルとして格納することもできる。.jsonと言う拡張子の付いたただのテキストファイルで、
　MIMEタイプはapplication/json である。

・JSONの注意点としては以下の通り。

    JSONは指定されたデータ形式の純粋な文字列。プロパティのみを含むことができ、メソッドを含むことはできない。

    JSONでは文字列とプロパティ名を二重引用符でくくる必要がある。単一引用符は、JSON文字列全体を囲む以外では無効。

    カンマやコロンが1つ抜けるだけでもJSONファイルは無効になり、動作しない。利用しようとしているデータを注意して確認する。
    (プログラムに問題が無い限り、コンピュータが生成したJSONの方がエラーが含まれる可能性が低くなる)。

    JSONは、配列やオブジェクトだけでなく、JSON内部に入れることができるあらゆるデータ型のデータだけでも有効なものになる。
    例えば、単一の文字列や数値も有効なJSONとなる。

    JavaScriptコードではプロパティを引用符で括らなくても構わないが、JSONでは引用符でくくった文字列だけがプロパティとして扱われる。

・JSONを取得するには、「フェッチ」というAPIを使用している。このAPIでは、JavaScriptを介してサーバからリソースを取得するための
　ネットワークリクエストを行うことができる。(画像、テキスト、JSON、HTML スニペットなど)。つまり、ページ全体を再読み込みしなくても
　コンテンツの小さなセクションを更新できるのである。

・今回のアクティブラーニングではresponse.json()を使用してネットワークレスポンスを直接JavaScriptオブジェクトに変換しているので、
　JavaScriptオブジェクトへのアクセスはシンプルだった。しかし、時には生のJSON文字列を受け取り、それを自分自身でオブジェクトに変換する
　必要がある場合もある。また、JavaScriptのオブジェクトをネットワーク経由で送信したい場合、送信前にJSON(文字列)に変換する必要がある。
　この2つの問題はweb開発ではよくあることなので、ブラウザでは組み込みのJSONオブジェクトが利用でき、
　それには以下の2つのメソッドが備わっている。

    parse();
    　→ JSON文字列を引数に取り、それに対するJavaScriptオブジェクトを返す。

    stringify();
    　→ オブジェクトを引数に取り、等価なJSON文字列を返す。

　つまり、アクティブラーニングでは const superHeroes = await response.json(); としてJSONを直接JavaScriptオブジェクトに変換して
　受け取ることができていたが、場合によっては const superHeroesText = await response.text(); のようにJSONではなくテキストの形で
　データを取得し、そこから const superHeroes = JSON.parse(superHeroesText); のようにJSONデータに変換する、のような手順で
　JSONデータを取得するケースもある。

・ボールを壁に当たったと判定する時の式に this.x + this.size のようにサイズも加算しているのは、x,yはあくまで中心座標のため、
　これだけ指定すると図形がめり込んでしまい、中心に達してから跳ね返るようになってしまうので、
　ちゃんと弾んでるように見せたい場合はサイズも加算しなければならない。

・モノをアニメーションさせる全てのプログラムには、大概アニメーションループがあり、プログラム内の情報を更新して、
　アニメーションの各フレームでその結果を表示する。これは大半のゲームや類似するプログラムの基本になる。

非同期JavaScript 入門

・非同期プログラミングは、長く続く可能性のあるタスクを開始しても、そのタスクが完了するまで待つのではなく、そのタスクの実行中も
　他のイベントに応答できるようにする技術である。タスクが完了すると、プログラムはその結果を表示する。ブラウザが指定した多くの機能、
　特にほとんどの興味深い機能は長い時間がかかる可能性があるため、非同期で実行される。例えば以下のものがある。

    HTTPリクエストをfetch()を使用して行う。

    ユーザーのカメラやマイクにgetUserMedia()を使用してアクセスする。

    ユーザーにshowOpenFilePicker()を使用してファイルを選択するように依頼する。

　したがって、自分自身で非同期関数を実装することはあまりなくても、正しく使用することが必要になる可能性は非常に高い。

・同期プログラミング

　以下のようなコードを考えてみる。

    const name = "Miriam";
    const greeting = `Hello, my name is ${name}!`;
    console.log(greeting);  // Hello, my name is Miriam!

　このコードは、1．nameという文字列を宣言する。　2．greeting というもう1つの文字列を name を使用して宣言する。
　3．JavaScriptコンソールに挨拶文を出力する。　といった流れになっている。
　ここで、ブラウザはプログラムを一度に一行ずつ、書いた順番に進めていくことに留意する。この点でブラウザは次の行に進む前に
　その行の動作が完了するのを待つ。これは、各行が前の行の処理結果に依存しているため、この手順を踏まなければならない。
　このため、これは「同期プログラム」となる。以下のように別個の関数を呼び出されたとしても、同期的であることに変わりはない。

    function makeGreeting(name) {
        return `Hello, my name is ${name}!`;
    }
    const name = "Miriam";
    const greeting = makeGreeting(name);
    console.log(greeting);  // Hello, my name is Miriam!

　ここでは、makeGreeting()は「同期関数」である。なぜなら、呼び出し側はこの関数が動作を完了して値を返すまで待たないと、
　処理を続行できないからである。

・長時間動作する同期関数には問題点がある。例えば、その処理をしている間はテキストボックスに入力ができない、など。
　この問題を解決するためには以下のことをプログラムする方法が必要になる。

    1．関数を呼んで長時間実行する処理を開始する。

    2．その関数が処理を開始してすぐに値を返すようにすることで、プログラムが他のイベントにも応答できるようにする。

    3．最終的に処理が完了したら、その結果を通知する。

　これこそまさに非同期関数ができることである。

・イベントハンドラー

　イベントハンドラーは、非同期プログラミングの一形態である。イベントが発生したときに、すぐにではなくても
　呼び出される関数(イベントハンドラー)を提供する。「イベント」が「非同期処理が完了した」というものであれば、そのイベントを使用して
　非同期関数呼び出しの結果を呼び出し元に通知することができる。

　初期の非同期APIの中には、まさに上記のような方法でイベントを使用するものがあった。XMLHttpRequest は、JavaScriptを使って
　リモートサーバーにHTTPリクエストを送信するAPI。APIを使用すると、JavaScriptでリモートサーバーにHTTPリクエストを行うことができる。
　これは長い時間を要するので、非同期APIとなっており、XMLHttpRequestオブジェクトにイベントリスナーを装着することで、
　リクエストの進捗と最終的に完了したことの通知を受けることができる。

・コールバック

　イベントハンドラーは、コールバックの一種。コールバックは単なる関数で、他の関数に渡され、適切なタイミングで呼び出されることを期待する。
　先程のプログラムのように、コールバックはJavaScriptで非同期関数を実装するための主な方法として使用されていた。
　しかし、コールバックベースのコードは、コールバック自身がコールバックを受け入れる関数を呼び出さなければならないときに、
　理解しづらくなることがある。これは、一連の非同期関数に分解される何らかの処理を実行する必要がある場合によくある状況。

　コールバックの中でコールバックを呼び出さなければならないので、深い入れ子になってしまい、読むのもデバッグするのも大変になってしまう。
　このようにコールバックを入れ子にすると、エラー処理もとても難しくなる。最上位のレベルで一度だけエラー処理をするのではなく、
　それぞれのインデントレベルでエラー処理をしなければならないことがよくある。

　このような理由から、現代の非同期APIのほとんどはコールバックを使用しない。その代わり、JavaScriptで非同期プログラミングの基礎となるのは
　プロミス(Promise)であり、これを次で解説していく。

プロミスの使い方

・「プロミス」は、現代のJavaScriptで非同期プログラミングを行う際の基礎となるもの。プロミスは非同期関数から返されるオブジェクトで、
　操作の現在の状態を表す。プロミスが呼び出し元に返される時点では、操作が完了していないことが多いのだが、
　プロミスオブジェクトは最終的な操作の成功や失敗を処理するためのメソッドを提供している。

　プロミスベースのAPIでは、非同期関数が処理を開始し、Promiseオブジェクトを返す。その後、このプロミスオブジェクトにハンドラーを割り当てれば
　操作が成功したとき、失敗したときにハンドラーが実行される。

・fetch() APIの使用

　この例では、https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json
　からJSONファイルをダウンロードし、それに関するいくつかの情報をログに記録する。

　これを行うには、サーバーに「HTTPリクエスト」を行う。HTTPリクエストでは、リクエストメッセージをリモートサーバーに送信し、
　サーバーからレスポンスが返される。この例では、サーバーからJSONファイルを取得するためのリクエストを送信する。前のプログラムでは
　XMLHttpRequest APIを使用してHTTPリクエストを作成したが、今回はfetch() APIを使用する。これは、XMLHttpRequestに代わる現代の
　プロミスベースAPIである。

・今回のプログラムは以下の通り。

    const fetchPromise = fetch(
    "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
    );

    console.log(fetchPromise);

    fetchPromise.then((response) => {
    console.log(`レスポンスを受信: ${response.status}`);
    });

    console.log("リクエストを開始…");

　上記で行っていることは以下の通り。

    1．fetch() APIを呼び出し、その戻り値をfetchPromiseへ代入する。

    2．その直後に、変数fetchPromiseにログを出力する。これはPromise {<state>: "pending"}のような出力になるはず。
    　 これは、Promiseオブジェクトがあり、そのオブジェクトのstateの値が"pending"であることを示している。"pending"の状態は、
    　 読み取り処理がまだ進行中であることを意味する。

    3．プロミスのthen()メソッドにハンドラー関数を渡し、読み込み処理に成功すると、プロミスはハンドラーが呼び出され、
    　 サーバーのレスポンスが格納されたResponseオブジェクトが渡される。

    4．リクエストを開始したことをメッセージとしてログ出力する。

　出力の全体像は以下のようなもの。

    Promise { <state>: "pending"} (Promise {<fulfilled>: Response})
    リクエストを開始
    レスポンスを受信: 200

　リクエストを開始　は、レスポンスを受け取る前にログに記録されることに注意する。同期関数とは異なり、fetch()はリクエストが進行している
　間に値を返すので、プログラムが応答し続けることができる。レスポンスは200ステータスコードを示し、リクエストに成功したことを示している。

・プロミスの連鎖

　fetch() APIでは、Responseオブジェクトを取得したら、別の関数を呼び出してレスポンスデータを取得する必要がある。
　今回は、レスポンスデータをJSONとして取得したいので、Responseオブジェクトのjson()メソッドを呼び出すことになる。
　json()も非同期であるため、つまりこれは2つの連続した非同期関数を呼び出さなければならないケースである。以下のコードを追加する。

    fetchPromise.then((response => {
        const jsonPromise = response.jeson();
        jsonPromise.then((data) => {
            console.log(data[0].name);
        });
    });

　この例では、前回と同様にthen()ハンドラーをfetch()が返すプロミス(fetchPromise)に追加している。しかし今回は、ハンドラーは
　response.json()を呼び出され、次に新しいthen()ハンドラーをresponse.json()が返すプロミス(jsonPromise)に渡している。

　しかしここで気になるのが、前回の記事でコールバックの中で別のコールバックを呼び出すと、コードの入れ子レベルがどんどん深くなる、
　そしてそれは良くないことだと言っていたが、これと同じでthen()を入れ子にしていくだけではないのだろうか？

　これはもちろんそうである。しかし、プロミスの特徴は、then()自身がプロミスを返し、それに渡された関数の結果で完了することである。
　これはつまり、上記のコードを以下のように書き換えられる(そしてこの通りに書くべき)ということ。

    const fetchPromise = fetch("https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",);

    fetchPromise
        .then((response) => response.json())
        .then((data) => {
            console.log(data[0].name);
        });

    alice1.animete(a,b)
      .then(() => alice2.animate(a,b))
      .then(() => alice3.animate(a,b))

　最初のthen()のハンドラーの中で2つ目のthen()を呼び出す代わりに、json()が返すプロミスを返し、その戻り値で2つ目のthen()を呼び出すように
　することができる。これは「プロミス連鎖」と呼ばれ、連続した非同期関数呼び出しを行う際に、インデントがどんどん深くなっていくのを避ける
　ことができる。

　もう1つ追加しなければならないことが、リクエストを読み込む前にサーバーがリクエストを受け入れ、処理することができたかどうかを調べる
　必要がある。これを行うには、レスポンスのステータスコードを調べて、それがOKでない場合はエラーを発生させる。

    fetchPromise
      .then((response) => {
        if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        console.log(data[0].name);
      });

・エラーの捕捉

　fetch() APIは様々な理由でエラーを発生させることがある(例えば、ネットワークに接続できない、URLが何らかの形で不正であるなど)。
　また、サーバーがエラーを返すと、私たち自身がそのエラーを報告することになる。

　ネストされたコールバックではエラー処理がとても難しくなり、ネストレベルごとにエラーを処理しなければならなくなることを確認した。
　エラー処理に対応するために、Promiseオブジェクトはcatch()メソッドを提供している。これはthen()によく似ている。これを呼び出して
　ハンドラー関数を渡す。ただし、then()に渡されたハンドラーは非同期処理が成功したときに呼び出されるのに対し、catch()に渡されたハンドラーは
　非同期処理が失敗したときに呼び出される。

　プロミス連鎖の最後にcatch()を追加すると、非同期関数の呼び出しのいずれかに失敗したときに呼び出されるようになる。
　つまり、ある処理をいくつかの連続した非同期関数呼び出しとして実装し、全てのエラーを処理する場所を1つにまとめておくことができる。

・プロミスの用語

　プロミスにはかなり特殊な用語が使われているので、それについて理解しておくとよい。
　まず、プロミスは以下の3つの状態のいずれかになる。

    待機(pending)
    　→ プロミスが作成され、それが関連する非同期関数がまだ成功も失敗もしていない状態。これは、プロミスがfetch()を呼び出して
    　　返されたときの状態であり、リクエストはまだ実行されている。

    履行(fuffilled)
    　→ 非同期関数が成功している。プロミスが履行されると、そのthen()ハンドラーが呼び出される。

    拒否(rejected)
    　→ 非同期関数が失敗している。プロミスが拒否されると、そのcatch()ハンドラーが呼び出される。

　ここでいう「成功した」「失敗した」が何を意味しているかは、当該APIによるということに注意する。例えば、fetch()はサーバーが404 Not Found
　といったエラーを返していればリクエストに成功したと判断するが、ネットワークのエラーでリクエストが送れなかった場合は成功しない、とする。
　決定(settled)と言う用語を使うこともある。これは履行と拒否の両方を表す。

　プロミスが「解決(resolved)」したというと、決定されたときか、または他のプロミスの状態に従うことで「ロックイン」された場合を表す。

・複数のプロミスの組み合わせ

　「プロミスチェーン」は、処理がいくつかの非同期関数から構成され、次の関数を開始する前にそれぞれの関数が完了する必要がある場合に
　必要となるもの。しかし、他にも非同期関数の呼び出しを組み合わせる必要がある場合があり、Promise APIはそのためのヘルパーを
　いくつか提供している。

・関数の開始時にasyncを追加すると、その関数は非同期関数になる。

・JavaScriptモジュールの中にコードが無い限り、awaitはasync関数の中でしか使用できないことに注意する。
　つまり、通常のスクリプトではこの機能は使えない。

・WebRTC,webオーディオAPI,メディアキャプチャとストリームなど、多くの現代的なweb APIは、プロミスベースになっている。

・このモジュールの最初の記事では、プログラム中に長時間実行する同期タスクがある場合に何が起こるかを見た。ウィンドウ全体が全く
　反応しなくなる。これは、プログラムが「シングルスレッド」であることが根本的な原因である。スレッドとは、プログラムが従う一連の命令。
　プログラムは単一のスレッドで構成されているので、一度に1つのことしかできない。つまり、長く続く同期呼び出しが返されるのを待っていると、
　他のことは何もできないのである。

・他の種類のワーカー

　今回の例で作成したワーカーは「専用ワーカー」と呼ばれるもの。これは、単一のスクリプトインスタンスで使用されることを意味する。
　ワーカーは以下のように他にも種類がある。

    共有ワーカー
    　→ 異なるウィンドウで動作する複数の異なるスクリプトで共有することができる。

    サービスワーカー
    　→ プロキシサーバのような役割を果たし、リソースをキャッシュすることで、ユーザーがオフラインの時でもwebアプリケーションを
    　　動作させることができる。プログレッシブwebアプリの重要な構成要素である。

・フレームワークとライブラリの違いは「制御の逆転」である。ライブラリからメソッドを呼び出す場合、制御するのは開発者である。
　フレームワークでは、フレームワークが開発者のコードを呼び出すので制御が逆転している。

・JavaScriptのHTMLElement.styleプロパティでは backgroundColor,textAlignなどキャメルケースで書かれるが、
　本来のCSSの方ではbackground-colorやtext-alignのようにハイフンを使う点に注意する。ここを間違えてしまうと、うまく機能しない。

・同一オリジンポリシーとは、あるオリジンのドキュメントが他のオリジンのドキュメントのDOMにアクセスしようとすると、
　ユーザーエージェントがアクセスを拒否するようなこと。オリジンは、URLのスキーム、ホスト、ポートによって定義される。
　詳細は下記を参照。

　https://www.w3.org/Security/wiki/Same_Origin_Policy

・IndexedDBは、トランザクションデータベースモデルに基づいて構築されている。
　IndexedDB APIには「インデックス」「テーブル」「カーソル」などを表す多くのオブジェクトが用意されているが、これらはそれぞれ特定の
　トランザクションに関連付けられている。そのため、トランザクションの外でコマンドを実行したり、カーソルを開いたりすることはできない。

・「トランザクション」とは、コンピュータ内で実行される、分けることのできない一連の情報処理の一単位を意味する。
　この一連の処理を分割して実行した場合、結果の整合性を保てなくなる。

　トランザクション処理における永続性記憶資源の管理では、複数のデータ項目の更新操作列をすべて実行するか、全く実行しないように
　制御する必要がある。これを「アトミック実行」という。実行前の状態に戻す処理を一般的なデータベース管理システムでは「ロールバック」
　という。バッチジョブのような処理形態でも、出力結果はアトミック実行の概念を満たさなければならない。

・上記から、トランザクションは自動コミットされ、手動でコミットすることはできない。このトランザクションモデルは、
　ユーザーがwebアプリケーション2つのインスタンスを2つの異なるタブで同時に開いた場合のことを考えると、とても有用である。
　トランザクション操作が無ければ、2つのインスタンスが互いの変更に干渉してしまう可能性があるため。

・IndexedDB APIはほとんどが非同期である。同期的な方法でデータベースに値を「格納」したり、データベースから値を「取り出す」ことはしない。
　代わりに、データベース操作を「リクエスト」する形となる。操作が終了するとDOMイベントで通知され、そのイベントの種類によって操作が
　成功したか失敗したかがわかる。

・IndexedDBはDOMイベントを使って結果が利用可能になったことを通知する。成功イベントはバブルアップしないし、キャンセルもできない。
　一方で、エラーイベントはバブリングするし、キャンセルも可能である。これは非常に重要なことで、エラーイベントはキャンセルされない限り
　実行中のトランザクションを中断する。

・IndexedDBはオブジェクト指向である。行と列の集合体であるテーブルを持つ「リレーショナルデータベース」ではないことに注意。
　IndexedDBでは、データの種類に応じてオブジェクトストアを作成し、そのストアにJavaScriptオブジェクトを永続化する必要がある。
　各オブジェクトストアには、クエリや反復処理を効率的に行うためのインデックスのコレクションを持つことができる。

・IndexedDBはSQLを使用せず、インデックスに対するクエリーを使用してカーソルを生成し、そのカーソルを使用して結果セットを反復処理する。

・サードパーティのウィンドウコンテンツ(例:iframeコンテンツなど)は、ブラウザがサードパーティのクッキーを受け入れないように
　設定されていない限り、埋め込まれたオリジンのIndexedDBストアにアクセスすることができる。

・IndexedDBは、以下のようなケースには対応していない。

    国際化に対応した並べ替え
    　→ 全ての言語で文字列が同じように並べ替えされるわけではないので、国際化に対応した並べ替えには対応していない。
    　　Firefox 43以降、実験的なフラグを有効にすることで、「ロケールを考慮した並べ替え」が可能になっている(現在はFirefoxのみ)

    同期
    　→ このAPIはサーバー側のデータベースとの同期を行うようには設計されていない。クライアント側のindexedDBデータベースと
    　　サーバー側のデータベースを同期させるコードを書く必要がある。

    全文検索
    　→ このAPIには、SQLの LIKE 演算子に相当するものが無い。

・IndexedDB APIの理解に関連する主な用語としては以下の通り。

    データベース
    　→ 普通1つ以上の「オブジェクトストア」で構成される、情報の格納庫。それぞれのデータベースには名前とバージョンがある。

    データベースコネクション
    　→ データベースを開くために作成される操作。指定されたデータベースは、同時に複数の接続を保有することができる。

    永続性
    　→ completeイベントが関係している。

    インデックス
    　→ 「参照オブジェクトストア」と呼ばれる別のオブジェクトストアにあるレコードを探すために特化したオブジェクトストア。
    　　インデックスは永続的なキーと値のストレージで、そのレコードの値の部分が参照するオブジェクトストアのレコードのキー部分となる。
    　　インデックス内のレコードは、参照されるオブジェクトストア内のレコードが挿入、更新、または削除されるたびに、自動的に入力される。
    　　インデックス内の各レコードは、参照するオブジェクトストア内の1つのレコードのみを参照することができるが、複数のインデックスが同じ
    　　オブジェクトストアを参照することは可能。オブジェクトストアが変更されると、そのオブジェクトストアを参照している
    　　全てのインデックスが自動的に更新される。

    オブジェクトストア
    　→ データベースにデータを保存する仕組み。オブジェクトストアはレコードを持続的に保持しており、これはキーと値の組。
    　　オブジェクトストア内のレコードは、キーによって昇順に整列して保存されている。すべてのオブジェクトストアには、そのデータベース内で
    　　一意となる名前が必要。オブジェクトストアは、オプションで「キージェネレーター」と「キーパス」を持つことができる。
    　　オブジェクトストアにキーパスがある場合は「インラインキー」、ない場合は「アウトラインキー」が使用される。

    リクエスト
    　→ データベースへの読み書きが行われる処理。全てのリクエストは、1つの読み取りまたは書き込み処理を表す。

    トランザクション
    　→ 特定のデータベースで行う、原子性を持つデータアクセスやデータ変更の操作のセット。これは、データベース内のデータと対話する手段。
    　　実際は、データベース内のデータの読み取りや変更はトランザクション内で実施しなければならない。

    　　書き込みトランザクションの「スコープ」が重ならない限り、一つのデータベース接続で同時に複数のアクティブなトランザクションが
    　　存在できる。トランザクションのスコープは生成時に定義され、トランザクションがどのオブジェクトストアと対話できるかや、
    　　トランザクションの持続期間にわたって保持し続けるかを示す。よって例えば、データベース接続でflyingMonkeyオブジェクトストアのみ
    　　対象とするスコープを持つ書き込みトランザクションが既に存在するとき、unicornCentaurオブジェクトストアや
    　　unicornPegasusオブジェクトストアをスコープで持つ別のトランザクションを開始できる。読み取りトランザクションは、
    　　スコープが重なっていても複数実行できる。

    　　トランザクションは持続期間が短いものを除き、長時間のトランザクションがストレージ資源をロックする状況から解放するために、
    　　ブラウザが終了させることができる。トランザクションを中止した場合、トランザクションによるデータベースの変更箇所はロールバックされる。

    　　トランザクションには、readwrite,readonly,versionchange の3つのモードがある。オブジェクトストアやインデックスの生成及び
    　　削除は、versionchangeトランザクションを使用する場合に限り実行できる。全ての操作はトランザクション内で発生するため、
    　　IndexedDBにおいて重要な概念である。

    バージョン
    　→ データベースを生成したとき、バージョンは整数の1になる。それぞれのデータベースは、一度に1つのバージョンを持つ。
    　　バージョンを変更する唯一の方法は、現在のバージョンより大きなバージョンでデータベースを開くこと。

    インラインキー
    　→ 保存される値の一部として保存されるキー。

    キー
    　→ オブジェクトストアに保存された値は、このデータ値によって編成及び取り出しされる。オブジェクトストアは「キージェネレーター」
    　　「キーパス」「明示的に指定した値」の、3種類の生成源のいずれかからキーを得られる。キーは、自身の前にあるものより
    　　大きな数値を持つデータ型であることが必要。オブジェクトストア内の各レコードはオブジェクトストア内で一意のキーを
    　　持たなければならず、オブジェクトストア内で複数のレコードが同じキーを持つことはできない。

    　　キーは文字列、date、浮動小数点数値、配列のいずれかの型を使用できる。配列では、キーは空の値から無限大までの範囲を使用できる。
    　　また、配列の中に配列を含めることができる。文字列または整数値のキーしか使用できないという条件はない。

    　　代わりに、「インデックス」を使用してオブジェクトストア内のレコードを検索することもできる。

    キージェネレーター
    　→ 指定した順序で新たなキーを生成する仕組み。これはブラウザの実装の細部であり、実際に生成やアクセスを行うことはない。

    キーパス
    　→ オブジェクトストアやインデックスのどこからブラウザがキーを取り出すべきかを定義する。有効なキーパスは空文字列、
    　　JavaScriptの識別子、あるいはそれらを収めた配列のいずれかを含むことができる。空白を含むことはできない。

    アウトオブラインキー
    　→ 保存する値とは別に保存されるキー。

    値
    　→ それぞれのレコードは値を持っており、論理値、数値、文字列、date、オブジェクト、配列、正規表現、undefined、nullを含む
    　　JavaScriptで表現可能なものをどれでも含むことができる。Blobやファイルも保存可能。

    　　オブジェクトまたは配列を保存する場合は、それらのプロパティや値もまた、有効な値をどれでも持つことができる。

    カーソル
    　→ キーレンジに属する複数のレコードにわたって反復処理を行うための仕組み。カーソルは、反復処理を行うインデックスや
    　　オブジェクトストアがどれかを示すsourceを持つ。またレンジ内の位置や、レコードキーの順序について増加方向に移動しているか
    　　現象方向に移動しているかの情報も持つ。

    キーレンジ
    　→ キーとして使用する、何らかのデータ型の連続的な区間。キーまたはキーレンジを使用して、オブジェクトストアやインデックスから
    　　レコードを取り出すことができる。下限又は上限を使用して、レンジを制限又はフィルタリングできる。例えば、キーがxからyの間である
    　　全ての値に対して、反復処理を行うことができる。

    スコープ
    　→ トランザクションの適用先であるオブジェクトストアやインデックスのセット。読み取りのみのトランザクションのスコープは、
    　　同時に重ねあったり実行することができるが、書き込みトランザクションのスコープは重ねあうことができない。同時に同一のスコープで
    　　複数のトランザクションを開始することはできるが、それらはキューに収められ、順番に実行される。

・IndexedDbで推奨される基本パターンは以下の通り。

    1．データベースを開く。

    2．データベース内に、オブジェクトストアを作成する。

    3．データの追加や取り出しといった、データベース操作のトランザクションを開始して、リクエストを行う。

    4．適切なDOMイベントを受け取ることにより、操作が完了するのを待つ。

    5．結果(リクエストオブジェクトにある)に応じた処理を行う。

・データベースを開く

　プロセス全体は以下のようにして始める。

    const request = window.indexedDB.open("MyTestDatabase", 3);

　上記から分かるように、データベースを開くことも他の操作と同様、「リクエスト」が必要である。
　データベースを開くリクエストは、すぐにはデータベースを開いたりトランザクションを開始したりはしない。open()関数を呼び出すと、
　結果(成功)またはイベントとして扱うエラー値を伴う IDBOpenDBRequest オブジェクトを返す。IndexedDBのほとんどの他の非同期関数も
　同様であり、結果又はエラーを伴う IDBRequest オブジェクトを返す。open関数の結果はIDBDatabaseのインスタンス。

　ハンドラーの生成

　ほぼすべてのリクエスト生成に合わせて始めに行いたいことは、成功およびエラーのハンドラーを作成すること。

    request.onerror  (event) => {
        // request.errorCode に対して行うこと
    };
    request.onsuccess = (event) => {
        // request.result に対して行うこと
    }

　すべてが成功すると成功イベント(すなわちtypeプロパティがsuccessであるDOMイベントが)、requestをtargetとして発生する。
　イベントが発生するとrequestのonsuccess()関数が、successイベントを引数として呼び出される。一方、何らかの問題がある場合はエラーイベント
　(すなわちtypeプロパティがerrorであるDOMイベント)がrequestで発生する。これは、エラーイベントを引数としてonerror()関数を呼び出す。

　成功イベントを受け取ったと想定する。次に行うのは、request.resultはIDBDatabaseのインスタンスなので、以降のためにこれを保存すること。
　よって、以下のようにする。

    db = event.target.result;

　エラーを処理する

　エラーイベントはバブリングする。エラーイベントはエラーを発生させたり、リクエストをターゲットにして、さらにトランザクションや
　最終的にデータベースオブジェクトへバブリングする。全てのリクエストにエラーハンドラーを追加する代わりに、以下のように
　データベースオブジェクトにだけ追加することができる。

    db.onerror = (event) => {
        // このデータベースのリクエストに対する全ての
        // 汎用エラーハンドラー
        console.error(`Database error: ${event.target.errorcode}`;
    }

　データベースを開く際によく発生するエラーの一つが VER_ERR である。これはディスクに保存されているデータベースのバージョンが、
　開こうとしているバージョンより大きいことを表す。これは、必ずエラーハンドラーで処理しなければならないエラーの実例である。

　データベースのバージョンの作成と更新

　データベースがまだ設定されていない場合、またはデータベースが既存の格納されたデータベースよりも大きなバージョン番号で開かれた場合
　(アップグレードを実行する場合)に upgradeneeded イベントが発火する。これは、以下のようにまず既存のデータベースへの参照を
　イベントのターゲット(e.target.result)のresultプロパティ(requestオブジェクト)から取得する。次に、createObjectStore()を使用して、
　呼び出されたデータベースの中に新しいオブジェクトストアを作成する。

    openRequest.addEventListener("upgradeneeded", (event) => {
        db = event.target.result;
        const objectStore = db.createObjectStore("objectStore_name", {
            keyPath: "id",
            autoIncrement: true,
        });
    })

    request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const objectStore = db.createObjectStore("objectStore_name", {keyPath: "myKey"})
    };

　addEventListenerを用いる場合は upgradeneeded イベントを使用し、
　openRequestを用いる場合は onupgradeneeded イベントハンドラープロパティを使用する。

　データベースを構築する

　次に、データベースを構築する。IndexedDBはテーブルではなくオブジェクトストアを使用しており、一つのデータベースに複数の
　オブジェクトストアを含めることができる。値をオブジェクトストアへ保存するたびに、値がキーと関連付けられる。
　オブジェクトストアでキーパスを使用するかキージェネレーターを使用するかに応じて、キーを供給する方法がいくつか存在する。
　それらについて、以下の表で示す。

    キーパス    キージェネレーター
    なし        なし
    　→ このオブジェクトストアは、数値や文字列と言ったプリミティブ値を含む、どのような種類の値でも保存できる。
    　　新たな値の追加を望むたびに、個別のキー引数を供給しなければならない。

    あり        なし
    　→ このオブジェクトストアは、JavaScriptオブジェクトのみ保持できる。オブジェクトはキーパスと同じ名前のプロパティを
    　　持たなければならない。

    なし        あり
    　→ このオブジェクトストアは、どのような種類の値でも保持できる。キーは自動的に生成される。
    　　また、特定のキーを使用したい場合は個別のキー引数を取得できる。

    あり        あり
    　→ このオブジェクトストアは、JavaScriptオブジェクトのみ保持できる。通常はキーが生成されて、オブジェクトでキーパスと同じ名称を持つ
    　　プロパティに、生成されたキーの値を保存する。ただしそのようなプロパティが既に存在している場合は、生成された新たなキーではなく、
    　　そのプロパティの値をキーとして使用する。

　オブジェクトストアがプリミティブではなくオブジェクトを保持していれば、オブジェクトストアでインデックスを作成することもできる。
　インデックスは、オブジェクトのキーではなく保存されたオブジェクトのプロパティの値を使用して、オブジェクトストア内に保存された値を
　検索することを可能にする。

　さらにインデックスには、保存されたデータに単純な制限を強制する機能がある。インデックスを作成する際にuniqueフラグを設定(true)すると、
　インデックスのキーパスで同じ値を持つオブジェクトが複数保存されないことを、インデックスが保証する。例えば集団の一人一人の
　メールアドレスを保持する場合など、同じメールアドレスが無いことを保証したい場合は、uniqueフラグを設定したインデックスを使うとよい。

　キージェネレーターを使用する

　オブジェクトストアを作成する時に autoIncrement フラグを設定すると、そのオブジェクトストアでキージェネレーターを使用できる。
　デフォルトでこのフラグは設定されない。

　キージェネレーターを使用すると、オブジェクトストアに値を格納するのに応じて自動的にキーが生成される。オブジェクトストアで
　キージェネレーターを初めて作成した時点では、キージェネレーターの値が1になる。基本的に、新たに自動生成されるキーは、前のキーから
　1増加した値になる。データベースのトランザクションが中止されるなど、データベースの操作が取り消された場合を除き、キージェネレーターの
　現在の値が減少することはない。したがって、オブジェクトストアからレコードを削除したり、すべてのレコードをクリアしたりしても、
　オブジェクトストアのキージェネレーターには影響がない。

　データの追加、読み取り、削除

　新しいデータベースで何かを行えるようにする前に、トランザクションを開始しなければならない。トランザクションは
　データベースオブジェクトから生じており、トランザクションの対象にしたいオブジェクトストアを指定しなければならない。
　トランザクションの内部では、データを保持しているオブジェクトストアへのアクセスや、リクエストの実行が可能。
　次にデータベースに変更処理を行うのか、あるいは読み出すだけかを決める。readonly,readwrite,versionchange の3つのモードを使用できる。

　データベースのスキーマや構造を変更する(オブジェクトストアやインデックスを作成または削除する)には、トランザクションを
　versionchange モードにしなければならない。このトランザクションは version を指定して IDBFactory.openメソッドを呼び出すことによって開く。

　データベースからのデータの取得

　データベースは情報を持っているので、いくつかの方法でデータを読み出すことができる。まずは、単純にget()を使用する。
　値を読み出すためにキーを提供しなければならない。データベースからの単純な情報の読み出しとしては以下のような形。

    const transaction = db.transaction(["customers"]);
    const objectStore = transaction.objectStore("customers);
    const request = objectStore.get("444-44-4444);
    request.onerror = (event) => {
        // エラー処理
    };
    request.onsuccess = (event) => {
        // request.result に対して行う処理
        console.log(`Name for SSN 444-44-4444 is ${request.result.name}`);
    };

　単純な読み出しでも多くのコードがある。なお、データベースレベルでエラー処理を行うのであれば、コードを少々短縮できる。

    db
      .transaction("customers")
      .objectStore("customers")
      .get("444-44-4444").onsuccess = (event) => {
        console.log(`Name for SSN 444-44-4444 is ${event.target.result.name}`)
      };

・

=================================================================================================================================