Win32 API 勉強メモ

・API(Application Programming Interfaces) = アプリケーションからOSを操作するための手段。

・16ビットアーキテクチャのWindows APIをWin16と呼び、32ビットWindowsのAPIをWin32と呼ぶ。
　16ビットから32ビットアーキテクチャへの移行時にはAPIにも大きな変更が加えられ、いくつかの過去のAPIを使うことを推奨されない。

・Windowsプログラミングの基本概念は「動的リンキング」となる。Windowsはディスプレイなどに表示するグラフィックス関数をサポートしている。
　アプリケーションはWindowsの関数を呼び出し(ファンクションコール)その機能を利用する。Windowsがサポートする関数は数千とあり、
　これらのファンクションはダイナミックリンクライブラリ(DLL)が用意している。拡張子は一般に*.dll,しばしば.exeの時もある。

・WindowsのファンクションはC言語などの標準ライブラリとは異なり、プログラムの外部に存在し、プログラムから関数のエントリポイントに
　アクセスする。DLLの名前や位置は「インポートライブラリ」が提供している。プログラムはWindowsプログラムを生成する時、まずこれに
　リンクしなければならない。//インポートライブラリは、開発環境がサポートしている。

・Windowsプログラムの場合、基本的にコンパイルするだけではいけない。VC++の場合、「ファイル」→「新規作成」→「プロジェクト」から
　「Windowsウィザードアプリ」を選択する。

・まずWindowsプログラミングのためにはヘッダファイルのインクルードが必要。Windowsプログラムの型や構造体、定数やファンクションコールを
　するためにそれを定義したヘッダファイルをインクルードする。Windowsプログラムの主要なインクルードファイルは「Windows.h」となる。

・Windowsプログラムにmain()関数は無く、WinMain()関数からプログラムが開始される。
　WindowsアプリケーションエントリポイントはWinMain()関数。

・エントリポイント = コンピュータプログラムを実行する際に、最初に実行することになっている箇所のこと。

・WINAPIはWINDEF.Hヘッダファイルで #define WINAPI__stdcall のように定義されている。__stdcallはWin32API関数を呼び出すときの規約。
　ほとんどのWindows関数はWINAPIと定義されている。

・Windowsでは次の基本データ型を次のように定義している。以下のデータ型の定義はWINNT.Hヘッダファイルのもの。

　　typedef char CHAR;
　　typedef short SHORT;
　　typedef long LONG;

　また、ワイド文字は typedef wchar_t WCHAR; のように定義されている。

・Microsoftは、wcを変数名の先頭に着けるように推奨している。これは「ハンガリー記法」という記述法で、変数名を見ただけで型が分かる。
　例えば、wcStrという変数名はWCHAR型であることがわかる。Windowsプログラミングではこのハンガリー記法による記述が推奨される。

・WinMain()関数の第三引数の型LPSTRは次の定義になっている。

　　typedef CHAR* LPSTR;

　LPSTRのLはLongを表すもので、16ビット時代の産物であるということからPSTR(Pはポインタ)というものも存在する。

・実はSDKではUnicodeが定義されていればワイド文字を定義し、Unicode未対応であればchar型の1バイトでコンパイルするような方法がある。
　それが、TCHAR型、*PTCHAR型を用いるもの。これら2つのデータ型は次のような定義となっている。

　　#ifdef UNICODE
　　typedef WCHAR TCHAR, *PTCHAR;
　　#else
　　typedef char TCHAR, *PTCHAR;
　　#endif

・「typedef 既存のデータ型名 新しい型名」 で既存のデータ型に新しい名前を付けることができる。

・TEXTマクロは、UNICODEが定義されているかどうかで文字列にLを付加する。

　　#define__T(x) L##x

　これが最終的なマクロとなり、TEXT(x)はこれにxを渡す。UNICODEが定義されていなければ何もしない。

・Win32の場合、Unicodeや型の関係からsprintf()を使うわけにはいかない。そこでwsprintf()関数を使う。

・char型は1バイト、つまり最大255種類の文字種を保存できる。しかしグローバル化しつつあるこの世界で255種類の文字しか格納できないのは
　明らかに不十分。そこで作られたのがUnicodeと呼ばれる文字セット。これは2バイトの文字のため255*255種類の文字を格納でき、C/C++では
　wchar_t型になる。wchar_t型の文字列は、L"Hello" のように文字列リテラルの前に L をつける必要がある。

　Windows APIの関数には A と W と 無印 がある場合がある。AはANSI、Wはワイド文字、無印はコンパイル環境に応じて自動選択を意味する。
　しかし無印の「自動で」というのは「コンパイル時の設定に応じて」という意味であり、「引数に応じて自動選択」ではない。
　つまり、コンパイル時の設定がUnicodeなのに MessageBox(NULL, "Hello", …) と書くとエラーになる。
　つまり、無印はエラーの温床となってしまう。
　この問題を解決するために"Hello"をコンパイル時の設定に応じて自動的にLにしたりLを外したりする機能が必要となる。
　これがTEXTマクロとなる。

・Win32がUnicodeの関係でANSI C標準の文字列関数を使えない。正確には使えないというわけではないが、
　移植性が低下してしまう。(wsprint()関数がいい例)
　そのため、Win32APIはstrcpy()やstrcat()などの文字列関数のWindows版を提供している。
　例えば、文字列をバッファにコピーするにはlstrcpy()関数を使う。

・TCHAR型はマルチバイト文字とワイド文字の両方に対応するための型。Unicode対応の環境用プログラムと非対応の環境用のプログラムを
　一つのソースコードでコンパイルできるようにするための仕組みであり、Unicodeが定義されている時はwchar_t型、
　定義されていないときはchar型と同一となる。

・TEXTマクロはT()でも記述可能。短いのでこちらの方が良いかも。冗長を持たせたい場合はTEXT()でよい。

・LPTSTR,LPCTSTRなど紛らわしいこれらの型については、以下のような規則で型の名前が作られている。

　　LP = ポインタ(*)
　　C = const
　　TSTR = TCHAR
　　STR = char
　　WSTR = WCHAR

　つまり、それぞれの型をこれに当てはめて読み解くと、以下のようになっていることがわかる。

　　LPSTR = char*
　　LPCSTR = const char*
　　LPTSTR = TCHAR*
　　LPCTSTR = const TCHAR*
　　LPWSTR = WCHAR*
　　LPCWSTR = const WCHAR*

・これはC言語の知識だが、main関数の引数は一般的にはvoid型、または無指定となるがmain関数は次のように書くこともできる。

　　int main(int argc, char *argv[]) {…}

　この例ではint型の引数と、char*型の配列引数を受け取るようになっている。
　main関数はプログラムの実行時に自動的に呼び出されるため、コード中でmain関数に引数を指定して呼び出すことはない。
　main関数の引数はプログラムの実行時にOS(Windowsなど)から渡される。これを「コマンドライン引数」という。

　main関数の第一引数 argc は普通のint型変数(引数)。これは次の引数 argv[]の要素数が格納されている。
　第二引数の argv には実際に受け取ったコマンドライン引数の文字列が配列で格納されている。ポインタの配列なので、
　複数の文字列を同時に受け取れる。Windowsでは最初の要素には実行ファイル自身のフルパス名が格納されるらしい。

　例えばWindows上で何かのプログラムを起動する場合、普通はプログラムのアイコン(実行ファイル)を選択してEnterキー、
　またはダブルクリックして起動するが、プログラムによっては「起動オプション」というものがある。例えばメモ帳は、
　そのまま起動すれば中身が空の状態で起動する。しかし、メモ帳のアイコンにテキストファイルをドラッグ&ドロップして開けば、
　そのテキストが開かれた状態で起動する。プログラム(実行ファイル)にファイルをドラッグ&ドロップすると、そのプログラムにドロップした
　ファイルのパスが渡され、パスを受け取ったプログラムはそのファイルを自動で開くなどの処理を行う。このように、外部から値を指定して
　プログラムを実行したとき、その値を受け取る方法がコマンドライン引数であり、コマンドライン引数はmain関数の引数として受け取れる。

・WinMain関数は第三引数がコマンドライン引数となっているため、コマンドラインからの立ち上げや、ファイルのD&Dでの立ち上げに
　アプリケーションが対応することができる。WinMain関数の第三引数は配列ではない。トークンの分解はしていなく、
　スペースも含めた一つの文字列として格納する。

・WinMain関数からコマンドライン引数へアクセスすることができるが、専用のGetCommandLine関数から得ることも可能。
　何より、WinMainの第三引数はプログラム本体の引数を得ることができないが、
　GetCommandLine関数からは実行ファイルの名前を得ることができる。

・Windowsプログラミングではウィンドウの生成は二つの作業に分かれる。1つはウィンドウクラスの登録。比較的汎用的な設定を行い、
　これを登録して使いまわすことができる。もう1つは、直接的なウィンドウの生成作業。登録されている「ウィンドウクラス」を基盤に
　ウィンドウを生成する。

・Windowsの全てのウィンドウにはハンドルが存在し、ウィンドウを操作するには関数にハンドルを渡すことで
　どのウィンドウを操作するのかを知らせることができる仕組みとなっている。

・CreateWindow関数で作られ、デフォルトで返されたウィンドウハンドルは不可視状態となる。ウィンドウの表示状態の変更には
　ShowWindow関数を使用する。

・コンボボックスとは、ドロップダウンリストに直接文字を入力できる機能を追加したもの。

・Win32では、ウィンドウの処理に「メッセージ」と呼ばれるものを使う。
　メッセージは、ユーザーがウィンドウに対して要求した内容を格納している。

・メッセージは「キュー」として格納されている。これを「メッセージキュー」と呼び、アプリケーションはキューからメッセージを取り出す。

・ShowWindow関数を使用せずにウィンドウを表示するには、CreateWindow関数のスタイル指定で WS_VISIBLE を指定する。
　このスタイルは仮死状態のウィンドウを作成するスタイル。

・ウィンドウプロシージャの最後にDefWindowProc関数を呼び出さないと、基本的なウィンドウの動作ができなくなる。

・DefWindowProcがウィンドウを破棄した時、この関数はウィンドウプロシージャに WM_DESTROY をディスパッチする。
　ウィンドウプロシージャでこれを監視し、WM_DESTROYメッセージを受け取った時に適切な終了処理をすれば、
　スマートにプログラムを終了させることができる。

・WinMain関数がWindowsに返す値だが、終了コードは必ずWS_QUITのwParamの値でなければならないとされる(もっとも多くの場合この値は0になる)

・プロシージャのメッセージの判定は、1つのメッセージしか処理しないのならばifでも問題はないが、通常処理するメッセージは複数のため
　一般的にメッセージの判定にはswitchを使用する。

・DefWindowProcがウィンドウを破棄する過程としては、ユーザーが"閉じる"などを選択し、ウィンドウの破棄を要求すると
　DefWindowProcはウィンドウプロシージャに「WM_SYSCOMMAND」メッセージを送る。さらに、DefWindowProcがこれを受け取ると
　ウィンドウプロシージャに「WM_CLOSE」を送る。DefWindowProcはWM_CLOSEを受け取るとDestroyWindow関数を呼び出す。
　この関数は、指定されたウィンドウを破棄する。

・ウィンドウを破棄しないようにするためにはDefWindowProc関数にウィンドウプロシージャからWM_CLOSEを渡さないようにすればよい。

・メッセージは全てがメッセージキューにポストされるわけではない。キューに入るメッセージのほとんどは、
　ユーザーからの入力によるメッセージ。WM_RBUTTONUPなどのメッセージがそれにあたる。しかし、それ以外に関数などから
　ダイレクトに送られるメッセージもある。メッセージはメッセージキューに入ることなくウィンドウプロシージャに送られる。
　例えば、CreateWindow関数はウィンドウを生成する前にWM_CREATEを送る。これはメッセージキューではなく、
　適切なウィンドウプロシージャに直接送られる。

　このメッセージは、パラメータlParamに「CREATESTRUCT構造体」へのポインタを含む。

・WM_CREATEメッセージは戻り値でウィンドウの生成を制御できる。このメッセージを処理したときに0を返すとウィンドウを生成し、
　ウィンドウを生成しない場合は-1を返す。-1を返した場合、ウィンドウは生成されないのでCreateWindowはNULLを返す。

・WM_CREATEメッセージはウィンドウ生成時の初期化処理などにも用いることができる。

・ウィンドウの初期位置や大きさにこだわらないアプリケーションで初期設定に迷うのならば、デフォルトの値を使う方が効率が良い。
　CreateWindow関数の、ウィンドウの位置とサイズ指定の場所に「CW_USEDEFAULT」定数を指定すると、関数はこの引数を無視し、
　そのアプリケーションを起動したときの位置などはWindowsに委ねられる。

・Windowsのテキストというのは、コンソールに文字を表示するのとは概念が違う。
　Windowsでは、ウィンドウや文字も含め全てを「画像」として扱う。
　そのため文字を「出力」ではなく「描画」するという表現がふさわしい。

・クライアントエリアに描画するには「GDIファンクション」を用いる。GDIとは「Graphics Device Interface」のことで、
　グラフィック関連のサブシステムのこと。

・グラフィックス関連の処理を行うためには、まず「デバイスコンテキスト」を得る。これは、GDIが管理する構造体で、
　ウィンドウや表示デバイスに対応している。GDIファンクションを利用するには、まずデバイスコンテキストのハンドルを取得する。
　デバイスコンテキストのハンドルはHDC型。デバイスコンテキストのハンドルを取得するにはGetDC関数を利用する。

・Windowsには「隠された部分は保証しない」という特性がある。クライアントエリアが他のアプリケーションなどで隠された場合、
　文字部分が消されているなどその内容を保証されない。Windowsは、ウィンドウに隠された部分を保存しない。
　(マウスやアイコンのカーソルの時は保存する)

・クライアントエリアが隠された場合、クライアントエリアの情報は消されてしまう。
　その後、再びクライアントエリアが表示されるとその領域は空の状態となる。この状態を「無効リージョン」または「更新リージョン」と呼ぶ。
　無効リージョンがウィンドウにある場合、Windowsは「WM_PAINT」メッセージを発行する。
　このメッセージは無効リージョンが存在する限り、常にメッセージキューにポストされる。WM_PAINTは、
　wPalamにデバイスコンテキストのハンドルを持つが、一般に無視する。戻り値は0を返す。

・アプリケーションは無効リージョンを有効な状態にしなければならない。そのためには、背景を背景色で塗りつぶす必要がある。
　しかも、全体を描くのではなく、無効な領域だけを再描画する。この作業の多くもWindowsファンクションが行ってくれる。
　このように、ウィンドウごとの情報をWindowsは構造体で扱っている。その構造体がPAINTSTRUCT構造体となる。

・もしウィンドウプロシージャでWM_PAINTを処理する場合、必ずBeginPaintとEndPaintを使う。

・TextOut関数で文字を表示する場合、文字列内に\nを指定しても残念ながらTextOut関数はこれをサポートしないため改行されることはない。
　ではどうやって改行を表現するのかというと、フォントの詳細情報を持つ「メトリックス構造体」を得れば良い。
　この構造体を理解することは、テキスト操作に非常に重要となる。

・Windowsでは文字の幅はその文字ごとに違う。このようなフォントを「プロポーショナルフォント」と呼ぶ。
　これに対し、全てのフォントが同じ幅のフォントを「固定ピッチフォント」と呼ぶ。

・フォントが実際に描画されたときの具体的な描画属性やサイズはフォント情報だけでは決定できず、そのデバイスに依存する部分がある。
　そのため、GetTextMetrics関数はHDCを要求する。

・TextOut関数が位置や文字列を受け取れることに対し、文字のフォントや文字サイズ、文字の色などが設定できないように、
　このような使いまわしが予想される汎用的な設定部分は関数ではなくデバイスコンテキストの設定値となる。多くのGDIファンクションは
　デバイスコンテキストのハンドルを受け取る。細かい設定は、ここで行うことで関数が冗長になることを防いでいる。
　だからこそ、TextOut関数も少ない引数で文字列を表示できる。

・文字色の指定でわかるようにデバイスコンテキストはその属性を参照する。

・一度デバイスコンテキストの属性を設定してもウィンドウプロシージャの終了時にそれは破棄されてしまう。
　しかし、WNDCLASS構造体のメンバに「CS_OWNDC」を指定すればデバイスコンテキストの属性が保存される。
　これを利用すればWM_CREATEなどが発生したときに、一度だけデバイスコンテキストの属性を指定するだけで、
　以降デバイスコンテキストを取得したときの属性もすべて影響される。

・WNDCLASSを用いてデバイスコンテキストの属性を保存することもできるが、一般的にデバイスコンテキストの属性を保存する方法としては
　SaveDC関数とRestoreDC関数を用いる方法が推奨される。CS_OWNDCと異なり、この方法を一時的な保存に適している。

・デバイスコンテキストの属性を操作することで、背景色を指定できる。背景色は、ウィンドウの背景ではなく描画した文字などの背景。
　デフォルトで背景色は白だが、これを変更することができる。実は文字などを描画する時にプログラムは背景色で塗りつぶしてから
　文字を描画している。

・線などの一部の描画命令は、カレントポジションの影響を受ける。線の始点はカレントポジションから始める。

・長方形や円を描くファンクションが用意されているため、専用のファンクションによって描画した方がはるかに効率が良い。
　これらのファンクションは線の描画命令とは異なり、カレントポジションの影響を受けない。一見すると線を描画しているように思えるが、
　これは背景を塗りつぶす。これらのファンクションが受ける影響は「ブラシ」と「ペン」という属性。ファンクションはペンで外枠を描画し、
　内部をブラシで塗りつぶす。

・ブラシの属性はデフォルトで白、ペンは黒のためデフォルトでは線描画のように見える。

・グラフィックスシステムは右としたの1ピクセルが重要になる。右下端を図形に含めるシステムもあるが、
　Windowsファンクションはこれを含めない。つまり、長方形を指定したとき、右と下の外枠は指定した値より-1ピクセルの位置にある。

・ベジェ曲線とは、CGで用いられる曲線手法の1つで、いくつかの座標から曲線を表現する。たとえば、4つの点から描画するベジェ曲線は
　「3次ベジェ曲線」と呼ぶ。このようなパラメータから表現する曲線を「パラメトリック曲線」と呼ぶこともある。

・これまで描画してきた図は黒い外枠で描画されていた。これらは、デバイスコンテキストに設定されている「ペン」と呼ばれる属性。
　つまり、このペン属性を変更すれば線の色や太さを変えることができる。

・Windowsはデフォルトで定義済みのBLACK_PENが設定されている。これは太さ1ピクセルの黒いペン。同様に、定義済みのペンで白いWHITE_PENと
　描画しないNULL_PENがある。これらも、GetStockObjectファンクションから取得することができる。

・既に定義されているペンは黒と白、そして何も描画しないペンしかない。これ以外の色や太さのペンで描画するにはまずペンを作る必要がある。
　自分で作ったペンは色や太さなどを自由に変えることができる。ペンオブジェクトを作成するにはCreatePenファンクションを用いる。

・ペンやブラシなどを総称して「GDIオブジェクト」という。カスタムで生成したGDIオブジェクトに共通することで、
　注意しなければならないことがある。まず、作成したGDIオブジェクトは「必ず削除しなければならない」ということ。
　デバイスコンテキスト同様に、ウィンドウプロシージャが終了する前にこの作業を行う。
　作成したGDIオブジェクトを破棄するにはDeleteObjectを呼び出す。DeleteObjectを呼び出す際、決して有効なデバイスコンテキストが
　選択中のGDIオブジェクトを削除してはいけない。つまり、EndPaintの後にDeleteObjectを行わなければならない。
　この2点に気を使いながら、GDIオブジェクトを扱う必要がある。

・破線を描画したとき、線と線の空白には背景色と背景モードによる属性の色が描画される。

・LOGPEN構造体を用いてCreatePenIndirectファンクションでカスタムペンを使用する場合、GDIオブジェクトを削除する場面で
　HPEN型の変数を用意していないため、SelectObjectファンクションの戻り値である以前のオブジェクトのハンドルを
　取得し、それをDeleteObjectに指定するなどして破棄する必要がある。

・閉じた図形の内面を塗りつぶすのは「ブラシ」となる。ブラシはペン属性同様にGDIオブジェクトで、SelectObjectで指定することができる。
　以後、長方形や円などの閉じた図形の内面はブラシで塗りつぶされる。また、ウィンドウの背景色もブラシ。
　定義済みのストックオブジェクトとして白のWHITE_BRUSH、黒のBLACK_BRUSH、灰色のGRAY_BRUSHなどが用意されている。

・CreateSolidBrushはもっとも簡単なブラシの作成ファンクションだが、これ以外にも「ハッチ」と呼ばれる特殊なブラシがある。
　ハッチブラシは、水平、垂直、斜め45度などに連続した線(ハッチパターン)で閉じられた図形の内面を塗りつぶすというもの。
　線と線の間は、背景色と背景モードで決定される。

・高度な描画操作の一つとして「ラスタオペレーション」がある。これは高度なグラフィックシステムの開発に必ず役に立つ。
　ピクセルの描画は、描画される前にある2つの値が比較される。それは、「描画される色(ソース)」と「画面の色(ディスティネーション)」。
　簡単に考えて、白を0黒を1として比較すれば描画しようとしている色と画面の色を比較して、その結果で描画命令を実行するとすれば
　ピクセルレベルの操作を全体的に、しかも簡易に行うことができる。このようなピクセルレベルのビットの操作を
　「ラスタオペレーション(ROP)」と呼び、2つのピクセルを操作することを「バイナリラスタオペレーション(ROP2)」と呼ぶ。
　2つのピクセルとは、描画する色と画面の色の2つ。

　このラスタオペレーションでは、例えば画面の色が白の時は黒を出力し、画面の色が黒の時は白を出力するというような排他的な論理演算による
　操作などは、このラスタオペレーションで行うことができる。

・ラスタオペレーションの設定をするにはSetROP2ファンクションを使う。ただし、この設定はラスタデバイスのみで有効となる。
　ディスプレイはラスタデバイス。

・Polylineは連続した線を描画する関数だが、閉じた図形の多角形を描画するには「polygon関数」を使う。
　この関数は、始点と終点を最後に結ぶことで閉じた図形として描画される。Polylineと異なり、内部はブラシによって塗りつぶされる。

・多角形の場合は「多角形塗りつぶしモード」と呼ばれる特殊な属性がある。
　これは、複数の線が重なり交差しあう複雑な多角形で効果を発揮する。
　多角形塗りつぶしモードを設定するにはSetPolyFillModeファンクションを用いる。

・キーボードイベントは、キーボードが押された時点で発生するが、それは直接メッセージキューに入るわけではない。キーボードイベントはまず
　「システムメッセージキュー」という場所に格納される。理由は単純で、メッセージの同期を取るため。
　キーボードイベントはアプリケーションがそれを処理するよりも速い速度でタイプすることができる。しかし、基本的にキーボードイベントは
　アクティブなウィンドウに対して送られるが、キューのメッセージの途中でアクティブなウィンドウが切り換えられた場合、
　その後のキーイベントは切り替わったウィンドウに送られるべき。

　上記を行うために、まずシステムメッセージキューに「キーイベント(キーストローク)」をセットし次のメッセージを送り先アプリケーションの
　メッセージキューにセットする。キーボードイベントは、基本的にアクティブなウィンドウとその子コントロールに有効。
　コントロールとはウィンドウを含むボタンやラジオボタンなどGUIを形成するWindowsの部品を指す。このようなキーボードからのメッセージを
　受け取る権利を「入力フォーカス」とも呼ぶ。キーボードのキーが押されると、入力フォーカスを持つプログラムのメッセージキューに
　押された場合は「WM_KEYDOWN」が、離した時は「WM_KEYUP」がポストされる。

　Windowsはキーボードのキーを「仮想キーコード」として扱う。デバイスに依存する数値ではなく、仮想コードを定義して論理的に扱う。
　仮想キーコードの値は、ウィンドウプロシージャの第三引数WPARAMに格納されている。これらのメッセージは、0を返す。

・Windowsウィザードを選択する際、コンソールアプリケーションではなくWindowsデスクトップ？アプリケーションを選択する。

・user32.dllはWindows API機能を関連付けたWindowsのユーザーインターフェースを含んでいるモジュール。
　user32.dllはPCを適正に動作させるためのシステムプロセスとなる。ここでエラーが起こる理由は主に、PCで稼働しているアプリケーションに競合がある
　ことにより生じるもの。実際起こったエラーには、wuser32.dllが読み込めない、user32.dllが読み込めない、user32.dllでアクセス違反が発生など。
　あとはwuser32.dllのソースがuser32.dllにあるがそのソースが読み込めない、みたいなのも出ていた。
　　→　「デバッグ」→「プロジェクト名のデバッグプロパティ」→「詳細」の「デバッグライブラリの使用」を「いいえ」にすると解決した。

・WM_KEYDOWNやWM_KEYUPは、LPARAMにはその他の情報が入力されており少し複雑だが、32の各ビットで6つのフィールドに分かれて情報を格納している。

　最も重要なのは0～15ビットの「リピート情報」と呼ばれる情報で、通常は1。プログラムの処理速度以上の速さでキーイベントが発生している場合は
　1より大きな数になる。例えば、キーを押し続けた場合はWindowsに設定されている速度で連続にKEY_DOWNが発生する。しかし、処理が間に合わない場合は
　Windowsはメッセージをまとめてリピートを代わりにセットする。これを無視するか処理するかはプログラマの責任となる。リピート情報が1以外の情報に
　なるのは押したときのメッセージのみで、離した時のメッセージは常に1となる。

　16～23ビットまでは「OEMスキャンコード」と呼ばれるもの。これは低水準な分野のコード。一般的にこの値は無視する。

　24ビット目の値は拡張キーフラグ。IBM拡張キーボードで追加されたキーストロークなら1にセットされる。キーボード右側のAltやCtrl、
　テンキー以外の方向キーなどの場合は1になる。

　29ビット目には「コンテキストコード」というものがセットされる。これはAltが押されている場合は1になる。

　30ビット目は直前のキーの状態を意味する。直前に発生したキーイベントが離されたものであれば0、押された状態のものならば1であり、
　キーを離した時の状態は常に1になる。直前のキーストロークが押し続けて発生したオートリピートの監視に使える。

　最後の31ビット目は、キーが押されたものであれば0、離されたものであれば1になる。これは、WM_KEYDOWNでは0、WM_KEYUPなら1になる。

・AltキーはWM_KEYDOWNやWM_KEYUPを発行していない。なぜならば、これはアプリケーションよりもWindowsシステムに重要なキーストロークだから。
　例えば、Alt + Tabでアクティブウィンドウを切り替えたりすることができる。しかし、このようなシステム側のメッセージを受けることもできる。
　押されたときは「WM_SYSKEYDOWN」、離した時は「WM_SYSKEYUP」となる。これはAltと他のキーで生成されるメッセージ。
　それ以外はWM_KEYDOWNとWM_KEYUPと同じ。

・WM_KEYDOWNはキーが押されたときに発生するメッセージだが、これはどのキーが押されたとかと言う部分に興味を示さない。
　もし、入力された文字や数値に興味がある場合はこれだけでは処理ができない。仮想キーコードを実際の文字に変換するには
　TranslateMessageファンクションを用いる。

・Altキーを押しながらのシステムキーストロークを処理したい場合、WM_SYSCHARメッセージを使う。システム文字であるということ以外は
　WM_CHARメッセージとパラメータは同じ。さらに、これ以外にアメリカ使用以外のキーボードを使用している場合、その国語独自のアクセント文字などが
　存在する。このようなキーを「デッドキー」と呼ぶが、これに対するメッセージとしてWM_DEADCHAR、WM_SYSDEADCHARがある。

・キーボードに関係するプログラムにおいて、フォーカスは重要。キーボードからの入力はフォーカスを持つウィンドウに対して行われる。
　ウィンドウのフォーカスの監視はメッセージで行える。フォーカスを得ると「WM_SETFOCUS」、失うと「WM_KILLFOCUS」がポストされる。
　これを処理することで、フォーカスの取得時や小執事に何らかの処理を行える。

・ゲームなどで、フォーカスが無い状態ではプログラムを動作させたくないという時にはフォーカスを失った時に
　プログラムを停止するようにすればよい。

・リージョンとは、画面内の領域を表すオブジェクトの一つで、専用のハンドルを持つ。グラフィカルプログラムにおいて、
　リージョンの知識は無くてはならないもの。なぜならば、リージョンは矩形や多角形、円などの複数の図形を合わせた
　複雑な領域を表す一つのハンドルだから。

　今まで、描画処理をそれぞれ固有の形を表すファンクションで行っていた。しかし、RectangleやEllipseなどの閉じた図形はリージョンとして
　あらわすこともできる。それも、描画したい形をリージョンとして登録するだけなので、描画したい形によってファンクションを使い分ける必要が無い。

・リージョンのハンドルは「HRGN型」となる。リージョンを生成するには、様々な専用ファンクションを用いる。

・状況によって描画する形を変化させなければならない場合、描画ファンクションはFillRgnなどを使い、形の設定は別の処理として行える。
　ユーザーに形を設定させる画像編集ソフトなどの分野で、性能を発揮することが予想される。

・イベントなどによって何らかのパラメータに変更があった時、ウィンドウ全体または一部を再描画したい時がある。
　このような場合はWM_PAINTを呼び出せばいいのだが、WM_PAINTが呼び出されるのは無効リージョンが存在する時。
　そこで、プログラム側で明示的に「無効領域を作る」ことでWM_PAINTを生成する、つまり領域を描き直すことができるようになる。
　これを行うにはInvalidateRectファンクションを用いる。

・デバイスの情報を得るだけでなく、Windowsの設定やウィンドウを構成する各要素のサイズなどを得る方法もある。ウィンドウを構成する要素とは、
　タイトルバーやスクロールバーなどのサイズのこと。また、マウスが接続されているかどうかなどの情報も知ることができる。
　これらシステムの情報を得るにはGetSystemMetricsファンクションを使用する。

・Win32 APIにはNTと9xで互換性のないものがいくつかある。これらを使いたい時はOSの種類をあらかじめ取得し、
　その結果に応じて呼び出すべきファンクションを決定しなければならない。OSの情報を得るにはGetVersionExファンクションを使用する。

・マウスの存在は時代によって異なっており、Windows発表当時から2つボタンのマウスが標準だったわけではない。
　当時は1つボタンのマウスユーザーへの配慮のために、マウスの2つ、3つ目のボタンをプログラムで使用することは避けられていた。
　このような背景があることをよく覚えておいた方が良い。もしマウスやボタンの数に依存するプログラムを作る場合、必ずGetSystemMetrics
　でチェックすることが推奨される。

・マウスには「押す」「離す」の基本動作がある。メッセージはこれらの動作を左、右、中央のボタンに分けて処理できる。
　WM_LBUTTONDOWN,WM_LBUTTONUPなど。処理したとき、戻り値は全て0を返す。これらのメッセージはウィンドウプロシージャの
　第三引数WPARAMにマウスボタンとShiftとCtrlキーの状態を格納している。MK_LBUTTONが格納されていれば左ボタンが押されている、
　MK_SHIFTならShiftキー、MK_CONTROLならCtrlキーが押されている、とわかる。GetKeyStateファンクションを使うことも1つの方法だが、
　基本的にマウス処理の場合はこのパラメータを使った方が便利となる。

　ウィンドウプロシージャ第四引数LPARAMにはマウスの座標が入る。クライアントエリアの左上を原点とした座標で、上位16ビットにy座標、
　下位16ビットにx座標がそれぞれ格納されている。これらのパラメータはシフトやキャストで取り除いても問題ないが、一般的には
　LOWORDマクロとHIWORDマクロを使用する。

・カーソルがクライアントエリアの上を移動すると「WM_MOUSEMOVE」が発生する。メッセージのパラメータはWM_LBUTTONDOWNなど、
　他のマウスメッセージと同じ。

・if(a & b)はaとbとのビットごとの論理積(AND)をとる。結果が0だったら偽、0以外だったら真。つまり、if(wp & MK_LBUTTON)とすることで、
　左ボタンが押されている状態ならば0以外を返すため、マウスの状態を調べることもできる。

・送られるWM_MOUSEMOVEの数は処理能力で異なってしまう。実際にドラッグすると半径2ピクセルの円を描画し続けるサンプルプログラムで
　素早くドラッグすると点と点の間が大きく空いてしまうように。また、WM_MOUSEMOVEは非アクティブでも受け取る。そのため、
　別のウィンドウがアクティブの状態でも、マウスがウィンドウの上を通過すればウィンドウはWM_MOUSEMOVEメッセージを受け取ることができる。

・ダブルクリックのメッセージは「WM_LBUTTONDBCLK」のようになっている。ただし、これらはそのままでは発生しない。
　WNDCLASSのstyleメンバの指定に「CS_DBLCLKS」を加える必要がある。もしCS_DBLCLKSを指定していなければ、例えば左ボタンの連続したクリックは
　WM_LBUTTONDOWN → WM_LBUTTONUP → WM_LBUTTONDOWN → WM_LBUTTONUP　ところが、CS_DBLCLKSを指定していれば次のようになる。
　WM_LBUTTONDOWN → WM_LBUTTONUP → WM_LBUTTONDBLCLK → WM_LBUTTONUP　2回目のWM_LBUTTONDOWNがWM_LBUTTONDBLCLKに変化している。
　これは、物理的に近い位置で設定されているダブルクリック間隔の時間に行われた場合。

・まれに、タイトルバーなどに対するマウスメッセージなど、クライアントエリア以外の位置でクリックされたマウスメッセージを処理したい場合がある。
　これらのメッセージは通常DefWindowProcに渡され、ウィンドウの移動やサイズの変更などに利用されているが、プログラム側でこれを受け取り、
　独自の処理を行うことも可能。非クライアントエリアのマウスメッセージは「WM_NCLBUTTONDOWN」、「WM_NCLBUTTONUP」、「WM_NCLBUTTONDBLCLK」
　のようになっている。また、マウスカーソルの非クライアントエリアの移動は「WM_NCMOUSEMOVE」が発生する。
　非クライアントエリアのマウスメッセージは、全て通常のマウスメッセージに対応している。

　しかし、大きく違うのが受け取るパラメータの内容。第三引数のWPARAMには非クライアントエリアの場所を表す値で、これを調べることで
　非クライアントエリアのどの部分が押されたのかを知ることができる。例えば、HTCAPTIONならタイトルバーの領域内を示す。
　また、第四引数のLPARAMにはマウスの座標が入っている。ただしこの座標は「スクリーン全体から見た座標」となる。
　通常はディスプレイの左上を0,0とする。

・これまでいくつかマウスメッセージを学習したが、これらはDefWindowProcがマウスの位置から生成したメッセージとなる。
　全てのマウスのメッセージの最初に「WM_NCHITTEST」が発生する。通常はこのメッセージが最初にDefWindowProcに渡される。
　このWM_NCHITTESTメッセージを処理することで、あらゆるマウスメッセージを無効化させることもできてしまう。WM_NCHITTESTメッセージは
　第四引数LPARAMにマウス座標を含む。戻り値は、どの部分が押されたのかを表すヒットテストを返す必要がある。この戻り値によって各種の
　マウスメッセージが生成される。つまり、今まではDefWindowProcがマウスの情報から位置を算出し適切な戻り値を返してWindowsに
　各種のマウスメッセージを要求していた。

・通常、マウスがインストールされていない場合はカーソルは表示されない。しかし、マウスが無くてもカーソルを表示させたり
　マウスがインストールされていてもマウスカーソルを消すことができる。

・プログラムのある処理でマウスが押されてから離されるまでを1サイクルとする場合、必ずマウスが離されるまでのメッセージを取得する必要がある。
　例えば、画像ソフトウェアでマウスをドラッグして長方形を描画する場合など。

・ドラッグしている状態でクライアントエリアの外でボタンを離すと、そのメッセージはウィンドウプロシージャに送られてこないため
　処理できない。この状態でウィンドウに再びマウスを戻すと、プログラムはまだマウスのボタンが押された状態だと思いこんでいる。
　このような問題を避けるための機能が「マウスキャプチャー」となる。これは、ボタンが離されるまでウィンドウの外にマウスが移動しても
　そのウィンドウがマウスを制御することができるという機能。マウスをキャプチャーするにはSetCaptureファンクションを使用する。

　キャプチャーと言っても、マウスのボタンが押され他のウィンドウに制御が移るとその時点で他のウィンドウに制御が移り、
　マウスメッセージはそのウィンドウに送られる。

・基本的にウィンドウプロシージャ内に無限ループを作ってはいけない。なぜならば、ウィンドウプロシージャは有言の時間内に処理を終了し
　制御をメッセージループに戻さなければメッセージを処理することができないため。では、無限ループを使う処理はどのように実現すればよいのか？
　いくつかの方法があるが、その中でも最も簡単と思われるのが「デッドタイム」と呼ばれる空き時間を利用した処理。

　デッドタイムとは、ウィンドウがメッセージを処理していない時間帯でユーザーからキーボードやマウスからの入力を待っている状態のこと。
　この状態に別の処理を行うことで、CPUを有効利用することができる。

・今の状態がデッドタイムかどうかを調べるにはGetMessageファンクションでは実現できない。この場合はPeekMessageファンクションを使用する。

・デッドタイムを使った処理方法では無限ループのような処理も可能となるが、これだけではアニメーションなどを作成することはできない。
　アニメーションを実現するには、CPUの速度に依存することの無いようある程度ん時間を待機させるような処理が必要となる。
　そこでPeekMessageとは違った方法でこれを実現させなければならない。このような動作は「タイマー」による時間差処理が好ましいと思われる。
　タイマーとは、ある一定の指定した時間が経過するとメッセージキューにメッセージをポストするという便利な機能のこと。
　これらの作業は一見非同期のように思われるが、タイマーは入出力装置。つまり処理方法はキーボードやマウスと同じ方法でできる。
　指定時間が経つとタイマーはキューにメッセージをポストするが、それは割込みではない。その前に他のメッセージが存在していれば、
　当然そのメッセージが先行して処理される。一般にタイマーを使うにはSetTimerファンクションを使用する。

・タイマーは指定した時間が経過すると、「WM_TIMER」メッセージを発行する。lpTimeFuncがNULLの場合は、メッセージキューにポストされる。
　WM_TIMERはWPARAMにタイマーIDを、LPARAMにはコールバック関数へのアドレスが格納されている。lpTimerFuncにNULLを指定している場合は0になる。
　このメッセージを処理した場合は0を返す。

・タイマーには「分解能」という限界周期が定められており、この分解能以上の周期でメッセージを発行することはできない。この周期は9xとNTで異なり、
　9xの場合は55ミリ秒、NTは10ミリ秒となっている。つまり9xは1秒間に最大で18回、NTは100回までしかWM_TIMERを発生させられない。

・SetTimerによってタイマーを発生させると指定時間ごとにWM_TIMERが発生しファンクションを実行する。しかし、プログラムが起動してから終了するまで
　必要となるのは時計などの一部のアプリケーションだけであり、通常は数サイクル実行されるとタイマーが不要になったりする。
　タイマーが不要になった場合はKillTimerファンクションを使う。この関数を使うことによってタイマーは停止する。

・タイマーは複数作成することもできる。この場合、発行されたメッセージはWPARAMパラメータにタイマーのIDが入力されているため、これで判断する。
　または、コールバック関数をそれぞれに用意して実行することもできる。複数のタイマーを使う場合、一般的にはIDを定数にしてswitchなどを用いて
　メッセージと同様に処理すると見やすくなる。

・時間をプログラムから設定するなどはAPIを使わなければならない。なによりWin32 APIを使用しているため、ここから時間を取得するべき。
　Win32では時間は「SYSTEMTIME」構造体で表される。

・ユーザーによってウィンドウのサイズが変更されたときもメッセージが発生する。これは、クライアントエリアのサイズが重要なプログラムにとって必要。
　クライアントエリアのサイズはGetClientRectで取得することができるが、描画ごとにこれを取得するのは効率が悪い。
　クライアントエリアのサイズを得るべき瞬間は、ウィンドウの生成時とウィンドウのサイズ(クライアントエリアのサイズ)が変更されたとき。

　そこで「WM_SIZE」メッセージを処理する。このメッセージは、ユーザーによってウィンドウサイズを変更されたときに発生する。
　WPARAMパラメータにはリサイズフラグが入る。これは、要求されるサイズ変更のタイプで「SIZE_MAXIMIZED」「SIZEMINIMIZED」などの定数のいずれか。
　LPARAMは下位ワードにクライアントエリアの新しい横幅、上位ワードにクライアントエリアの新しい高さが入る。

・通常、WM_SIZEは再描画処理(InvalidateRectのこと？)を明示的に行う必要はない。これは、一般的なアプリケーションはWNDCLASSのstyleメンバに
　CS_HREDRAWとCS_VREDRAW(ウィンドウの高さや横幅をユーザーが更新した際に再描画する設定)を設定しているから。

・ユーザーのドラッグなどによってウィンドウの位置が移動されたとき、「WM_MOVE」が生成される。LPARAMの下位ワードにウィンドウのX座標が、
　上位ワードにY座標がそれぞれスクリーン座標で格納されている。(ただし、子ウィンドウの場合は親ウィンドウのクライアントエリアの座標となる)

・GUI部品の中で最も威力を発揮する部品の一つに「スクロールバー」がある。これを使うことにより、
　ウィンドウのサイズや解像度に依存することなく大きな画像や長い文字を扱うことができるようになる。このようなGUI部品を
　Windowsでは「コントロール」と呼ぶ。ただし、ボタンやスクロールバーをコントロールと呼ぶのはWindowsだけ。
　JavaシステムなどではGUI部品を「コンポーネント」と呼ぶ。

・ウィンドウに関連付けたスクロールバーは簡単に実現することができる。CreateWindowの第三引数のスタイルにスクロールバーをつけるよう指示する。
　水平スクロールバーは「WS_HSCROLL」、垂直スクロールバーは「WS_VSCROLL」となる。もちろんこれだけではスクロールバーは表示されるものの
　使い物にならない。スクロールバーの各種設定はSetScrollInfoで行われる。

・スクロールバーを実装しただけでは、マウスボタンを離せばつまみは元の位置に戻ってしまう。これは、まだ何もメッセージの処理を行っていないため。
　スクロールバーのメッセージはこれまでのメッセージと同様に処理することができる。縦スクロールは「WM_VSCROLL」、
　横スクロールは「WM_HSCROLL」。スクロールバーをクリックされたり、スクロールボックスをドラッグされると発生する。
　WPARAMには下位ワードにスクロールバーにどのような操作を行っているかを表す定数が格納されており、これを「通知コード」と呼ぶ。
　SB_BOTTOM,SB_ENDSCROLLなどの定数がある。これを分析することで、ユーザーがスクロールバーに何をしているのかがわかる。
　もし、通知コードがSB_THUMBPOSITIONまたはSB_THUMBTRACKであればWPARAMの上位ワードにはスクロールバーへのハンドルが格納される。
　これはコントロールのスクロールバーの場合。

・Windowsは特定の処理を専門とする動作をパッケージ化し、一つのウィンドウとして扱い操作することができる。
　ボタンやチェックボックスなども全てウィンドウ(コントロール)となっている。ボタンなどのコントロールはCreateWindow関数が
　デフォルトで用意している。これらの定義済みコントロールクラスはWNDCLASSを設定する必要が無い。また、ボタンが押されたときなどの
　描画処理やメッセージの処理はすべてデフォルトの状態でサポートされているため、なにも設定する必要が無い。

　これらのコントロールは、トップのウィンドウの「子ウィンドウ」として登録する。そのためには、CreateWindow関数のスタイルに
　「WM_CHILD」を指定する。また、第8引数のhWndParentにオーナーとなる親ウィンドウのハンドルを指定する。
　配置する位置は、オーナーウィンドウのクライアントエリアの座標となる。

・ボタンは押されると親ウィンドウのウィンドウプロシージャに「WM_COMMAND」を送る。このメッセージはWPARAMの下位ワードに
　子ウィンドウのIDが格納されている。子ウィンドウのIDはCreateWindow関数の第9引数に指定する。通常、この引数はメニューの
　ハンドルを指定するが、子ウィンドウのIDを指定することもできる。ただし、その場合はHMENU型に整数をキャストする必要がある。
　WPARAMの上位ワードにはコードが格納されている。コントロールからのメッセージであれば通知コードが、
　アクセラレータからであれば1、メニューからであれば0が格納されている。この通知コードとは「通知メッセージ」のことであり、
　まず、ボタンに何らかの変化がある場合は通知メッセージが送られる。親ウィンドウはWM_COMMANDを通して通知メッセージを知り
　コントロールがどのような状態なのかを判断し、適切な処理を行う。
　LPARAMには子ウィンドウのハンドルが格納されている。このメッセージを処理した場合は0を返さなければならない。

・子ウィンドウの第9引数 hMenu には子ウィンドウのIDを指定することができる。これをあらかじめ決めておいた
　定数などで指定することで、WM_COMMANDのcase文がわかりやすくなる。

・様々なウィンドウメッセージを受け取ってきたが、それだけではなく自らがメッセージを発信することもできる。
　とくに、子ウィンドウに対して何らかの操作を行う時は重要で、ウィンドウがたがいにメッセージを送信し合い、
　情報を送るという操作ができる。それも、プログラムから明示的に子ウィンドウにメッセージを送ることができる。この機能を使えば
　例えば、ボタンをプログラムから押すことができる。プッシュボタン以外のコントロールなどではより重要になる。
　メッセージをウィンドウに送るにはSendMessage関数を使う。

・子ウィンドウにメッセージを送るときは、子ウィンドウを生成したときにCreateWindow関数が返したハンドルに対してメッセージを送る。

・SendMessageは直接プロシージャに対してメッセージを送る。この場合は、プロシージャが終了するまで制御が戻らない。
　つまり、完全に同期がとれていると考えることができる。逆に、メッセージを送信すると即座に制御を戻すこともできる。
　プロシージャが処理しているか否かは関係ない。このような処理をしたい場合はPostMessage関数を使う。

・子ウィンドウが親ウィンドウにメッセージを送るように親ウィンドウから子ウィンドウに対してメッセージを送ることも可能。
　子ウィンドウへ送れるメッセージに多くのウィンドウメッセージが含まれるが、一般にボタン操作には「ボタンメッセージ」を使う。
　ボタンをプログラムからクリックするには「BM_CLICK」を使う。これをボタンに送ればボタンは
　WM_LBUTTONDOWNとWM_LBUTTONUPメッセージを受け取る。BM_CLICKのパラメータは両方とも0で、このメッセージに戻り値は無い。

　また、プッシュボタンが押されたときの強調表示をシミュレーションする場合、「BM_SETSTATE」メッセージを使う。
　このメッセージは、WPARAMにTRUE設定するとボタンを押した状態に描画し、FALSEに設定して送るとボタンを基の状態に戻す。
　LPARAMの値は0を指定し、戻り値も常に0となる。

・

===============================================================================================================================

注意点

・POINT構造体を使用して多角形を描画する際は、staticをつけて宣言しないとバッファオーバーランになる。

・wsprintfを用いる際は、文字列リテラルの前に L をつけないと文字化けする。

・再描画処理が上手くいかないときはInvalidateRectをつけてみるとよいかもしれない。

・

===============================================================================================================================

ブラウザゲーム　メモ

・ウィンドウの属性を最大表示、ウィンドウサイズ変更不可にする

・