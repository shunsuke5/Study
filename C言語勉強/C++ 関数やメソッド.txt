C++ 関数やメソッド

・cin >> = 主にキーボードから何らかの値を入力する際に使用する。

　　cin >> 変数

・continue文 = for文で残りの実行分を無視する。breakで完全にループを抜け出したくないときなどに使用。
　　　　　　　 elseでも代用できるが、こういった条件が何個も出てくる時などにはif-elseだと
　　　　　　　 入れ子がどんどん深くなってしまってプログラムが分かりづらくなってしまうため
　　　　　　　 そのような場合にcontinue文を使うとわかりやすくなるかも。

　　continue;

・fill_n関数 = データをあるデータで埋める。主に配列の初期化に使える。

　　fill_n(先頭位置,要素数,入力する値)

・std::copy関数 = 先頭から順番にコピーする。firstからendまでをresultにコピーする。
　　　　　　　　　firstに配列を指定して、endに数値を入力すればその配列の最初からそのインデックス分だけ
　　　　　　　　　進んだところまでをresultの配列にコピーすることができる。

　　std::copy(first, end, result)

・size関数 = 文字列のサイズ、つまりバイト数を返す関数。

　　文字列.size()

・rfind関数 = 引数に指定した文字列を文字列の末尾から検索していく関数。
　　　　　　　見つかった場合はそのインデックスを、見つからなかった場合は「string::npos」
　　　　　　　という値を返す。戻り値の方はstring::size_typeという型になるが、これは符号なし整数。

　　文字列.rfind(検索文字列)

・insert関数 = 文字列の途中に文字列を挿入する関数。挿入する場所は指定した位置の前となる。

　　insert(位置, 文字列)

・str関数 = 作った文字列をstringクラスのオブジェクトとして返す。
　　　　　　取得した文字列はstringstream内部の文字列としてそのまま残っているため、
　　　　　　一旦クリアしたい時はsstr.str("")のように初期化する。

　　オブジェクト名.str("文字列")

・open関数 = fstreamのメンバ関数。ファイルを開く。フラグにはファイルの状態を指定する。
　　　　　　 フラグは一度に複数指定することができる。指定する時は | で区切る。
　　　　　　 ファイルが正常に開かれるとis_openというメンバ関数がtrueを返す。逆に、
　　　　　　 ファイルが開けなかった場合はfalseが返される。これを利用してファイルが開けなかった場合の処理を書いておいた方が良い。

　　オブジェクト名.open(ファイル名, フラグ)

　　　フラグ　ios::in → ファイルからの入力を行う。
　　　　　　　ios::out → ファイルへの出力を行う。
　　　　　　　ios::binary → バイナリモードで開く。
　　　　　　　ios::trunc → ファイルが存在していた場合、その内容を破棄してから開く。
　　　　　　　ios::app → 常にファイルの末尾に書きだすようになる。
　　　　　　　ios::ate → ファイルを開いた後、ファイルの末尾に移動する。

・close関数 = fstreamのメンバ関数。ファイルを閉じる。

　　オブジェクト名.close()

・getline関数 = ファイルから一行だけ文字列を読み込む。

　　getline(ファイルオブジェクト, 文字列を格納する変数)

・write関数 = fstreamのメンバ関数。生の値をそのまま出力したい時に使用する。
　　　　　　　第一引数の型はconst char*のため、それ以外の型の場合にはキャストが必要となる。
　　　　　　　バイトオーダを保存したままファイルに出力される。

　　オブジェクト名.write((const char*)アドレス, 出力するバイトサイズ)

・read関数 = fstreamのメンバ関数。ファイルから変数に生の値を読み込む。write関数と引数が似ているが、
　　　　　　 値を書き込むため第一引数のconstがなくなっている。

　　オブジェクト名.read((char*)アドレス, 出力するバイトサイズ)

・gcount関数 = 最後に取得したバイト数を取得する。実際に読み込んだファイルのバイト数分だけ
　　　　　　　 他に出力したい場合に便利。

　　オブジェクト名.gcount()

・eof関数 = fstreamのメンバ関数。ファイルの最後に到達した場合に真を返す。

　　オブジェクト名.eof()

・fail関数 = fstreamのメンバ関数。入出力で何らかのエラーが発生した場合に真を返す。
　　　　　　 この関数が真を返した時に何らかのエラー処理を行えばプログラムはより安全となる。
　　　　　　 読み込みの場合はファイルの終端に到達した際も真を返すため、エラーチェックなどで
　　　　　　 使用する際はその点に気を付ける。

　　オブジェクト名.fail()

・seekg関数 = fstreamのメンバ関数。ファイルポインタの位置を変更する。指定する引数には計算式も指定可能。
　　　　　　　引数に10を取れば先頭から10バイト目、引数に0を取ればファイルの先頭に移動させることができる。
　　　　　　　第二引数にフラグを指定することもできる。

　　オブジェクト名.seekg(ファイルポインタの位置, フラグ)

　　　フラグ　ios::beg → ファイルの先頭から第一引数に指定した数だけ移動する(引数1個の場合と同じ)

　　　　　　　ios::cur → 現在の(current)位置から第一引数に指定した数だけ移動する。
　　　　　　　　　　　　 ファイルの末尾方向へ移動するが、第一引数に負の値を指定すれば先頭方向へ移動することもできる。

　　　　　　　ios::end → ファイルの末尾から第一引数に指定した数だけ移動する。
　　　　　　　　　　　　 ios::curと同様、負の値を指定すればファイルの先頭方向に移動する。
　　　　　　　　　　　　 ファイルの末尾というのはファイルの最後のバイトのさらに次を表すため、
　　　　　　　　　　　　 読み込みの場合はもう読み込めるデータのない位置であり、書き込む場合は最後のバイトよりもあとに追加できる位置となる。

・clear関数 = fstreamのメンバ関数。ファイル操作で何らかのエラーが発生した場合、
　　　　　　　もう一度ファイルにアクセスできるようにする。ファイルの終端に達した場合も
　　　　　　　エラーに含まれてしまう場合があるので、これを呼んでおかないとそれ以降
　　　　　　　他の関数が失敗してしまうことがあるので注意する。

　　オブジェクト名.clear()

・tellg関数 = ファイルポインタの位置を取得する。戻り値の方はstreamposという型だが、この型は必ずしも普通の整数型とは限らない。
　　　　　　　そのためこの型に足し算や引き算が使える保証はない。その代わり、この値はseekgやseekpの第一引数に指定することができる。

　　streampos 変数名 = オブジェクト名.tellg()

・setwマニピュレータ = 最小幅を指定する。最低でも引数に指定した幅だけ出力される。
　　　　　　　　　　　 効果は1度きりのため、ループの場合はループ内の処理に書く必要がある。

　　cout << setw(最小幅)

・setfillマニピュレータ = setwで指定した幅に足りない場合に出力される文字を指定できる。デフォルトは半角空白。
　　　　　　　　　　　　　効果は永続となっているため、1度指定すれば以降ずっとその効果が適用される。

　　cout << setfill(出力文字)

・hexマニピュレータ = 16進数で出力する。デフォルトではA～Fが小文字で出力されるため、
　　　　　　　　　　　大文字で出力する場合はuppercaseマニピュレータと併用して使用する。
　　　　　　　　　　　効果は永続となっているため、1度指定すれば以降ずっとその効果が適用される。

　　cout << hex

・uppercaseマニピュレータ = 大文字で出力する。効果は永続となっているため、1度指定すれば以降ずっとその効果が適用される。

　　cout << uppercase

・size関数 = vectorのメンバ関数。第二引数を指定すると、配列が全てその値で埋められる。

　　size(配列のサイズ, [配列に与える値])

・resize関数 = vectorのメンバ関数。配列のサイズを変更する。第二引数を指定しなかった場合は、デフォルトコンストラクタ
　　　　　　　 で作られたオブジェクトで埋められる。配列のサイズが変化した場合にメモリの再確保が起こった場合は要素のコピーが行われる。
　　　　　　　 例えば、10要素のメモリしか確保してないのにv.resize(15)とすれば、新たにメモリを確保することになる。
　　　　　　　 この際、前のメモリ領域にあるv[0]～[9]は新しいメモリ領域へとコピーされる。これを考えると、
　　　　　　　 各要素のアドレスはresizeなどをすると変わりうるということが分かる。

　　resize(変更後の配列のサイズ, [増えた配列に与える値])

・system("pause") = 入力待ちにすることができる。これにより、exeファイルで実行しても結果を見ることができる。

　　system("pause");

・

================================================================================================================================

文法

・クラス継承

　　class 派生クラス名 :
　　　アクセス指定子 基底クラス名 {・・・};

・純粋仮想関数

　　virtual メンバ関数名() = 0

・基底クラスのコンストラクタを呼ぶ

　　コンストラクタ名(仮引数リスト) :
　　　基底クラス名(実引数リスト)
　　{
　　・・・実装・・・
　　}

・深い名前空間に別名を与える

　　namespace 別名 = 名前空間名

・関数テンプレート

　　template <typename 定義する型名>

・クラステンプレート

　　クラス名<テンプレート名>::メンバ関数名() {}

・例外処理

　　try {
        if(エラー判定条件) {
            throw エラーメッセージ;
        }
    } catch(変数宣言) {
        エラー処理
    }

・関数tryブロック

　　FileException::FileException(consnt char* error)
　　try :
　　  m_error(error)
　　{
    } catch(const bad_alloc& e) {
    }

・staticメンバ変数の実体を作る変数宣言

　　型 クラス名::メンバ変数名;

・配列のサイズ指定に使う静的メンバ定数

　　static const 整数型(intなど？) 定数名 = 値;

・[]演算子のオーバーロード

　　戻り値の型 operator[](インデックス)

・フレンド関数の宣言

　　friend クラス名 operator*(引数);

・インライン関数の宣言

　　inline 型名 関数名(引数)

・

================================================================================================================================

ヘッダーファイル一覧とその中に入っている関数

<cstring>
　strlen
　strcpy
　strcat
　strcmp
　strchr
　strrchr
　strstr

<cstdio>
　sprintf

<cstdlib>
　rand
　srand

<ctime>
　time

<cmath>
　sqrt
　abs
　fabs
　floor
　ceil
　fmod
　modf

<cctype>
　isdigit

<algorithm>
　exit
　fill
　fill_n

<string>
　size
　getline

<sstream>
　str

<fstream>
　open
　close
　write
　read
　gcount
　eof
　seekg
　seekp
　clear
　tellg
　tellp

<iomanip>
　setw
　setfill
　hex
　uppercase

<vector>
　size
　resize

