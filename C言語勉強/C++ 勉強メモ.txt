C++ 勉強メモ

・文字の表示には「cout」というものを使用する。これはconsole outputの略で、
　制御装置(console)に出力する(output)ことを意味している。出力とは逆の入力を行う
　「cin」も存在する。

・endlは改行を意味する。もう1つの役割としては、確実に文字を表示する効果がある。
　改行しないときにはendlの代わりにflushを使用する。

・コメントは//もしくは/**/で記述。

・coutは文の途中で改行して続いて内容を記述することができる。その時改行して表示したい場合は、
　endl をつけてセミコロンをつけなければそこが改行される。

・if (! (a < 5))として、aが5より小さくないとき といった指定方法もできる。

・プログラムに意味不明の異常が発生した場合はバッファオーバーランが起こっている可能性が高い。

・インクリメントやデクリメントは変数の前に記号を持ってくることもできる(例：++i)

・for文の初期化の中でループ変数を宣言することも可能。(例：for (int i = 0; i < 10; ++i))
　こうして初期設定分の中で宣言されたループ変数はfor文の内部でしか使えない。for文の外でも使いたい場合は
　for文の外で宣言するようにする。C言語では初期設定分の中で宣言することはできない。C99は可能。

・ループを抜けるにはbreakを使用するが、ループが終わった後関数がすぐ終了するなら、
　returnを使用して抜け出すことも可能となる。

・変数のスコープはできるだけ小さい方が影響範囲が小さくなり、その変数に起因するバグがあった場合に
　修正が比較的楽となる。この論理で行くとグローバル変数は最悪のものということになってしまい、事実
　グローバル変数は1つも使うべきではないという人もいる。

・switch文を終わるにはbreak文を使うため、必ず忘れないようにする。

・操作、記憶する型の最小単位は「バイト」となる。

・変数に格納できる最大値より大きい値になった時を「オーバーフロー」、最小値より小さい値になった時を「アンダーフロー」と呼ぶ。

・整数型には大きく分けてchar, short, int, longの4つがあり、少数型にはfloat, double, long doubleの3つがある。
　これに加えて、signedかunsignedの分類がされる。

・short int, long int, signed int, unsigned intの4つの型はintを省略することができる。
　そしてsignedはsigned char以外は省略可能。しかし、符号付きか符号なしかを保障したい場合は必ず
　signedまたはunsignedを使用するようにする。

・int a;
　signed char b = -1;

　a = (unsigned char)b;

　上記のようなプログラムがあるとすると、signed char型の-1という値をunsigned char型に変換して、
　それをint型の変数aに代入している。つまり変数の流れとしては　-1(signed char) → 255(unsigned char) → 255(int)
　という流れになる。signed charだったbを(unsigned char)を指定して変換している。このように自分で型を指定して
　行うキャストを「明示的なキャスト」と呼ぶ。それに対し、255というunsigned char型の値がint型の変数aに代入される場合にも
　unsigned char型からint型への変換が自動的に行われる。このように自動的に行われるキャストを「暗黙のキャスト」と呼ぶ。
　もしunsigned char型への明示的なキャストが無く単にa = bとしただけの場合、aには-1が代入される。
　このようにキャストは単に型を変えるだけでなくキャストするかしないかで動作に影響を与えることもある。

・C/C++の仕様では型のサイズは環境ごとに自由に決めていいことになっている。
　ただし、char <= short <= int <= long, float <= double <= long doubleのルールに従う必要はある。

・厳密にはchar型のサイズのことを「バイト」と呼ぶ。そのため、環境によっては1バイトが9ビットとなることもある。
　確実に8ビットの組であることを表現したい場合には「オクテット」という言葉が使われる。
　一方で9ビットは「ノネット」と呼ぶ。

・参照の参照先を後から変更することはできない。参照は初期化することしかできず、その初期化時に指定した変数から
　参照先を変更することはできない。

・''で囲って得られる値の方はC++ではchar型、C言語ではint型となる。これはC言語とC++の重要な差異の1つ。

・通常のパソコンでは普通の半角英数記号は32～126までの値となっている。また、タブ、改行など特殊な文字(制御文字)
　を含めると0～127までの値になる。これを「(7ビット)ASCIIコード」と呼ぶ。

・文字列の最後には必ずヌル文字をつけることになっている。このヌルターミネータを忘れてプログラムを組んでしまうことは
　初心者に多いバグの1つとなるため気を付ける。

・sizeof演算子によって得られる値の型はsize_tという型。これは符号なしの整数型だが、そのサイズは環境によってまちまち。
　C/C++には他にもptrdiff_t型やtime_t型といった_tのついた型があるが、このtはtypeの略で「これは型である」という目印になっている。

・符号付きの値と符号なしの値を比較するとビルド時に警告が出ることがある。

・ソースファイルは実際にはヘッダーファイルと合成された形でビルドされる。

・iostreamやcstdioのように標準で用意されているヘッダファイルのことを「標準ヘッダファイル」と呼ぶ。
　そこで宣言される関数を「標準関数」と呼ぶ。

・""でヘッダファイルをインクルードしたとき、もしファイルが無い場合にはツール側の提供しているフォルダ内からファイルを探す。
　<>も同様に、ツール側の提供しているフォルダにファイルが無い場合はプロジェクト内フォルダを探す。

・自分で作ったヘッダファイルは標準ヘッダファイルをインクルードする前にインクルードした方が良い理由としては、
　例えばtest.hというヘッダファイルを作り、今のところ全ての箇所でiostreamをインクルードしたあとにtest.hが
　インクルードされていて、それでうまくビルドできていたとする。そして、test.hはiostreamをインクルードしていなかったとする。
　iostreamをインクルードしないままtest.hをインクルードした場合にビルドエラーが出る可能性がある。
　当然、ちゃんとtest.hを読めばiostreamに依存しているかはわかるが、それよりはiostreamより前にインクルードして
　ビルドエラーがでないかどうかチェックする方がはるかに楽、といった理由。

・自作のヘッダファイル同士の順番は別に気にしなくてよい。

・乱数を使用する方法の1つに、割り算の余り(6で割ると必ず余りは0～5になるためそれに1を足す)がある。

・疑似乱数の生成法には色々あり、rand関数では線形合同法や遅延フィボナッチ法という方法が使われている場合が多い。
　他にもM系列乱数やMersenne Twister(MT)法などがある。MT法は現在最も質の良い疑似乱数生成法で、質を求めるなら迷わず
　MT法を使った方が良い。ただし、MT法はワーキングメモリが比較的大きく、そこまで高いクオリティの乱数が必要と
　されない場合はオーバースペックとなりがちなデメリットがある。

・C++のcinで複数入力する場合はスペースで入力する。

・浮動小数点には大きい値も小さい値も両方とも表現できるという利点がある。これが可能なのは、大きい値なら小数点をずっと
　右にずらし、小さい値なら小数点をずっと左にずらせばよいだけだから。その代わり、大きな数に小さな数を足しても
　変化がなかったり(情報落ち誤差)、近い数同士を引き算すると精度が落ちたり(桁落ち誤差)、保存できる桁数を超えた部分が
　0になってしまったり(丸め誤差)、様々な数値誤差を生んでしまう。

・同じ名前の違う関数を作ることを「オーバーロード」という。

・全く同じ戻り値の型、引数の型、個数、順番を持つ関数を2つ定義することはできない。
　int Func()とdouble Func()という関数があった場合、どちらを呼び出しているのかわからない、つまり引数の型がすべて
　同じであればオーバーロードできない。

・C言語ではオーバーロードができない。これはC言語とC++の違いの内、重要なものの1つ。

・関数の戻り値をbool型にすると、while文などで!= 0と指定せずにbool型の値を直接
　入れることができる。何より、0と1よりもtrueとfalseを使った方がどちらが成功を表しどちらが失敗を表すかがわかりやすくなる。

・while(true)は、bool型の値を利用した無限ループ。

・C言語では条件式の結果は1(真)か0(偽)というint型の値になる。C言語ではbool型に相当する型は存在しない。

・メモリとは、プログラムを実行する際の作業領域となる。まず、ディスク上にある実行ファイルをメモリ上に(多少手を加えつつ)
　読み出す。そして、そのメモリ上のデータを元にしてプログラムが実行される。決してディスク上で実行されるわけではない。
　また、実行ファイルに限らず、ファイルを扱うには中身を一度メモリに読み出す必要がある。

・参照とポインタの大きな違いは、参照は初期化時に一度参照先を決めたら二度と参照先を変えられないのに対し、
　ポインタの場合はアドレスを再代入すれば参照先を何度でも買えられるという点。

・一度に2個以上のポインタを宣言する時は、int *p, *qのようにすべての変数名の前に*をつける。

・sizeof(array) / sizeof(array[0])のように配列のサイズが取得できるのは配列変数を直接扱った場合のみであり、
　一旦ポインタに入れてしまうとそこからはもう配列のサイズを取得することはできなくなってしまう。つまり配列を関数に渡す場合は
　配列の長さをあらかじめ決めておくか、配列の長さを別の引数から渡すか、文字列のように
　何らかのターミネータをつけておくかする必要がある。

・&n[2] + 1　は　&n[3]となる。つまり、配列のある要素のアドレス&n[i]に値jを足すと、その数だけ進んだ要素のアドレス&n[i + j]となる。
　また、&n[i]からjを引くともちろん&n[i - j]となる。

・配列のポインタ変数に数値を代入すると、その数値分前か後のアドレスに変化する。

・例えばstrという文字列配列があったとする。そこで、*(str + i)とすると、まずstr + iが括弧でくくられているため
　この演算が行われる。アドレスにiを足すとi要素分だけアドレスを進める。そして、その計算結果に*がついている。
　つまり、「strからi要素分だけ進んだアドレスにある値」となる。すなわち、str[i]となる。
　上記から、*(アドレス + インデックス) と、 アドレス[インデックス] という2つの表現は全く同じとなる。

・関数に配列を渡すときは配列本体を直接渡すことになるため、if文条件式の==を=と間違えるなどのミスによる
　書き替え言った危険が伴ってしまう。そこで、C/C++には変数の中身を変更できないようにする「const」という機能が
　備わっている。

・ポインタ型の前にconstを追加した場合、ポインタ自身は変数のままだが、ポインタの参照先が定数となる。
　つまりstrというポインタの値を変更することはできる物の、*strやstr[i]などを変更することができなくなる。
　このことは参照でも同様で、const int& rとするとrの参照先の値を変えることができなくなる。
　ポインタや配列、そして参照を引数に取る際にはこのconstを使う必要があるか常に考えておく
　癖をつけておくとよい。

・配列のサイズに変数を指定することはできないが、数値で初期化された整数定数なら指定することができる。
　(例:const int ARRAY_SIZE = 256;　→　int array[ARRAY_SIZE])
　C言語では配列のサイズにconst定数を指定することはできない。これもC言語とC++の重要な違いの1つ。
　C言語では代わりにマクロというものが使われる。

・const char* pとすると参照先が定数になるがp自体は定数にならない。pは定数ではないので初期値は必要ない。
　char* const p = &a;とすると、ポインタpが定数になる。その代わりpの参照先は定数にならない。
　これらの区別は「constの右側にあるものが定数になる」と覚えておけば簡単。
　参照先とポインタ両方を定数にしたい場合は、const char* const p のように両方にconstをつければよいだけ。

・引数にconst定数を指定している関数内でconst定数を指定していない関数を呼び出すことはできない。
　関数を呼び出すときには中身までチェックしないため、constがついていなければ書き替えられる可能性があると
　判断されるから。

・constを使って作られる定数のことを、その値の意味を表す名前がついている定数ということで
　「表意定数(figurative constant)」と呼ぶ。それに対し、生の値を直接処理に埋め込んだものを
　「マジックナンバー」と呼ぶ。マジックナンバーの使用はできる限り避けるべきで、可能な限り
　表意定数を使うようにした方が良い。constはプログラムの動作に直接影響を与えるものではないが
　プログラムを安全に作成するためには非常に重要なものとなる。

・ヌルポインタ = どんな変数や関数などのアドレスと比較しても等しくならないことが保証されているアドレスを持つポインタ。

・NULLは基本的にcstddefというヘッダファイルで定義されているが、cstdio,cstdlib,cstring,ctime,cwchar,clocaleという
　ヘッダファイルでも定義されている。また、他のヘッダファイル内でもこれらのヘッダファイルがインクルードされている場合があり、
　前述のヘッダファイル以外のヘッダファイルのみをインクルードしただけでもNULLが定義されていることがある。
　例えば、iostreamをインクルードしただけでもNULLが使える。

・NULLは実はマクロというものになっていてNULLと書かれたところが0で置き換わるようになっている。
　インクルードがファイルの内容を埋め込むのに対し、マクロは指定された内容を埋め込むようになっている。

・NULLはプログラムを読みやすくするため、ポインタに関する処理である、ということを明らかにするために使われる。
　そのため、NULLが0に置き換わるとしても数値の0やヌル文字の代わりとして使うわけにはいかない。
　for(int i = NULL; i < 9; ++I) や for(int i = 0; str[i] != NULL; ++i) などという記述は絶対にしないようにする。

・ヌルポインタはNULLかNULLでないかで処理を分けることができるが、これには色々な意味を持たせることができる。
　例えば、アドレスを返す関数で関数が失敗したときにNULLを返すようにする、
　NULLを渡すと何らかの特別な処理をする関数を作る、NULLを渡すとそのパラメータを無視する、などの処理ができる。
　つまり、ヌルポインタは普段とは異なる特殊な処理を行わせる場合の目印として使うことができる。

・配列変数の名前はその配列の先頭要素のアドレスになる。この「配列変数の名前」というのは[]を1つ除いたものと考えることができる。
　例えば、x[i]から[]を1つ除くとxになり、これは&x[0]と同じアドレスを指す。では、配列の配列で[]を1つ除いたものはどうなるのか。
　例えばint n[3][5]としたとき、n[0]はどうなるのか。実はこれはちゃんと機能し、&n[0][0]となる。
　同様にn[1]は&n[1][0]であり、n[2]は&n[2][0]となる。

・配列の配列でサイズを省略できるのは最初の[]だけとなる。

・構造体の各要素は「メンバ」という。

・メモリ上にある変数を実体(インスタンス)と、構造体変数のことを「オブジェクト」ともいう。
　メンバを使う時はオブジェクト.メンバとなる。

・構造体はデータ量が多いので参照渡しあるいはポインタ渡しをするのが普通。値渡しにしてしまうと、
　もし構造体のサイズが4000バイトなら4000バイトコピーされてしまうため。
　ただし、小さい構造体なら値渡しの方が実行速度の面で有利になる可能性がある。ただしその場合でも
　速度面以外の理由で参照渡しにする必要があるならもちろん参照渡しにした方が良い。

・*(A + B) が A[B] と表せたり、(*ポインタ).メンバ名 が ポインタ->メンバ名 で表せたりなど、このように
　見た目をすっきりさせるために導入される構文のことを「シンタックスシュガー(糖衣構文)」と呼ぶ。

・列挙体(enum)の定義では、最後の要素の後にはコンマをつけてはいけない？

・enum 型名 で定義した型を enumで定義した型名 関数名(引数)のように関数の戻り値に設定すると、
　この関数の戻り値にはenumで定義した値しか取れないようになる。このように列挙体を使っていれば
　変な値を返そうとするとビルドエラーが出るため多少のミスは防ぐことができる。

・条件式などで比較する場合には列挙体型の値と比較しているかどうかというチェックは行われないため
　その点には十分気を付ける。

・列挙体型でキャストするとどんな値でも扱えるようになる、という大きな穴がある。

・? は条件演算子、3項演算子と呼ばれ、3つの項(operand)を取る。加算演算子の + や減算演算子の - などは
　左項と右項の2つの項を取るので2項演算子、負符号演算子の - やsizeof演算子などは1つの項を
　とるので単項演算子と呼ぶ。C/C++では3項演算子はこの条件演算子の ? だけとなる。

・? の書式は 条件式 ? 真の場合:偽の場合　となる。条件式を判定して、その結果に応じて数値1か数値2を返す。

・仮引数を初期化するような形(例:StrCopy(char* dst, const char* src, int first = 0, int length = -1))
　にすると、その引数を省略して関数を呼び出すことができ、省略した際には宣言した際に代入したデフォルトの値
　が渡される。もちろん、関数呼び出しの際に他の値を指定したい場合は指定可能。
　このように引数に指定されたデフォルトの値のことを「デフォルト引数(default argument)」と呼ぶ。

・関数プロトタイプ宣言を行う場合はデフォルト引数は関数プロトタイプ宣言の方のみに記述する。
　関数プロトタイプと関数の定義の両方に書くとビルドエラーとなってしまうため。

・しかし、デフォルト引数が複数ある場合に、途中の実引数だけ省略することはできない
　(例:StrCopy(str1, str2, ,1)はビルドエラーとなる)
　そのため、最後の実引数だけ指定したい時でも結局すべての実引数を書かなければいけなくなる。
　そのため、使用頻度の少ない引数ほど後ろの方に持っていくとよい。

・void Func(int a, int b = a)のように前の引数をデフォルト引数にとるようなことはできない。
　また、デフォルト引数には静的な値しか指定できない。ここでいう静的な値というのは、定数、もしくは
　プログラムが実行される前に位置が決まっている値のこと。つまり、定数、グローバル変数、
　そしてそれらや関数のアドレスのこと。また、静的な値を使って実行された関数の戻り値も指定可能。

・引数は関数を呼ぶたびに位置が変わる。もちろん位置が同じこともあるが違うこともある。
　例えば、void Func(int a = 0) {cout << (size_t)&a << endl;} と void Func2() {Func()}
　といった2つの関数があった場合に、main関数からこの2つを実行するとFunc()とFunc2()が
　示すaのアドレスは異なるものとなる。つまり、アドレスが変わりうるということになる。

・オーバーロードとデフォルト引数を併用する際は、関数の呼び出し方によってはどちらの関数を
　使用しているのか区別がつかずにビルドエラーとなることがあるので注意する。

・静的変数の定義としては、「プログラムが実行される前(プログラムがメモリ上にダウンロードされたとき)に
　既に位置の決まっている変数」のこと。例えばグローバル変数は静的変数となる。

・自動変数の値は関数を抜けると保証されない。そのため、自動変数のアドレスを返すような関数は
　絶対に作ってはいけないことに十分注意する。それに対し、静的ローカル変数は関数を抜けても値が
　保証される。つまり、静的ローカル変数のアドレスを返す関数であれば作っても構わないということ。

・静的変数についてまとめると、

　　静的変数のアドレスは常に一定。
　　静的変数の初期化はローカル変数でも1度のみしか行わない。
　　静的変数は初期化されなければ0で初期化される。
　　静的変数は関数を抜けても値が保存される。

　などの特徴がある。

・ポインタを利用すると寿命が尽きた変数にアクセスすることもできてしまうが、そのようなことは決して
　してはいけない。わざとではなくても何らかのミスでそういう状況になってしまうこともあるので
　十分に注意する。

・同じ名前の変数が何個もあった時は最も内側のブロックにある変数が使用される。
　また、C++ではグローバル変数ならどのスコープからでも参照することができる。
　そのためにはスコープ解決演算子 :: というものを使用する。変数の前に :: をつければそれは
　グローバル変数を指すようになる。

・グローバル変数と関数は、実はファイルを越えて利用することができる。しかし、ファイルを越えて
　利用させたくないときはファイルを越えて利用できないようにすることもできる。
　こういった、ファイルを越えて利用できるかどうかという性質を「リンケージ」と呼ぶ。
　リンケージには2種類しかなく、そのファイルの外部でも利用できるものは「外部リンケージを持つ」と、
　そのファイルの内部でしか利用できないものは「内部リンケージを持つ」という。

・関数に外部リンケージを持たせるには戻り値の方に「extern」を加える。ただし、externは省略できるため
　普通に関数を定義すればそれは別のファイルでも利用できる。また、グローバル変数の場合も普通に変数を
　定義すれば別のファイルでも利用することができる。

・ローカル変数としてexternの付いた変数を宣言することもできる。この場合、その変数は
　どこかで宣言されている同名の外部リンケージのグローバル変数を操作するために使われ、
　その変数名のスコープはローカル変数のものと同じとなる。

・内部リンケージを持たせるには型にstaticを付け加える。staticは静的なローカル変数を宣言する時に
　使うものだが、グローバル変数や関数に内部リンケージを持たせるときにもこのstaticを使用する。
　staticを省略することはできない。

・externやstaticのようなものを「記憶クラス指定子(storage class specifier)」と呼ぶ。
　そしてextern,static,auto,registerで決められるものをまとめて「記憶クラス(storage class)」と呼ぶ。

・外部リンケージのグローバル変数はあらゆるファイルで扱うことができる故に、あらゆるファイルのあらゆる処理で
　値が変更される非常に恐ろしい可能性がある。内部リンケージのグローバル変数であればその変数を含む
　1つのファイルを中心にチェックすればよく、比較的チェックする範囲が狭くなる。しかし、そのファイルの中に原因が
　見つからなければそのグローバル変数を操作する関数を読んでいる場所をチェックする必要が出てきて、やはりそれを
　呼んでいるあらゆるファイルをチェックする必要がある。これらに対し、自動変数を使った場合は原因の存在範囲が
　その自動変数を宣言してから異常が発生するまでの間の処理にまで制限されるため、比較的原因が見つかりやすくなる。
　このように、変数のスコープやリンケージが広ければ広いほど、そして寿命が長ければ長いほどバグを
　見つけにくくなってしまう。

・さらにグローバル変数はプログラムの全処理を通して実態が1つしか存在しないため、
　例えば2つの異なる値で初期化された乱数列が両方同時に欲しいといった場合にrand関数が使えないように
　モジュール性(プログラムの部品として色々なところで使えるという性質)が非常に低下してしまう。
　グローバル変数を使おうと思っても、果たしてそれでいいのか、使わなくてもこの処理は実現できる
　んじゃないかと考える癖をつけるようにした方が良い。

・コンパイルを行うと各ソースファイルを元に中間ファイルが作成される。これを「オブジェクトファイル」と呼ぶ。
　ここにはどんなグローバル変数や関数が定義されているかなどが書かれている。マシン語に変換された関数の中身も
　書かれているがグローバル変数や関数のアドレスは確定していない。そして、リンクという作業でオブジェクトファイルを
　束ねて実行ファイルを作成する。コンパイルは各ソースファイルごとに全く独立に行われるため、この段階では二重定義が
　起こっているかどうか全くわからない。そしてリンク時にどんな変数や関数が定義されているかをチェックする。
　異なるファイルに同じ変数や関数を定義したときの二重定義は、このリンクという作業を行う時に発生する。

・ヘッダファイルには良く使うconst定数を書いておくと便利。const定数は自動敵に内部リンケージになる。
　そのため二重定義エラーの心配はないし、そもそも定義をヘッダファイルに書かなければ公開できない。

・C言語ではconst定数も外部リンケージになり、配列のサイズ指定にも使用できない。staticをつけるともちろん内部リンケージ
　になるが、配列のサイズ指定には使用できない。これはC言語とC++で互換性が無い部分のうち、重要なものの1つとなる。

・色々な宣言や定義を書いていくと、ある問題が起こってくる。それはコンパイルの段階での二重定義となる(リンクの段階での二重定義ではない)
　例えばconst int N = 10;を2行記述すると二重定義となる。これは、const int N = 10;とだけ書いてあるヘッダファイルを
　2回インクルードすることと同じとなる。ヘッダファイルでヘッダファイルをインクルードするということもあるため
　いつの間にか2回インクルードしてしまっていたということは頻繁に起こる。そのため、ヘッダファイルには必ず二重インクルード
　防止コードを書くことになっている。これはとても重要となっており、2回目以降のインクルードの時にはインクルードを行わないように
　することができる。それには#ifndef,#define,#endifというものを使う。このように先頭に#のついたものを
　「前処理指令(プリプロセッサディレクティブ)」と呼ぶ。#includeもこれに当たる。これらはコンパイラがソースファイルを
　解析するよりも前に色々と処理したい時に使う。しかし実際にはコンパイラに対して指令を送るかのような前処理指令も存在する。

・#ifndef～#endifで囲まれた部分は、#ifndefで定義されているマクロが定義されていなければコンパイルされ、
　定義されていればコンパイルされない。つまり最初の#ifndefを読み込んだときはマクロが定義されていないので
　コンパイルされ、そのあとに#defineでマクロが定義されているので、2回目の#ifndefの時には定義されていることになり
　コンパイルされない、といった動きとなる。ここで注意する点は、「定義するマクロの名前は各ファイルごとに変える」という点。
　マクロ名の中に日時やランダムな文字を入れた方が良い。

・visualstudioの場合、二重インクルード防止コードを書く代わりに #pragma once をヘッダファイルのどこかに記述しただけでも
　これだけで二重インクルードを防げる。ただ、この形で二重インクルードを防止していた場合、他のコンパイラでコンパイルしようと
　しても二重インクルードが防止されない可能性がある。VC++以外のコンパイラでコンパイルする可能性がある場合には

　#if defined(_MSC_VER) && _MSC_VER >= 0x1020
　#pragma once
　#endif

　という風にし、さらに二重インクルード防止コードを別途書く。こうすればVC++を使った場合にのみ#pragma onceが有効となる。

・オブジェクトファイルを束ねて作るものには実行ファイルの他に「ライブラリ」というものもある。
　ライブラリには静的ライブラリと動的(共有)ライブラリの2種類がある。
　静的ライブラリは本当にオブジェクトファイルを束ねただけのもの。静的ライブラリはオブジェクトファイルと同様にリンクすることができる。
　動的ライブラリは実行ファイルと静的ライブラリの中間のようなもの。動的ライブラリはそれ単独では実行することができないが
　実行中のプログラムから利用することはできるというもの。動的ライブラリを利用できる状態にすることもリンクと言うが、
　本来のリンクと区別して「動的リンク」と呼ぶことが多い。これに対し本来のリンクのことを「静的リンク」と呼ぶ。
　静的とはプログラムの実行前を表す言葉のため、静的リンクは「プログラムの実行前にリンクする」ことを意味する。
　それに対し動的というのはプログラムの実行時を表す言葉なので、動的リンクはプログラムの実行時にリンクすることを意味する。

・文字列リテラルはメモリ上のどこかに置かれた静的なデータで、プログラムが始まってから終わるまで
　ずっと破棄されることはない。そしてこれをポインタに代入する式は、ポインタにそのアドレスを代入する式となる。
　ここで注意することは、文字列リテラルを直接書き換えてはいけないということ。
　C/C++では文字列リテラルを直接書き換えた場合、コンパイルは通っても実行するとエラーになることもあるし、
　同じ内容を持った別のリテラルまで書き換えられてしまう可能性もある。したがって、文字列リテラルのアドレスを受ける
　ポインタには必ずconstをつけるようにする。

・自動変数の場合はあらかじめ自動変数用の領域が最初に用意され、そこに順次値を置いていくようになっている場合が多い。
　この領域のサイズは決まっており、つまりはプログラムをメモリ上にロードする時にOSが確認する。
　一方でnewというのは、プログラムを実行している最中に新たにメモリを確保したい時に使う。OSが使っていいよと言ってくれれば
　そのメモリを使うことができるようになる。そのメモリの位置、つまりアドレスはnewが返してくれる。これをポインタに入れておけば
　新たに確保したメモリを使えるようになる。

・newで確保できるメモリのある領域のことを「フリーストア」と言う。「ヒープ」と言われることもあるが、
　これらは別のものを表す用語。newで確保したメモリを開放するための演算子がdeleteとなる。
　newで確保したメモリは不要になれば必ずdeleteで開放する。これは最上級に重要なこと。

　例えば、newで確保してそのアドレスをpというポインタに入れておくとする。そしてこのpを別の変数に
　保存したりdeleteしないままpの値を変えてしまうともうそのアドレスを保持しているポインタが1つもなくなってしまう。
　こうなると、もうこのメモリは自分で開放することは二度とできなくなってしまう。他にも、自動変数でアドレスを受けた後に
　そのまま関数を抜けてしまうと、やはり二度とそのメモリを解放できなくなってしまう。こうした処理が何度も行われると、
　知らない間にメモリを食いつぶし、最後にはその解放できないメモリ領域でメモリが一杯になってしまうことさえある。
　これがC言語でもやった「メモリリーク」となる。

・普通の配列では例えば100個の要素の配列を作りそれを使って計算、表示するようにするが、それでは100より大きな値を指定した場合に
　エラーにする必要があったり、あるいはより要素数を増やすことも考えられるがそれでも常に上限は存在し、そこまで大きな値を指定
　しなかった場合に多くのメモリが無駄となってしまう。

　ところがnewを使用すればどこまで計算するかをたずね、その分だけ配列を作り、そしてその配列を使って計算や表示をすることができる。
　これが可能になるのは、配列変数の宣言の場合とは異なりnewの[]の中に変数などを含む式を入れることができるから。

・配列のメモリを動的に確保した場合は、delete[]を使用する。deleteとdelete[]はきちんと使い分ける必要があるので注意する。

・自動変数の置かれるメモリ領域は「スタック」という場所である。このスタックというメモリ領域のサイズはあまり大きくないことが多く、
　例えば関数内で巨大な配列変数を作るとスタック領域からあふれ出してしまう。これが「スタックオーバーフロー」となる。
　スタックをオーバーフローすると、その溢れた先にたまたまあったメモリ領域を使うことになる。そこに書き込みを行うと
　たまたまそこにあった別領域の変数などの値を変えてしまったり、プログラムがエラー終了したりしてしまう。
　スタックオーバーフローが起きたらすぐにエラーが起こるという保証は無く、たまたま上手く動く条件でプログラムを動かせば
　エラーに気づかず、別の変数の値を変えた時にそれが原因で初めてエラーが発生して気づくなどという場合もある。

・したがって、大きな配列を作るときは動的に確保するようにする。もちろん大きな配列のため、メモリが足りない時もあるが
　そういう時もプログラムの起動はでき、更にスタックオーバーフローのような危険なことも起きない。メモリが足りない場合には
　そのままエラー終了することもでき、メモリが足りない場合用の特別な処理を実行することもできる。このように、メモリの動的確保を使えば
　大きな配列も安全に作成することができる。

・動的に確保したメモリの寿命はnewしてからdeleteされるまでとなる。つまり、newで確保したメモリの寿命はスコープには左右されず、
　スコープを越えた自由な寿命を持つ。ただし、注意しないとメモリリークが起こる可能性があるため十分に注意する。

・クラスと構造体は似てはいるが、やはり構造体とは違うものとなる。
　クラスのメンバにアクセスするためにはpublic:というものを書かなければならない。
　「公開しようとしなければ基本的にメンバは隠される」というこの仕様こそがクラスを象徴する重要な性質を表している。

・クラスは構造体と同じように「型」となっている。クラスの宣言を行った時点ではメモリ上のどこにも実体は存在しない。
　そしてたくさん実体を作ってもそれぞれは全く別の実体を持つ。

・クラスは関数もメンバにすることができる。これを「メンバ関数」と呼ぶ。メンバ関数は「メソッド」とも言う。

・メンバ関数を使うにはまずクラス宣言の中に関数プロトタイプ宣言を書く必要がある。
　普通の関数では条件によっては関数プロトタイプが必要ないこともあるが、メンバ関数の場合は必須となる。

・関数の中身を定義することを「実装する」とも言う。メンバ関数を実装する時は関数名の前にクラス名::をつける。
　どのクラスの関数なのかを表している。

・メンバ関数の中身で扱っているクラスのメンバ変数の中身は、メンバ関数を呼び出した際に使ったオブジェクトのものとなる。
　つまり、students[0].Show()が実行されればこの時のShow()関数の中のnameはstudent[0].nameとなる。
　students[0].Show()が実行されれば中のnameはstudent[1].nameとなる。このように、どのオブジェクトを使って呼んだかによって
　モノが変わってしまう。つまり、内部的にはメンバ関数を呼ぶときにオブジェクトのアドレスを渡し、メンバ関数ではそのアドレスを
　使ってメンバ変数を利用している。

・上記のように、クラスとは「データ(変数)とそれを扱う処理(関数)を1つにまとめた型」となる。
　構造体は単に複数のデータをまとめた型でしかないが、クラスではそれを扱う処理も一体となっている。

・クラスにより、ある物(オブジェクト)をプログラムの中で表現できるようになる。例として車で考えてみると、
　Car(車)というクラスを作り、m_fuel(燃料残量),m_distance(走行距離)などのメンバ変数を作り、Drive(運転)やStop(停車)などの
　メンバ関数を作る。こうすると、Car myCar;とするとmyCarは燃料残量や走行距離などの情報を持ち、myCar.Drive(60, 1000);のようにすれば
　運転でき、myCar.Stop();とすれば停車できる。そして、それぞれの動作に合わせて燃料残量や走行距離などの情報が変化する。
　このように、myCarはまるで1台の車であるかのように振舞うことができる。複数の車を扱いたければCar myCar, yourCar;のようにでき、
　myCarとyourCarはそれぞれ別の燃料残量や走行距離を持ち、myCar.Stop()とすればmyCarは止まるもののyourCarには何ら影響はない。
　このようにまるで物を扱うような感覚で行うプログラミングのことを「オブジェクト指向プログラミング」と呼ぶ。

・クラスの初期化には「コンストラクタ」と呼ばれる特殊なメンバ関数を使用する。Student student;のように書くと
　勝手にこのコンストラクタが呼ばれるため、クラスの初期化についてはわざわざ自分で初期化関数などを呼ばなくてよい。
　コンストラクタはクラス名と同じ名前のメンバ関数で、戻り値が無い。これは戻り値の型がvoidであるということではなく
　戻り値の型すら無い、ということになる。

・コンストラクタでメンバをある値で初期化するように指定すると、そのクラスの実体を作る時に自動的にコンストラクタが呼ばれ、
　そのメンバ変数の値が指定した値で初期化されるようになる。

・引数無しのコンストラクタのことを「デフォルトコンストラクタ」と呼ぶ。変数宣言で引数を指定しなかった場合には
　このデフォルトコンストラクタが呼ばれる。「デフォルトのデフォルトコンストラクタ」では基本型のメンバ変数は初期化されず、
　コンストラクタを持つ方のメンバ変数はデフォルトコンストラクタで初期化される。ただし、デフォルトコンストラクタ以外の
　コンストラクタを作った場合はデフォルトコンストラクタは自動的には作られない。その場合は自分でデフォルトコンストラクタを
　作る必要がある。

・デフォルトコンストラクタにおいて注意する点は、デフォルトコンストラクタを呼ぶことを強調しようと思って
　変数宣言で Integer a(); としてもデフォルトコンストラクタは呼ばれない、といった点。そればかりかこれはInteger型の戻り値を持つ
　引数無しの関数プロトタイプ宣言とみなされてしまい、aという変数すらつくられない。必ず integer a;のようにカッコのない形で書くようにする。

・コンストラクタはオーバーロードすることもできる。また、デフォルト引数を使用することも可能。ただし、デフォルト引数に
　基本的にメンバ変数を指定することはできない(例外有)

・「public:というものを書いてメンバにアクセスできるようになる」と記述したが、正しくは「外部からアクセスできるようになる」。
　外部というのは「そのクラスのメンバ関数の外」ということ。つまり、public:がなくてもメンバ関数内からならそのメンバを使うことができる。
　public:を書いた後にも外部に公開したくないメンバが出てきたときは、private:と記述すればそれ以降のメンバは
　そのクラスのメンバ関数からしか利用できなくなる。これらpublicとprivateのことを「アクセス指定子」と呼ぶ。

・メンバ変数を外部から隠し、関数を通して扱うようにすることによって、メンバ変数の値を保証したりその扱いを安全にしたり
　することができる。アクセス指定子はそのためにとても重要な役割を果たす。そのため、メンバ変数は基本的にすべてprivateにする。

・クラスで動的に確保したメモリは「デストラクタ」によって解決される。デストラクタはオブジェクトが寿命を迎えた時に
　自動的に呼ばれる特殊な関数。つまり、クラスはコンストラクタに始まりデストラクタに終わる。

・デストラクタを自分で作らなかった場合はデフォルトのデストラクタが自動的に作られる。デフォルトのデストラクタでは何も行われない。
　デストラクタはクラス名の前に~(チルダ)をつけて定義する。つまりIntArray::~IntArray() {　のような形。

・デストラクタでメモリを解放するようにしておくと、変数の寿命が来た時に自動的にメモリを解放してくれる。これによりメモリリークからも
　解放される。なお、そのクラスのデストラクタを実行し終えると、次に全メンバ変数のデストラクタが自動的に呼ばれる。
　メンバ変数の寿命が尽きるわけなので当然と言えば当然。

・デストラクタは後に作られた方が先に呼ばれている。変数を作った時と逆順にデストラクタが呼ばれる理由は、後に作った変数は前に作った
　変数に依存している可能性があるから。なお、グローバル変数を複数作った場合、各ファイル内においては変数の実体定義の出現順に
　コンストラクタが呼ばれていくが、異なるファイルにあるグローバル変数との間の初期化順は特に決まっていないため注意する。
　ただ、この際もコンストラクタが呼ばれた順とは逆順でデストラクタが呼ばれる。

・exit関数を呼んでプログラムを終了した場合、デストラクタは静的変数のものしか呼ばれず、自動変数のデストラクタは呼ばれないので注意する。

・クラスをヘッダファイルで宣言する場合、そのクラスの実装部は別途ソースファイルを作成してそこに記述する形となる。
　その際もクラスを宣言したヘッダファイルを#includeする必要がある。

・なぜクラスを宣言したヘッダファイルをそれぞれで#includeしなければならないのか、それはもし#includeを使わずにクラスを複数のファイルで
　使おうとした場合を考えるとなぜこうなっているのかがわかりやすい。クラスを使うにはそのクラスの完全な宣言が必要となる、
　メンバ関数を実装する時にもそのクラスの完全な宣言が必要になる、メンバ関数はどこか1か所のみで実装されなければならない、
　これらを踏まえると、クラスの宣言部は全く同じ形で別々のソースファイルに書かれるのでこの部分をヘッダファイルにしてしまうと便利、ということ。
　インクルードというのはあるファイルの中身を別のファイルに埋め込むという作業のため、ヘッダファイルを展開すれば#includeを
　使わない場合と同じ形になる。ヘッダファイルが展開されてコンパイルされる、といったことを忘れがちになってしまうので気を付ける。(p299辺り)

・coutやcinは本来std::coutなどのように記述しなければならないが、using namespace std;を使うとそのstdを省略して記述することができる。
　しかし、このusing namespaceを使用すると「std」に存在する名前群(例:countなど)をプログラム内で変数名などに使用したときに
　どっちがどっちかわからなくなってしまうなどの問題があるため使用は控えた方が良い。

・クラスの実体を関数の仮引数とする際に、値渡しとなるためメンバ変数がアドレスとなっている場合はそのアドレスが渡される。
　すると、クラスの仮引数の寿命はその関数が終わるまでなので、関数が終了するタイミングでデストラクタが呼ばれる。このとき、仮引数のデストラクタで解放されるのが
　実引数の参照するメモリが解放されてしまうと、main関数を抜けようとしたときに実引数のデストラクタが呼ばれても
　既にメンバ変数の指していたメモリが解放されているため、deleteしようとしても見つからずにエラーが出てしまう。

・仮引数が作られる時にもコンストラクタが呼ばれる。このコンストラクタはコンストラクタの中でも特殊な「コピーコンストラクタ」と呼ぶ。
　コピーコンストラクタはそのクラス型への参照を引数に取るコンストラクタ。特にconst参照を取ることが多い。例えばIntArrayなら
　IntArray(const IntArray& other)となる。

・constの付いたオブジェクトのことを「constオブジェクト」と呼ぶ。もしコピーコンストラクタの引数をconst参照にしなかった場合は
　このconstオブジェクトを渡せなくなる。ただし、const参照版と非const参照版の両方を作ることは可能。その場合、constオブジェクトを渡した時には
　const版が、非constオブジェクトを渡した時には非const版が呼ばれる。

・コピーコンストラクタを自分で作らなかった場合はデフォルトコンストラクタの時と同様、デフォルトのコピーコンストラクタが自動的に作られる。
　そのデフォルトのコピーコンストラクタでは全てのメンバ変数をその型のコピーコンストラクタを使って複製する。
　基本型にもコピーコンストラクタが存在し、基本型のコピーコンストラクタは引数の値で変数を初期化するだけ。

・確認のテキストを表示するようにすると、何がどう機能しているかがよくわかる。

・初期化ではなく代入の場合にはコピーコンストラクタは呼ばれないので注意。コピーコンストラクタが無い場合に各メンバ変数がコピー元のメンバ変数の値で
　初期化されるのと同様、代入の場合も各メンバ変数にコピー元のメンバ変数が代入されてしまう。

・代入の問題を解決するには、「演算子オーバーロード」を使用する。代入は=という演算子で行われる。
　この演算子のふるまいを変更するのが演算子オーバーロードとなる。つまり、b = a; としたときに
　何か特殊な関数を呼ぶことができる。

・void operator=(引数)としたとき b = a; は b.operator=(a); であると解釈されて実行される(実際このように記述することも可能)
　あとはこのoperator=関数を実装してやれば b = a; としたときのふるまいを自分で決めてやることができる。「

・なお演算子の内、=演算子に限っては自分で定義しなかった場合には自動的にデフォルトのoperator=が作られる。
　このデフォルトのoperator=では各メンバ変数にコピー元のメンバ変数が代入される。

・メンバ関数がメンバ変数を変更するかどうかというのは、コンパイラにはわからない。そのため、メンバ関数の宣言の後ろにconstをつける必要がある。
　int IntAreay::Size() const {} のようにする。こうすると、Sizeがメンバ変数を変更しないメンバ関数であるということがコンパイラにやっとわかるようになる。
　こういったメンバ関数を「constメンバ関数」という。もちろん、constメンバ関数の中でメンバ変数の内容を変えてしまうとコンパイルエラーとなる。

・constオブジェクトからはconstメンバ関数しか呼べない。

・constメンバ関数から非constメンバ関数は呼べない。

・constオブジェクトのメンバ変数は変更することができないが、まれにどうしても値を変更したい変数があることもある。
　そういった時はメンバ変数の方にmutable(変更可能な)という記憶クラス指定子を加える。そうすれば、constオブジェクトであっても
　そのメンバ変数の内容を変えることができるようになる。ただし、mutableを使用するのは非常に危険なため、mutableが必要となった場合
　本当に使わないといけないのか考え、それでもどうしても必要になった場合にのみ十分注意を払いながら使用するようにする。

・あるクラスを基に新しいクラスを作ることを「継承」という。継承はclass クラス名:アクセス指定子 基底クラス名 のように行う。

・C++の標準ライブラリ関数はstd::をつけないとエラーが出るものが多い？

・別々のクラスで共通している処理があるような場合、その共通部分を抜き出して1つのクラスとしてしまうことができる。
　そして、別々のクラスをその共通部分をまとめたクラスを基にして作ることができる。基となるクラスを「基底クラス」と言い、
　あるクラスを基にして作られたクラスを「派生クラス」と言う。あるクラスを基にしてクラスを作ることを「継承」あるいは「派生」と呼ぶ。
　派生クラスはその基底クラスのメンバを引き継ぐ。派生クラスでは足りないメンバだけ定義すればよい。

・派生クラスのアクセス指定子をprivateにすると、基底クラスではpublicだったメンバも派生クラスにおいては全てprivateとなる。
　publicにした場合は、全てpublicにするわけではなく、元のアクセス指定子を保存する(基底クラスのprivateはprivateのまま？)
　つまり派生クラスと基底クラスのアクセス指定子でより厳しい方が採用される。たいていはpublicなのでとりあえずpublicを指定するのはあり。
　ただし、アクセス指定子を省略するとprivateになるため、publicにしたい場合は必ずpublicを忘れないように注意する。

・基底クラスのprivateメンバは派生クラスにすら公開されない。しかし、publicにすると外部から好き放題使えてしまう。
　この問題を解決するには「protected」アクセス指定子を使用する。この指定子を使えば、「外部には公開されないが派生クラスには公開される」
　といったことが実現可能となる。

・基底クラスと派生クラスの継承関係はよく「クラス図」というもので表される。基底クラスを上に、その下に派生クラスを書き
　派生クラスから基底クラスへ矢印を書いて継承関係を表す。また、こういった継承関係のことを「継承木」ということがある。
　継承木は上の方に基底クラスを書き、下向きに枝分かれしていくのが普通。根っこのように見えるが、こういう分岐構造を
　よくツリー(木構造)と言うため、継承根ではなく継承木という。

・派生クラスのオブジェクトは基底クラスへの参照に渡すことができる。派生クラスから基底クラスへの参照への暗黙のキャストのことを
　「アップキャスト」という。継承木の上の方にあるクラスへのキャストなのでアップキャスト。

・複数のクラスをもっと抽象化したレベルで眺め、共通項をあぶりだし、その共通項に対するプログラムを記述すれば
　それらのどのクラスに対しても適用できる処理を1つの処理にまとめることができる。例えば、人間にもいろいろな人がおり、
　職業で分けたとするとプログラマ、学者、小説家、ゴルファーなどさまざまな職業の人がいるが、彼らが食事をしたり呼吸をしたり
　するのは別にプログラマだからとか小説家だからとかではなく「人間だから」食事をしたり呼吸をしたりする。
　そのため「人間は食事をする」「人間は呼吸をする」ということさえわかっていれば「歌手は食事をするか」と問われても
　歌手が人間だとわかった時点で「歌手は食事をする」ということを事前に知らなくても「歌手は食事をする」とわかる。
　どの職業の人でもみんな「人間」だという風に抽象化できる。そしてその抽象化された「人間」という概念レベルで
　法則を記述すれば、それはどの職業にも適用できるということ。

・基底クラスにある関数の定義を派生クラスで変更することができる。これを「オーバーライドする」という。上に乗って
　定義を上書きしてしまう、という感じ。例えば、基底クラスでSet()関数を定義し、派生クラスでもSet()を定義している時、
　基底クラスのオブジェクトでSet()を呼び出せば基底クラスのSet()関数が、派生クラスのオブジェクトでSet()を呼び出せば
　派生クラスのSet()関数が呼び出されるようになる。

・オーバーライドをしても、アップキャストをしてしまうとアップキャスト先のクラスのメンバ関数が呼ばれてしまう。
　それを回避するには、基底クラスのヘッダファイルに記述されているメンバ関数の宣言において、
　メンバ関数名の前に「virtual」をつける必要がある。このようにメンバ関数の宣言にvirtualをつけておくと
　アップキャストをしても本来のクラスのメンバ関数が呼ばれるようになる。このvirtualが付けられたメンバ関数のことを
　「仮想関数」と呼ぶ。virtualなしにオーバーライドすることはほとんどないと思われるため、
　忘れないように気を付ける。なお、派生クラスの方のメンバ関数の宣言にはvirtualをつけてもつけなくてもよいが、
　仮想関数であることをわかりやすくするためにつけるのもあり。

・ある1つの記述stream.Set()などで行われる処理がアップキャストと仮想関数を利用することでstreamの本当の型ごとに
　変更される性質を「ポリモーフィズム」と言う。このポリモーフィズムこそが継承の本領であり、クラスの本領であり、
　オブジェクト指向プログラミングの本領となる。ポリモーフィズムを使いこなせば、色々なプログラムを効率よく
　汎用的に書くことができるようになる。

・仮想関数はどんな状況でもそのオブジェクトの本来の型のものが呼ばれる。仮想関数を使えば、基本的な処理の流れを
　基底クラスで書いておいて、その要所要所の処理を派生クラスに定義させるという風な使い方ができる。
　良く使うパターンなのでどんどん活用してみるとよい。

・仮想関数について、仮想関数の宣言に0を代入する形のコードを書くと実装部を記述しなくてもよくなる。
　この実装のない仮想関数のことを「純粋仮想関数」と呼ぶ。

・純粋仮想関数を持つクラスのオブジェクトは作れない。このようなクラスを「抽象クラス」と呼ぶ。
　ただ、抽象クラスへの参照やポインタを作ることはできる。純粋仮想関数が1つでもオーバーライド
　されていなければ派生クラスも抽象クラスとなる。すべての純粋仮想関数がオーバーライドされて初めて
　そのオブジェクトを作れるようになる。

・純粋仮想関数を使用したときとそうでないときでは何が大きく違うのか？それは、Streamクラスのオブジェクトが
　作れないことが「保証されるかどうか」といったこと。Streamクラスに直接の使い道が無いのであれば
　むしろそんなものは使えない方がよい。Streamクラスを作らないように注意して回らなくても、SetBaseメンバ
　関数を純粋仮想関数にすればそれだけでStreamクラスのオブジェクトがどこにも存在しないことを
　保証することができる。

　constにしろ、アクセス指定子にしろ、純粋仮想関数にしろ、「できるべきでないことはできないように保証する」
　という仕様がC++にはいろいろ備わっている。これらはプログラムの動作には全く影響を与えないが、
　間違ったプログラムを書いてしまってもコンパイルエラーになってくれるというメリットがある。
　実行時のいつ出るかもわからないエラーを待たずともコンパイル時にエラーになってくれる。これはバグを
　事前に防ぐために非常に重要な仕様なのでどんどん活用していった方が良い。

・派生クラスのコンストラクタを呼ぶとそれより先に基底クラスのコンストラクタが自動的に呼ばれる。
　まず基底クラスに関する情報を初期化し、それから派生クラスで新しく増えた情報を初期化する。
　このように段階的に初期化することにより、Streamクラスに関する初期化はStreamクラスに、InputStreamクラスに
　関する初期化はInputStreamクラスにのみ書けばいいようになる。

　派生クラスのコンストラクタだけ呼ばれるとなると、基底クラスのコンストラクタの内容と同じものをまた
　書く必要が出てきてしまう。また、派生クラスのコンストラクタが先に呼ばれてしまった場合も、やはり基底クラス
　のメンバを初期化しなければそれらを安全に使うことができない。基底クラス→派生クラスの順でコンストラクタが
　呼ばれるのにはこのようにちゃんと意味がある。

・デストラクタではコンストラクタとは逆に派生クラスのデストラクタが先に呼ばれ、そのあとに基底クラスのデストラクタ
　が呼ばれる。これはデストラクタのそもそもの本質と似たようなもので、派生クラスは基底クラスに依存しているため、
　先に基底クラスの情報を破棄するとよくわからない状態となってしまう。そのため、派生クラス→基底クラスの順で
　デストラクタが呼ばれる。

・基底クラスのコンストラクタがデフォルトコンストラクタの場合、基底クラスのコンストラクタを呼び出すプログラムを
　省略することができる。デフォルトコンストラクタ以外のコンストラクタは自動的には呼ばれず、明示的に呼ぶ必要がある。

・「派生クラスのコンストラクタを呼ぶと、それより先に基底クラスのコンストラクタが自動的に呼ばれる」となっているが、
　基底クラスのコンストラクタに引数が存在する場合、何らかの形で引数を指定する必要がある。それが文法の
　「基底クラスのコンストラクタを呼ぶ」に書いてある記述方法となる。これはクラスの実装ファイル(.cpp)で記述する。

　この構文は基底クラスのコンストラクタを呼ぶときだけでなく、メンバ変数のコンストラクタを呼ぶときにも使用する。
　初期化したいメンバ変数が複数ある場合はコンマで区切って書く。その初期化の順番にも決まりがあり、まず基底クラスの
　初期化が優先され、その後メンバ変数の初期化が行われる。そして、それぞれの中でもメンバ変数が宣言された順に
　初期化が行われる。コロンの後にこの順番で書かなかった場合でもこの順番でコンストラクタが呼ばれるため、
　紛らわしいのを防ぐためにクラス宣言に書いた通りの順番で書くのが良い。

・コンストラクタにおいて m_a = b の形で初期化した場合、これは文法的にはdouble m_a → m_a = b のようなものであり、
　double m_a = b; のようなものではない。これを初期化するにはどうすればよいか？それは、これも上記のように
　コロンをつけてm_a(b)とすることができる。double型の変数なのにコンストラクタを呼ぶような形で書いているが、
　なぜこの記述ができるのか、それは、double型のような基本型もコンストラクタを持っているため。つまり、普通に
　main関数内でも int x(3) のように記述すると、xは3で初期化される。これを使えば基本型の変数であっても
　コロンの後で初期化することができる。

・int型やdouble型など、デフォルトで提供されるコンストラクタしか持たない方のことを「POD(plain old data)型」という。
　メンバ変数がPOD型のみで構成された独自のコンストラクタの定義されていない構造体やクラスもPOD型となる。
　これに対し、独自のコンストラクタの定義された方のことを「non-POD型」という。また、non-POD型のメンバ変数を
　含む構造体やクラスであれば、その構造体やクラスがデフォルトで提供されるコンストラクタしか持っていない場合であっても
　non-POD型となる。

・全ての型にはデフォルトコンストラクタとコピーコンストラクタが自動的に作られる。POD型の場合、
　デフォルトコンストラクタは0初期化を行い(基本型の場合は0で初期化し、構造体やクラスの場合は全てのメンバを
　0初期化する)、コピーコンストラクタは指定された値をそのままコピーする。non-POD型の場合は、基本的に各メンバ変数の
　デフォルトコンストラクタやコピーコンストラクタを全て呼ぶ形となる。

　ただし、POD型には少し特殊な性質があり、変数を宣言したとき、何の初期化もしなければ
　デフォルトコンストラクタすら呼ばれない。例えば int n; とした場合、intのデフォルトコンストラクタは呼ばれない。
　これはnon-POD型のクラスのPOD型のメンバ変数であっても同様で、明示的にデフォルトコンストラクタを呼ばない限り
　デフォルトコンストラクタは呼ばれない。

・コンストラクタ、デストラクタで仮想関数を使用する場合、派生クラスのものではなくそのクラスのメンバ関数が呼ばれ、
　派生クラスのメンバ関数は決して呼ばれないので注意する。例えば、Streamクラスのコンストラクタが実行されている時点では
　まだInputStreamクラスのコンストラクタは実行されていない。そんな状態でInputStream::Setbaseメンバ関数が
　正しく実行できると保証はできず、非常に危険なことである。そのため、Streamクラスのコンストラクタが実行されている時点では
　SetBaseはStream::SetBaseであるとみなされる。このことはデストラクタでも同様となっており、デストラクタ内で仮想関数を
　使っても、そのクラスのメンバ関数が呼ばれる。これも同様に考えて、Streamクラスのデストラクタの中では既にInputStream
　クラスは破棄されているため、その状態でInputStream::SetBaseメンバ関数を呼ぶのは非常に危険。
　こういった影響はこの理由からわかるように、コンストラクタやデストラクタ内で呼ばれたメンバ関数内においても現れる。
　例えば、Streamクラスのコンストラクタ内でSetメンバ関数を呼んだ場合、その中のSetBaseメンバ関数は常に
　Stream::SetBaseメンバ関数となる。

・仮想関数の仕組みは多くの場合「仮想関数テーブル」という隠しメンバ変数を使って実現されている。
　仮想関数テーブルとは、「ある仮想関数を呼ぼうとしたとき、実際にはどの関数が呼ばれるのか」という情報が
　書かれた表のこと。例えばStreamの場合は次のように SetBase → なし となっている。Stream::SetBaseは純粋仮想関数なので
　どの関数が呼ばれるのかという情報が無い。純粋仮想関数の宣言で =0 と書くのも仮想関数テーブルをヌルポインタで初期化している
　という風なイメージで見れば自然な表現だとわかる。そしてInputStreamの場合は次のように SetBase → InputStream::SetBase
　となっている。

　仮想関数テーブルはコンストラクタの最初に初期化されデストラクタの最後で破棄される。そのため、Streamクラスの
　コンストラクタの中ではまだ仮想関数テーブルはStreamクラス用のものであり、SetBaseメンバ関数は呼べない。
　InputStreamクラスのコンストラクタに入った時点でようやくInputStream::SetBaseメンバ関数が呼ばれるようになる。
　仮想関数テーブルの隠しメンバ変数は、たいていは実際の仮想関数テーブルへのポインタで実装されていると思われる。
　コンストラクタの最初とデストラクタの最後でそのポインタを置き換える。仮想関数テーブルは隠しとは言えメンバ変数なため、
　当然ながらポインタのサイズだけオブジェクトのサイズは増える。メモリ使用量を見積もる場合や少し危険なキャストをする場合などでは
　この仮想関数テーブルの有無を必ず考慮に入れるようにする。

・オーバーライド前の関数を呼びたくなった時は、使用したいクラスの名前::メンバ関数名() と書けば
　オーバーライド前のメンバ関数を呼ぶことができる。クラス名::メンバ関数名 というのはフルネームのようなもので、
　メンバ関数をこのフルネームで呼んだ場合は、たとえ仮想関数であってもその指定したクラスのメンバ関数が呼ばれる。

・クラスのオブジェクトを動的に確保する場合はnewした時点でコンストラクタが呼ばれる。デフォルトコンストラクタの場合は
　カッコを省略できる。なお、配列を動的に確保する場合はデフォルトコンストラクタしか呼べない。

・条件によって同じ基底クラスを持つ別のクラスを作りたい場合には、オブジェクトを動的に確保して基底クラスへのポインタに
　入れて扱うのが定石。

・ある一連のクラスのオブジェクトを動的に生成して返すクラスを「ファクトリクラス」という。
　良く使うので覚えておくとよい。

・基底クラスへのポインタを指定して動的に確保したオブジェクトのdeleteを行うと、場合によっては派生クラスのデストラクタより
　先に基底クラスのデストラクタを呼んでしまいメモリリークとなる可能性がある。これは、基底クラスへのポインタを使って
　派生クラスへのデストラクタが呼べればよい、ということになる。つまり、デストラクタを仮想関数にしてしまえばよい。
　このように、デストラクタは必ず仮想関数にするようにする。

・C++には標準で文字列を扱うクラスが用意されている。それがstringクラス。stringクラスのオブジェクトには
　文字列を代入したり足しこむことができる。char配列の場合はこういうことはできないが、stringクラスには
　演算子オーバーロードが利用されているためこういったことが可能となる。もし文字列の長さに対してメモリが
　足りなくなってもstrignクラスが勝手により広いメモリを確保してくれる。
　さらに、i番目の文字を hello[i] という配列と全く同じ形で取得できる。これも演算子オーバーロードによって実現しており
　配列と同じようにすれば文字列の各要素を参照することができる。

・stringクラスのオブジェクトはconst char*を引数にとる関数にはそのまま渡すことができない。
　そこで、stringクラスにはc_strというメンバ関数が用意されている。この関数を呼べば生の文字列のアドレスを返してくれる。
　ただ、ここで得られる文字列はstringクラスの非constメンバ関数を呼んでしまうと内容が保証されなくなってしまう。
　文字列の内容が変わることもあり、メモリの再確保によりメモリが解放されてしまう可能性もある。
　もしずっと保存しておきたいのであれば何らかの形でコピーするようにする。

・文字列をconst char配列として得るためのメンバ関数には、c_strの他にdataというメンバ関数もある。
　c_strはヌルターミネータがついていることを保証するが、dataは保証しないという違いがある。
　stringクラスは内部的にはヌルターミネータを使わない実装になっているかもしれない。
　文字列のサイズは恐らくメンバ変数に保存してあると予想されるため、ヌルターミネータは特に必要ない。
　そのため、c_strメンバ関数を呼んだ場合にはヌルターミネータを付け加える処理が入る可能性がある。
　もしヌルターミネータが必要ないのであれば、無理にc_strを呼ばずともdataを呼んだ方がよい。
　c_strを使うかdataを使うかの違いによってヌルターミネータ期待しているかどうかの違いが読み取れるため
　きちんと使い分けることによってプログラムが読みやすくなる可能性がある。

・もしchar配列で文字列の内容の比較をしたい場合、==は使えずstrcmpという関数を使って比較することになるが、
　stringクラスのオブジェクトの場合には==演算子を使って文字列を比較できる。

・日本語で検索などを行う場合、Unicodeの場合には(UTF-7以外の符号化方式では)問題は発生しないが、
　Shift_JisやEUC-JPの場合には問題が発生する。例えば、Shift_JISの「表示」という文字列の中から\を検索するとする。
　「表示」という文字列は一見\を含んでいないように見えるが、「表」という字の文字コードは2バイトで構成されており、
　その2バイト目の値が\の文字コードと等しいため、そこで検索に引っかかってしまう。

・stringクラスを利用して文字列を作るような処理も用意されている。それが「stringstreamクラス」となる。
　必要となるヘッダファイルはsstream。

・coutの場合は作った文字列をそのまま画面に出力するが、stringstream(sstr)の場合は
　文字列を作るだけとなる。

・strメンバ関数に引数を渡せばstringstream内部の文字列がその文字列に置き換わる。

・近年のコンピュータの高速化に伴い、多少処理量が多くても良いからわかりやすいプログラムを書くことも多くなってきた。
　これを「富豪的プログラミング」と呼ぶことがある。これは決して悪いことではなく、
　わかりやすいプログラムはバグも出にくくデバッグもしやすいため、むしろ推奨されると言ってよい。

・stringstreamを使用すると、sstr("1 2); → sstr >> x >> y; とした場合、xに1が、yに2が代入される。
　このように文字列への出力も可能となる。

・特に時間のかかっている処理のことを「ホットスポット」と呼ぶ。

・ファイルに数値が書いてある場合、オブジェクト名 >> 変数名(例:file >> n;)のようにして数値を読み込むことができる。

・C/C++の機能を使う場合においては改行コードは\n(10)に統一されている。
　ファイルのテキストモードは改行コードを自動的に読み替えてくれるモード。
　つまりファイルから読み込むときにはその環境の改行コードは\nに変換されて読み込まれ、
　ファイルに書き出すときには\nはその環境の改行コードに変換されて書き込まれる。
　テキストモードとバイナリモードとの違いはこの改行コードの読み替えだけとなっており、
　それ以外はバイナリモードと何ら変わりがない。

　例えばテキストモードで file << '\n' << flush; とした場合、Windowsであれば\r\nの2バイト、macであれば\rの1バイト、
　UnixやLinuxであれば\nの1バイトが書きだされる。同様に、そうして作られたファイルから char ch; → file.read(&ch, sizeof ch);
　と1文字読み込もうとすると、常に\nという値が読み込まれる。

・4進法、8進法、10進法などこの数字の個数のことを「基数」という。

・8進数や4進数から10進数に変換する方式としては、例えば8進数で312とある場合、これを
　(100 * 3) と (10 * 1) と (1 * 2) に分解する。一の位は共通のためそのままの値、
　10というのは10進数で言うと桁数が1つ上がることを意味するので8進数で桁数が1つ上がるのは
　値が「8」の時。つまり十の位は10を8に変換して計算する。百の位は(十の位 * 10)を意味するので
　8進数の場合では8 * 8、つまり100 = 64となり、あとはこれを当てはめて計算すれば
　(64 * 3)、(8 * 1)、(1 * 2)となりそれらの積を足すと192 + 8 + 2 = 202 という風に求められる。
　4進数の場合は十の位が4、百の位が4 * 4で16となる。この方法は基数の小さいものから大きいものへの
　変換に便利となる。

　その逆として10進数から4進数や8進数に変換する方式としては、10進数で表されている値を
　4や8で割っていき、余りの数を下から順に読んでいけば求めている数となる。例えば、10進数の202を
　8進数で求めると、まず25 余り 2、その次に3 余り 1、最後はそのまま3が余るのでこれを下から読むと312となる。
　この方法は基数の大きいものから小さいものへの変換に便利となる。

・2進数から16進数への変換は2進数を4桁ごとに区切って変換するが、2進数から8進数の場合はこれを
　3桁ごとに区切ると求められる。

・16進数から10進数への変換は、16進数の1の位から16^0,16^1,16^2・・・という風に振っていき、あとはそこで
　計算した16の乗数とその位にある数値を掛け算し、各位で求められた数値を足していく。一の位は16^0なので
　そこにある数値をそのまま持ってくる。例えば12Aとあった場合、Aが16^0なので10,2が16^1なので16 * 2で32,
　1が16^2でまず16 * 16で256,それと1をかけるので256,そこからそれぞれで求められた 256 + 32 + 10 を行うと
　答えの298となる。

・10進数から16進数への変換は、16で割っていき余りを下から並べるか、2進数に直してから16進数に直す方法がある。

・C/C++ではプログラム上で10進定数、16進定数、そして8進定数を表現できる。16進定数は頭に0x、
　8進数は頭に0をつけて表現する。そのため n = 214; n = 0xD6; n = 0326; の3つはどれも全く同じ値が代入される。
　ただし、2進定数は表現できないため16進定数か8進定数に直して表現する必要がある。

・8進定数はほとんど使われないが、MacOSX、Unix、Linuxにおけるファイルのパーミッションの指定に役に立つ。
　これは3ビットごとに情報を指定するため、8進定数を使うと便利。また、1バイトのビット数が3の倍数である環境に
　特化したプログラムを作る場合は8進定数の方が便利に使える。

・ファイルに生の値を書き込む場合、通常はバイナリモードでファイルを開く。理由としては、テキストモードで開くと
　生のデータの中に10という値があった場合にそれがその環境の改行コードに変換されてしまうため。

・int n; とした場合に&nとすると、int型は多くの環境では4バイトのため、連続する4バイトの領域の先頭のアドレスが取得できる。

・環境によって多バイト値の並び順が下の方のバイトから順に出力されるか、上の方のバイトから順に出力されるかが違う。
　このような多バイト値のことを「バイトオーダ」と呼ぶ。そして下の方から出力される方を「リトルエンディアン」、
　上の方から出力される方を「ビッグエンディアン」という。

・別のバイトオーダの環境で作ったファイルから読み込んだ場合、メモリ上の出力が違うため
　特定のバイトオーダを指定するプログラムを記述する際は注意する。

・ファイルやメモリなどの中身をチェックするために1行につき16個の値を出力して表示することを「ダンプ」という。

・エラーチェックの際に、読み込みの場合はファイルの終端に到達した際もfailメンバ関数が真となるため、
　eofメンバ関数が真になる場合は除外しておく必要がある。

・ファイルを操作する際には次はどの位置から読み込むか、次はどの位置に書き込むか、という情報が使われる。
　これを「ファイルポインタ」という。

・ファイル操作において、一旦別の位置に移動して何かを読み込み、また元の位置に戻ってきたいという場合などに
　tellgメンバ関数が便利となる。まずtellgで元の位置を保存して起き、seekgで別の位置に移動し、
　そしてseekgの引数にtellgで取得しておいた位置を指定すると元の位置に戻る。この時、元の位置に戻る処理と
　そのあとに進む処理はひとまとめにしないように注意する。例えば、file.seekg(pos + 10) ではなく、file.seekg(pos)
　でいったん戻ってからfile.seekg(10, ios::cur)とするようにする。これはstreamposが必ずしも普通の整数型ではなく
　計算に使えるかどうかわからないため、環境によってはコンパイルできなくなる可能性があるため。

・stringstreamやfstreamはiostreamというクラスの派生クラスになっており、iostreamはistreamとostreamの派生クラスになっている。
　このistreamは入力のためのクラスで、ostreamは出力のためのクラスとなっている。cinはistream、coutはostreamクラスのオブジェクト。
　そして、iostreamはその両方を行うための、入出力のためのクラスとなる。<<での出力やwrite,seekp,tellpといった関数は全てostreamクラスの
　機能で、>>での入力やread,seekg,tellgといった関数は全てistreamクラスの機能。そのおかげで、coutやcinと同じ方法で
　stringstreamやfstreamを扱えた、ということになる。

　そしてstringstreamやfstreamにも入力、出力専用のクラスが存在し、入力専用のものには頭に i をつけ、
　出力専用のものには頭に o をつければよいだけ。iのついたものはistreamの、oのついたものはostreamの派生クラスとなっている。
　1つ注意する点としては、fstreamはifstreamとofstreamの派生クラスではないという点。あくまでfstreamはiostreamの派生クラスであるため、
　fstream&からifstream&へのキャストはできない。ただ、fstream&はistream&へアップキャストすることはできる。

・この継承関係が存在するため、例えばostream&を引数に取る関数を書けばostream,iostream,ostringstream,stringstream,ofstream,fstreamの
　全てのオブジェクトを渡すことが可能となる。これを利用すれば、出力に関する処理を1つにまとめることができる。

・入出力の処理というのは基本的には低速(文字列処理は例外)なため、実際にファイルなどに直接入力するのではなく、一旦比較的高速に操作できる
　メモリ上に出力し、その作業用のメモリがいっぱいになるなどしたときになって初めて実際にファイルなどへ入出力するようにしたほうが
　効率が良くなる。この一連の処理を川の流れ(stream)に例えて、この機構を「ストリーム」という。簡単に言えば、ストリームとは
　効率のいい入出力機構のこと。istream,ostream,iostreamクラスはこのストリームという機構を利用した入出力クラスになる。

・データをいったん貯めておく領域を「バッファ」と言い、データをいったん貯めておくことを「バッファリング」という。
　そして、バッファリングされたデータを実際にファイルなどへ出力する処理を「フラッシュ」という。フラッシュとは水を一気に流すという意味で
　貯まったデータを一気に出力するイメージ。flushやendlなどを使うとフラッシュできる。

・ostreamクラスのオブジェクトには標準出力用のcoutの他に、標準エラー出力用のcerrとclogがある。cerrとclogの違いは
　cerrはバッファリングしないという点。標準出力と標準エラー出力は両方ともデフォルトでは画面への出力となる。
　これらの出力先を変更することも可能であり、それぞれに別々の出力先を与えることも可能。

・cout,cin,fstream,stringstreamに対する操作はかなりの部分で共通している。>>や<<もそうであり、read,write,getlineなどもそう。
　これらは全て継承を通じて共通化されている。また、エラー処理に関するfail,eof,clearに関しても同様。例えば、cinで数値を入力すべきところに
　文字などを入力しようとすると解析に失敗してfail状態になってしまう。この状態になるとfailメンバ関数が真を返すようになり、
　clearするまでは以降の入力もすべて失敗する。このような場合、failした場合にはclearしてから1文字読み飛ばすという処理を加えることで
　エラー状態から復帰することができるようになる。

・ストリームの流れを操作するには「マニピュレータ」というものを使う。一部を除いて、マニピュレータを使うには「iomanip」ヘッダが必要となる。
　endlやflushもマニピュレータとなっており、これらのようにマニピュレータを<<や>>に流すことによりストリームを操作することができる。

・ループ文の中にずっと効果の続くマニピュレータがある場合、それをループ処理の前に持ってくることによって無駄な処理を無くすことができる。

・ずっと効果の続くマニピュレータを使う場合、他の部分の入出力に影響を与えてしまう危険性があるため、
　一旦今までの設定を保存しておいて処理が終わった後に復帰しておくのが無難。

・マニピュレータに関する設定はflagsメンバ関数を使えば取得でき、setiosflagsというマニピュレータで指定できる。
　hexやuppercaseなどで指定する設定はまとめてflagsメンバ関数で取得でき、その設定を表す値の型は「ios::fmtflags」となる。
　ただしsetfillで指定した設定は取得できないため、これはfillメンバ関数で別途取得する必要がある。例えば、
　ios::fmtflags flags = cout.flags(); → char fill = cout.fill(); とすれば現在の設定をflagsとfillに格納することができ、
　cout << setiosflags(flags) << setfill(fill) とすれば、その設定を復元できる。なお、cout.flags(flags);やcout.fill(fill);
　とすることも可能。

・マニピュレータを自作すると便利なことが多い。istream&やostream&を引数と戻り値に取る関数を作れば
　その関数自身が引数なしのマニピュレータとなる。例えば、ostream& hexZ(ostream& ostr) { return ostr << setfill('0') << hex << uppercase; }
　のような関数を自作しておけば、cout << hexZ;とするだけでこの関数内の全てのマニピュレータが適用される。

・名前空間は namespace 名前空間名 {・・・} で定義することができる。クラスや関数、変数などの名前のことを総称して「識別子」と呼ぶ。
　ある名前空間内で宣言された識別子は、その名前空間に属する。名前空間内の識別子を利用するには 名前空間名::識別子 のような形で利用する。
　名前空間が違いさえすれば、全く同じ名前の関数やクラスを宣言することができる。

・名前空間を指定していないところに関しては、名前なしの名前空間である「グローバル名前空間」に属すことになる。グローバル名前空間に属す関数を
　呼びたい場合は、特に頭に何も書かずにアクセスできる。あるいは::Func()のように、名前空間名を書かずに::だけを前に着けた形でもよい。
　グローバル変数を使うために::をつけるのは、グローバル名前空間の変数を使うように指定する形。

・不慮の名前の衝突を避けるためにもクラスや関数などは何らかの名前空間に入れておいた方が良い。

・using namespace 名前空間名; と書くことで、以降可能な限り名前空間名::を省略することができるようになる。これを「using指令」という。

・using std::cout; のように個別にusingすると、これだけ名前空間を省略して記述することができる。これを「using宣言」という。
　using指令には様々な問題があるため、usingの影響範囲を限定することで問題を少なくするために利用される。
　また、関数内でusingを使うこともできる。その場合はその関数内でのみ名前空間名を省略することができる。

・例外として、ヘッダファイルだけはusingを使うべきではない。その理由として、ヘッダファイルは色々なファイルにインクルードされるため、
　usingのあるヘッダファイルをインクルードすると、その影響はヘッダファイル内にとどまらず、そのヘッダファイルをインクルードした
　ファイル全体にも及ぶ。ヘッダファイル内で更に別のファイルをインクルードすることもあり、ある位置で何がusingされているかは
　すぐには把握できないこともある。

・同じ名前空間内にある識別子を使う場合は名前空間の指定を常に省略することができる。
　もしグローバル名前空間にある識別子と被った場合は、グローバルじゃない名前空間の中の識別子が優先される。

・名前空間定義は複数個所に分離することが可能。実際にはヘッダファイルとソースファイルに宣言と実装を分離するため、
　常に先頭にプロトタイプ宣言、そのあとに実装部を記述、という状態になるかと思われる。
　あるファイルの内部でしか使わない関数はヘッダファイルを必要としないため、関数プロトタイプを置かずに
　放置する時もあるだろうが、それはやめた方が良い。

・名前のない名前空間、無名名前空間を作ると、内部リンケージと似たようなものになる。この場合、関数だけではなくあらゆる識別子に対しても
　同様の効果が得られる。そのため、内部リンケージを利用するよりは無名名前空間を利用した方が応用範囲は広くなる。
　内部的にはソースファイルごとに異なる名前空間が自動的に作られている。しかし、実際にこの名前を使用する際には名前空間は指定しない。
　無名名前空間を書いた場所を含む名前空間内にあるかのように使うことができる。

・関数テンプレートとは、型をはっきり決めずに作った関数のようなもののこと。これを利用すると、引数の型は違うが、
　引数の個数と処理内容が全く同じの関数が複数ある場合に、それらをまとめることができる。関数テンプレートを利用した場合、
　戻り値の方は引数と同じ型になるのでその点に注意する。

・関数テンプレートにしたい場合は、はっきりとしない型を利用する関数の戻り値の型の前に template <typename 型名> を記述する必要がある。

・template <typename 型名> に記述する型名のことを「テンプレート引数」と呼ぶ。仮引数に相当するので「テンプレート仮引数」ともいう。
　テンプレート引数は別に1つである必要は無く、必要であれば2つ以上作っても良い。例えば、引数にint型の引数2つを取る関数と、int型とdouble型の
　引数2つを取る関数の処理内容が全く同じだった場合、テンプレートが1つだけだと後者の関数がintかdoubleどちらかしか使えないが、テンプレートを
　複数作成しておけば、テンプレート引数同士は同じ型であっても別の型であっても構わないため、引数同士の型が違っていても問題が無い。

・templateは関数テンプレートを利用したい関数の型名の前にtemplateで都度宣言する必要がある。

・関数テンプレートは、例えばAbs関数で関数テンプレートを利用した場合、Absの引数にint型の値を渡すとint Abs(int)であるかのように呼ばれるが、
　この表現は不正確で、正確にはint Abs(int)という関数が自動的に作られて、それが呼ばれる、といった形となる。つまり、int Abs(int)やdouble Abs(double)
　をいちいち定義していた時と、関数テンプレートを使った時とでは、動作的には全く同じになる。ただし、関数テンプレートにはその定義を1つにまとめることが
　できるという大きな利点がある。逆に言えば、1回も使わなければAbsという関数はどこにも存在しないことになる。Absという関数テンプレートを定義したが、
　あくまでもそれは「鋳型」の定義となる。実際に使う関数はこの鋳型を使って「鋳造」する。この「鋳造」することを「実体化(インスタンス化)」と言い、
　作られた関数を「実体(インスタンス)」という。

・関数テンプレートを利用して関数を実体化するには呼び出したところからその実装が見える必要がある。つまり、関数テンプレートは宣言と実装をヘッダファイルと
　ソースファイルに分離して書くことはできず、全てヘッダファイルで実装する必要がある。(正確に言えばTYPEが同じである関数テンプレートの呼び出しの内どれか1か所で
　関数テンプレートの実装が見えてさえいれば十分だが、むしろそういう風にする方が難しい)

・テンプレートを使うと型ごとに別の実体が作られる。これはアップキャストを利用した関数とは大きく異なる性質となる。例えば、第7.4節で作ったOverride2.cppの
　Average関数で考えてみると、この関数にはStreamクラスを基底クラスとするクラスのオブジェクトならなんでも渡すことができる。
　しかし、Average関数の実体は1つしかない。InputStreamクラスのオブジェクトを渡そうが、ArrayStreamクラスのオブジェクトを渡そうが、全く同じ1つの関数が使われる。
　InputStreamクラス用のAverage関数やArrayStreamクラス用のAverage関数が作られるわけではない。これがアップキャストを利用した関数と関数テンプレートの
　大きな違いとなる。

　テンプレートは書かれた処理が実行可能でありさえすればどんな型でも受け入れることができる。その代わり、型ごとに実体が作られ、どの呼び出しでどの実体が呼ばれるかは
　静的に決定される。当然実行ファイルのサイズは実体が作られるごとに増加する。
　一方、アップキャストを利用した関数の場合は、ある基底クラス、あるいはそこから派生したクラスのオブジェクトしか引数に取ることができない。その代わり関数の実体は
　1つで済むし、どの呼び出しでどの型のオブジェクトに対する動作が行われるかを動的に決定できる。ただ、その処理の異なる部分がどんなに単純でも仮想関数にしなければならず、
　それは最適化でインライン化することもできない。

・結果的にテンプレートはファイルサイズや動的な処理の切り替えを犠牲にすることで高速に動作し、継承は速度を犠牲にすることでファイルサイズが小さくなり
　動的な処理の切り替えを行うことができるようになる。テンプレートと継承はその性質の違いから適用領域が若干違うが、そのどちらでも使用できるという状況もある。
　その場合、基本的には継承を使うべきだとは思うが、テンプレートの方が使い勝手委が良い場合や実行速度が気になる場合にはテンプレートを利用するとよい場合もある。

・関数テンプレートでTYPE自動的に決められないとき、あるいは自動的めてほしくない時のためにTYPEを自分で指定することができる。
　それには、FillArray<double>(d, SIZE, 0); のように関数テンプレート名の後に<>をつけて、関数に引数を渡すときと同じような感じでテンプレート引数を指定する。
　指定したいテンプレート引数が複数ある場合も、Show<double, int>(2, '0'); のようにテンプレート引数の先頭から順に指定していく。

・テンプレート引数にはクラスの型も指定することができる。ここからわかるように、そこに書かれている処理が実行できるのであれば、TYPEは基本型に限らず
　どんな型にでもなれる。逆に言えば、そこに書かれている処理が実行できない場合はコンパイルエラーとなる。

・クラスのテンプレートも作ることができる。クラスのテンプレートを「クラステンプレート」と呼ぶ。

・クラステンプレートでは、クラス宣言の前と各メンバ関数の実装の前の全てにつける必要がある。

・クラステンプレートでは、基本的にテンプレート引数を明示的に指定する。例えば、intを指定した場合ではクラスでTYPEとなっている箇所が
　全てintに置き換わったオブジェクトが作成される。

・クラス名を書く部分にもArray<TYPE>::Get() {}のようにTYPEがついている理由としては、クラステンプレートとは、ただの鋳型であって
　「クラス」ではないから。クラステンプレートはテンプレート引数を伴って初めて「クラス」になる。

・クラステンプレートのテンプレート引数では、デフォルト引数にすることができる。その場合、最初の宣言時に = で代入する形となる。
　しかし、<>は省略できないので注意する。これに対し、関数テンプレートではデフォルト引数を取ることができないので注意。

・テンプレート引数の閉じかっこである > を2つつなげて >> のようにしてしまうと>>演算子だとみなされてコンパイルエラーが出てしまうので注意する。

・vectorは動的配列を便利に扱うためのクラステンプレート。基本的に1つのテンプレート引数を取る(第二引数もあるがデフォルト引数がある)
　コンストラクタに1つの数値を渡すとそのサイズの配列が作られる。つまり vector<int> v(10); とした場合はint型10要素の配列が
　動的に作られることになる。さらにvectorにはresizeという便利な機能がある。resizeメンバ関数を使えば後から配列のサイズを変更することができる。

・vectorのテンプレート引数としてboolを指定した場合には、bool型の配列ではなくビット配列として扱われる。

・gotoは関数内の指定した位置に移動する命令。移動位置の設定は ラベル名: のように識別子の後に:を書くことで行う。
　この識別子のことを「ラベル」と呼ぶ。エラー処理を比較的簡単に1か所にまとめることができたり、多重ループを一気に抜ける場合にも使える。
　なお、ラベルの後には必ず何らかの文が必要となるため、そのあとに文が必要ない場合でも、少なくともセミコロンだけ記述しておく必要がある。

・エラー処理をラベルでまとめた場合、正常終了した場合に表示される必要が無いので、正常終了のreturnの後に記述する。

・goto文は初期化を伴う変数宣言を飛び越えることができない。

・goto文はエラー処理と多重ループの脱出に大きな力を発揮する半面、危険な面もたくさんあるためその2つ以外の状況では
　goto文は使ってはならない。if文とgoto文があればwhile,do-while,break,continueなど全ての制御文が大体再現でき、
　それらで表現できないような奇妙な、あるいは危険な処理も記述できる。そのため、goto文を好き勝手使ってしまうとどういう処理なのか訳が分からなくなったり、
　妙なバグを仕込んでしまったりといったことが起こってしまう。

　goto文を使うのはgoto文を使ったほうがきれいで簡潔に処理を記述できる、goto文を使っても処理の流れが一目でわかる、goto文を使っても危険性が無い、
　などといった条件が満たされている場合に限るべき。そしてこれらの条件が満たされる状況はエラー処理と多重ループのbreakあるいはcontinueとなる。

・「例外」というのはその名の通り、例外的な状況に陥った際に力を発揮するエラー処理のために作られた機能。

・throw式は「例外」というものを発生させるための式。この例外というものがtryブロック内で発生するとcatch節に飛ぶ。

・例外は関数を越えて投げることができる。具体的には、main関数内のtryブロック内で呼び出された関数にcatch節が無かった場合、そのまま関数を抜けて
　tryブロックが見つかるまでどんどん関数を抜けていく。そして、そのtryブロックに対応するcatch節で例外がキャッチされる。ただ、tryブロックがあった場合でも
　投げられた値の型に対応するcatch節が無ければ更に関数を抜けていく。正確に言うと、「投げられた値の型に対応するcatch節を持つtryブロックが見つかるまで関数を抜ける」
　といった動作になる。この処理を「スタック巻き戻し」という。

・tryブロックを探して関数を抜けていく際には通常自動変数のデストラクタはきちんと呼ばれるが、最後まで例外がキャッチされなかった場合は
　デストラクタが呼ばれない可能性がある。もしデストラクタが呼ばれないと困るような処理がある場合には、例外のキャッチ漏れが無いように注意する。

・catch節は複数書くことができ、投げられた例外の型と対応するcatch節のみが反応する。また、catch(…)と書けば、まだキャッチされていない残りのあらゆる例外を
　キャッチすることができる。

・catch節からthrowで例外を投げる場合、例外はそのtry-catchの外にあるcatch節でキャッチされる。しかし、そのcatch節内で処理を完結させたい場合は、
　そのcatch節内にまたtry-catchを作るようにすればよい。

・「例外が発生したことを外に知らせたいけど、現在の関数内においても終了処理が必要だ」といった場合に、基本的にはデストラクタ頼りにすべきだが、
　一旦関数内で例外をキャッチしておいてから、そのcatch節内から同じ例外を投げることになる。このような場合を想定して、キャッチした例外と
　全く同じ例外を投げる時にはthrow; のようにthrowに値をしていせずに記述する。これで今処理している例外と同じ例外を投げることができる。
　これを「例外の再送出」という。この場合、投げられてきた例外の値を直接使わなくても同じ例外を投げられるためcatch(...)でも同じ例外を投げられる。
　こうしておけば、想定していなかった例外が発生した場合でもメモリをきちんと開放することができる。そしてそれがどんな例外であったとしても
　再送出することができる。ただ、想定していなかった例外に対応するためには、基本的にはデストラクタを実行しさえすれば終了処理が完了するように
　しておけば十分となる。

　意図しない例外が発生した場合に備えるには、何らかの終了処理が必要な場合はそれがデストラクタで実行されるような形にプログラムを組むことが大切。

・クラスを使って例外を投げる場合には通常 throw コンストラクタ名(コンストラクタの引数); という形にする。もっと深い文法的な意味もあるがその解説は後。
　とにかくこうすればFileExceptionクラスのオブジェクトが作られ、そのオブジェクトを伴った例外が投げられる。
　あるいは、FileException e("ファイルから読み込めませんでした！"); → throw e; といったような例外をキャッチするには普通は以下のように参照で受ける。
　catch(const FileException& e) { cerr << e.What() << endl; → return EXIT_FAILURE;}
　参照にしなくてもキャッチで気はするが、普通は参照にする。普通の変数にすると値渡しになってしまいコピーが発生してしまう。

・クラスの例外を投げた場合、投げる際に使ったオブジェクトは関数を抜ける際に寿命が尽きてしまう。それなのに参照で受けるのは危険に思うかもしれないが
　実際には例外を投げる際にどこか別の場所にオブジェクトのコピーが作られ、catch節における参照はそのどこかに作られたオブジェクトへの参照になる。
　どこかがどこなのかは特に気にする必要はないが、このオブジェクトはcatch節を抜けると寿命が尽きるため気を付ける。

・例外で基本型を使ってしまうと、その例外がどんな種類の例外なのかが全くわからない。それに対し、クラスを使えばどんな例外なのかが非常にわかりやすく
　なることに加え、catch節を例外の種類によって分けることが可能となる。そのため、普通は基本型の例外を投げることはない。必ず何らかのクラスの例外を投げる
　ようにした方が良い。

・共通の基底クラスへの参照で例外を受けることができる。つまり、例外のキャッチにおいてもアップキャストが有効となる。
　そして、アップキャストを利用するためには必ず例外を参照で受ける必要がある。これがクラス型の例外を参照で受ける理由の1つとなっている。p503

・上記から、ある例外が複数のcatch節でキャッチ可能なことがある。例えば、FileExceptionクラスの例外はそのままcatch(const FileException&)でも、
　基底クラスのExceptionを使ったcatch(const Exception&)でもキャッチできる。その2つのcatch節が同時に存在する場合は、先に書いてあるcatch節のみが
　実行されるため、catch(const Exception&)を先に書いてしまうとcatch(const FileException&)はどんな例外にも反応できなくなってしまう。
　そのため、catch節の順番には十分気を付けた方が良い。

　最基底クラスへの参照で例外を受けた場合、その最基底クラスから派生した全てのクラスの例外をキャッチすることができるが、
　これはなるべくしないほうがよい。例外にはいろいろな種類があるにもかかわらず、その種類を全く無視してしまうことになるため。
　基本的に例外は「どの例外が発生して、どの例外であればエラーからの復帰が可能で、どの例外はキャッチしないでおくか」
　といったことを考えながら処理するもの。そのため、なるべく基底クラスから離れたものを使うよう心掛けるようにする。

・例外はエラー処理以外に使うべきでない理由として2つある。1つめに、try,catch,throwと書いてあると普通は「何かエラー処理をしているのかな」となるため。
　2つ目は、例外は非常に遅い処理のため。

・例外の中には演算子や標準で用意されているクラスのメンバ関数などによって投げられる例外もある。例えば、new演算子はメモリの確保に失敗すると
　bad_allocクラスの例外を投げ、vectorクラスのatメンバ関数はインデックスの値がおかしいとout_of_rangeクラスの例外を投げる。
　これらの例外クラスは全て、ある1つの最基底クラスであるexceptionクラスから派生している。また、exceptionクラスから派生していない
　クラスの例外、あるいは基本型の例外は、自分で投げない限りは投げられない。

・関数宣言の最後に throw(例外型リスト)と書くと、その関数がその方の例外しか投げないことを宣言できる。これを「例外指定」という。
　何も指定しなかった場合は、「その関数は例外を投げない」と宣言することになる。

・標準例外クラスは以下の3種類に分類される。

　　処理を実行する前に検出可能なエラーを表す例外クラス(基底クラスはlogic_error)

　　処理の実行時に検出可能なエラーを表す例外クラス(基底クラスはruntime_error)

　　言語的に投げられる例外クラス(基底クラスはexceptionで、クラス名の先頭にはbad_という接頭辞がついている)

　また、exceptionはexceptionヘッダファイルに、logic_errorとruntime_errorとその派生クラスはstdexceptヘッダファイルに宣言されている。p507

・コンストラクタ内から例外が投げられた場合、基底クラスやメンバ変数のデストラクタは呼ばれるものの、そのクラスのデストラクタは呼ばれない。
　そのクラスのコンストラクト(構築)に失敗しているため、デストラクタが呼ばれないのも納得がいくかと思われる。コンストラクタ内でメモリの確保を
　行っていた場合などにこの現象が起こると、メモリリークを起こしてしまう可能性があるため、十分注意する。

・コンストラクタにおいて、メンバ初期化子でメンバ変数を初期化するようにしていた場合、メンバ初期化子でも例外が投げられる可能性がある。
　この場合もクラスのデストラクタは呼ばれず、まだ初期化されていないメンバ変数のデストラクタも呼ばれないが、既に初期化されてるメンバ変数の
　デストラクタは呼ばれる。まとめると、「コンストラクタの呼び出しが完了したもののデストラクタは呼ばれ、コンストラクタの呼び出しが
　完了していないもののデストラクタは呼ばれない」となる。

　また、メンバ初期化子で例外が起きた場合は初期化し終わっていないメンバ変数が存在するという点に注目すると、少なくとも例外を投げたメンバ変数は
　確実に構築に失敗する。どのようにエラー復帰しようとも、このオブジェクトの構築には必ず失敗することが分かる。そのため、メンバ初期化子で
　例外が投げられた場合はどうやっても完全にエラーから復帰することはできず、必ずコンストラクタの外へと例外が投げられることになる。

・例外クラスのコンストラクタが例外を投げてしまう場合、実際に投げられる例外は実際に投げようとした例外クラスではなく、そのコンストラクタ内で
　投げられた例外になる。これは、実際に投げようとした例外クラスの構築に失敗していることからも常識的な挙動であるとわかるかと思われる。
　ただ、この挙動は紛らわしいため、例外クラスのコンストラクタは例外を投げるべきではない。そのため、exceptionクラスのコンストラクタには
　「何も例外を投げない」という例外指定が行われている。

・デストラクタ内で例外が投げられた場合、例えばFooというクラスのデストラクタで例外が投げられるとした場合、
　　try {
        Foo foo;
        throw exception();
    } catch(...) {
    }

　とすると、まずexceptionクラスの例外が投げられる。ここでfooの寿命が尽きるため、fooのデストラクタが呼ばれる。
　すると、例外が投げられている最中にまた例外が投げられることになる。この場合、例外が処理されないままterminate関数が呼ばれ、
　そのまま異常終了することになっている。これを「二重例外」ということもある。他にも、deleteしようとしたときに例外が発生すると
　オブジェクトが解体されたにもかかわらずメモリは解放されないという事態に陥ってしまうなど色々な問題が考えられる。

　上記から、デストラクタでは例外を外には投げないことが推奨されている。デストラクタ内では例外が起こるような操作は行うべきではなく、
　また例外が発生する場合にもきちんとデストラクタ内で例外を処理するようにする。

・関数tryブロックを使用すると、初期化子などから投げられた例外をコンストラクタで一旦キャッチすることができる。この場合、
　明示的にthrow;と書かなくても例外が自動的に再送出される。どうあっても例外が投げられるということになる。関数tryブロックは
　コンストラクタ以外の関数でも書けるが、その場合はデストラクタを除いて例外の再送出は行われない。

・メンバ変数にstaticを付けた場合、クラスの実装部でメンバ変数の実体を作る必要がある。メンバ変数の実体を作るには
　int Integer::m_value; のように「型 クラス名::変数名;」のように変数宣言を行う。実体の定義を行う方にはstaticは付けないという点に注意する。

・staticを付けたメンバ変数は実体を1つしか持たない。そのため、例えば、m_valueに引数の整数を入れて初期化するといったコンストラクタの場合、
　a(100),b(300)としても、m_valueにstaticをつけると実体が1つしか存在しないため、100に300が上書きされてaでもbでも300としか表示されない。
　このようなメンバ変数を「静的メンバ変数」という。

　静的メンバ変数はそのクラスの実体ごとに変数が作られるのではなく、そのクラスの全ての実体で共有される。

・クラスの宣言はあくまで型の宣言でしかないが、この静的メンバ変数に関しては少し例外的であるといえる。C++のクラス自身はオブジェクトではないが、
　そのスコープ内には静的メンバ変数という形で変数を持つことができる。基本的にクラスは、オブジェクトごとにそのクラスの
　メンバ変数などを実体として持つため自身は何も持たない鋳型のようなものだが、静的メンバ変数に関してはクラス自身が持つことのできる変数となっている。

・静的メンバ変数は静的変数であるため、メンバ変数でありながらデフォルト引数に指定することができる。

・静的メンバ変数は実体が1つしか存在しないため、クラスのモジュール性(プログラムの部品として色々なところで使えるという性質)を大きく低下させてしまう。
　クラスの実体を2つ以上作っても作業領域が共有されてしまうため。この性質から、静的メンバ変数は使いどころがかなり制限される。
　しかし、中には逆に共有されていないと困る作業領域というのも存在する。例えば、あるクラスの実体の数を数えておきたい場合を考えてみると、
　この場合、クラスの数をカウントする変数m_countを普通のメンバ変数にしてしまうと、クラスの実体を作るたびに全ての実体のm_countを
　変更してやる必要が出てきてしまう。これは無駄が多いというレベルではなく、どうやってすべての実体のm_countを変更すればいいのかという問題まで発生する。
　ところが、m_countを静的にすれば、実体を作るときにm_countを増やし、実体を破棄する時にm_countを減らせばいいだけなのでこれを簡単に解決することができる。
　このように、静的メンバ変数はプログラムを通して共有されるべきもの、言い替えればプログラムを通して1つしか存在してほしくない者がある場合に使われる。

・静的メンバ変数を好きな値で初期化するには、その実態定義のところで int Count::m_count = 10; のようにすればよい。

・静的変数の初期化のタイミングは、静的メンバ変数を含む、ローカルでない静的変数はmain関数が実行される前に初期化される。複数のローカルでない
　静的変数間の初期化順は、実態定義の書かれた順と同じとなる。ただ、異なるファイルにある性的変数との間の初期化順は特に決まっていない点には注意する。
　これに対し、静的ローカル変数の初期化のタイミングは基本的には初めて関数が呼ばれたとき。初期化のタイミングが動作に影響しない場合はその限りではないが、
　例えばコンストラクタやデストラクタがある場合は、初めて関数が呼ばれた時にのみコンストラクタが呼ばれ、main関数が終了した後にデストラクタが呼ばれる。
　その場合、一度も関数が呼ばれなければコンストラクタは呼ばれず、デストラクタも呼ばれない。

・静的メンバ変数は派生クラスでも同じメモリ領域を使う。

・メンバ関数にstaticをつけると「静的メンバ関数」となる。静的メンバ関数は、実体がなくても呼べるメンバ関数。
　静的メンバ関数を呼ぶには Count::Show(); のようにクラス名::をメンバ関数名の前につける。実体を使ってa.Show();の形で呼ぶこともできるが、
　まるで静的でないメンバ関数のようにめいてしまい紛らわしいのでやらない方が良い。静的メンバ関数は実体がなくても呼べる代わりに、
　明示的に何らかの実体を通さずに静的でないメンバにアクセスすることはできない。もちろん、引数などを通して実体が渡された場合などには
　その実体の静的でないメンバにアクセスすることは可能。

・静的でないメンバ関数はそれを呼ぶときに使ったクラスの実体のアドレスが渡される。しかし、静的メンバ関数を呼ぶときには実体のアドレスが渡されない。
　なぜなら、実体がなくても呼べるから。これが普通のメンバ関数と静的メンバ関数の大きな違いとなる。静的メンバ関数にはそれを呼ぶときに使った実体のアドレスが
　渡されないため、静的メンバ関数内では当然静的メンバ変数と静的メンバ関数しか使えない。

・あるクラスのオブジェクトがプログラムを通して1つしか存在してほしくないという場合がある。このような場合、コンストラクタをprivateにしてしまい、
　その唯一の実体をクラス内で生成して、その唯一の実体を静的メンバ関数を通して返すようにすると、それ以上の実体を作られてしまう危険性が無くなる。
　このように管理されるクラスのことを「シングルトンクラス」という。シングルトンクラスは様々な問題があるが、
　比較的安全なグローバル変数のような間隔で使うことができるため、余裕があれば調べておいて損はない。

・普通のメンバ変数では配列のサイズ指定には使えない。配列のサイズ指定にはコンパイル時に値の決まる(静的な)定数しか指定できないため。
　普通のメンバ変数はクラスの実体ごとに別の値を取る可能性があり、明らかにサイズ指定に使えないことがわかる。
　かと言って、定数をクラス外で宣言するのも違和感がある。

　こういった場合、「静的メンバ定数」というものを使うことでこの問題を解決することができる。
　静的メンバ変数はconstをつけた静的メンバ変数のこと。静的なので実体は1つしかなく、
　定数であればコンパイル時に値が一意に決まる。

・静的メンバ定数を宣言しているところで初期化するようにすれば、配列のサイズ指定に使用できるメンバ変数を作成することができる。
　また、このように初期化した場合、変数の実体も同時に作られる。そのため、後でまた変数の実体を定義してやる必要はない。
　なお、このような形の初期化は静的メンバ定数でしか行えない。たとえ静的メンバ変数であっても、定数でなければ別途実体を定義し、
　そこで初期化する必要があるまた、型は整数型でなくてはいけない。整数以外の性的メンバ定数はこの形では初期化できない。
　とはいえ、整数型以外ではクラス宣言内で初期化しなくてはいけない状況もないため、これが問題になることは特にないと思われる。

・constの付いた変数へは「代入」することはできず「初期化」することしかできない。それはメンバ変数にconstを付けた場合も同様となり、
　コンストラクタのメンバ初期化子で初期化することはできるが、一切代入することはできなくなる。

・クラスの例外を投げる時、throw コンストラクタ名() のようにコンストラクタを呼ぶような感じで行ったが、これは例外を投げる
　時専用の特殊な文法ではなく、それ以外の場合でも使える文法となる。例えば、strの型をstringとすると、次のようにすることができる。
　str = string("hoge); これはstringクラスのオブジェクトを作り、それをstrに代入しているように見える。これは事実そうであり、
　クラス名(実引数リスト) とすると、「一時的に」クラス名で示されるクラスのオブジェクトを作ることができる。このように一時的に
　作られたオブジェクトのことを「テンポラリオブジェクト」という。なお、コンストラクタの引数が1つの場合は次のようにキャストの形で書くこともできる。
　str = (string)"hoge";

・テンポラリオブジェクトの寿命はテンポラリオブジェクトを作成した文の中だけで、その文を抜けるとテンポラリオブジェクトは破棄されてしまう。

・初期化の際に string str = string("hoge"); とすると、テンポラリオブジェクトを作って、その後コピーコンストラクタによりstrが初期化される
　ように見えるかと思われるが、実際にそういう動作になることもあれば、そうならないこともある。テンポラリオブジェクトを作らずに、
　strが文字列を引数に取るコンストラクタで直接初期化されるよう最適化されることがある。これは例外を投げる時も同様で、throw exception();
　とした場合、テンポラリオブジェクトを作ってそれをコピーするかもしれないし、コピーが発生しない場合に最適化されるかもしれない。
　ただ、たとえ最適化によりコピーコンストラクタの呼び出しが省略されるとしても、文法はコピーコンストラクタが呼ばれることを前提としてチェックされる。
　つまり、コピーコンストラクタがprotectedやprivateだった場合には(そのクラスのメンバ関数内などでない限り)コンパイルエラーとなってしまうので注意。

　なお、もし変数strの初期化時にテンポラリオブジェクトを作るようになっていた場合、そのテンポラリオブジェクトの寿命はその文の最後までではなく
　strの初期化が終了した時点となる。

・クラスのオブジェクトを返す関数の戻り値はテンポラリオブジェクトとなる。p537

・int Abs(const int& a) という関数があった場合に、int n = -10; → Abs(n) とすると、aはnへのconst参照となる。
　しかし、次のようにすることもできる。Abs(-10) ここでは、Abs関数に直接-10という生の値(即値)を渡しており、それでもちゃんと動作する。
　このように、const参照は変数でない値ででも初期化できる。その場合、一旦テンポラリオブジェクトが作られ、aはそのテンポラリオブジェクトへの参照となる。

・const参照のメリットは、引数を値で渡すのと同様の機能を提供するが、メモリが大きな型の効率が向上する。理由としては、関数のパラメータを値で渡すと、
　そのパラメータの値は「コピー」される。もしパラメータのデータが大きな複合型で構成されている場合、コピーするサイズも大きくなるためより大きな
　オーバーヘッドが発生する可能性がある。このような使い方をすると、アプリケーションの動作が遅くなったり、パフォーマンスを大幅に低下させる原因となる。
　そこで、&演算子を使用してパラメータをコピーで渡すのではなく参照するようにすれば、このコピーを完全に回避することができる。しかし、こういった & を
　引数に持つ関数は、一般的には「渡された引数を変更する関数」と認識されており、そのために参照パラメータが使われている。そこで、関数の参照パラメータが
　変更されないようにconstをつければ、参照先が変更されることなく、かつ値のコピーではなく直接参照になるため効率が良くなる、といった仕組みがconst参照となる。

・このテンポラリオブジェクトを参照に取る形を利用すると、例えば9.1節の関数テンプレートを
　template <typename TYPE>
　　TYPE Abs(const TYPE& a)
　{
    reurn a < 0 ? -a : a;
　}

　とすることができる。こうすれば引数が参照渡しになり、TYPEがクラスの場合のコピーが発生せずに済むうえに、TYPEが基本型の時に即値を渡すこともできる。

・なお、次のように引数でなくともconst参照をテンポラリオブジェクトで初期化することができる。

　　int main() {
        const int& n = 1;
        const Hoge& hooge = Hoge(n);
        Viss(1);
    }

　この場合は例外として、テンポラリオブジェクトの寿命がそのconst参照の寿命と等しくなる。
　基本型に使うことはないかもしれないが、例えばクラスのオブジェクトを直接(参照でない形で)返す関数の戻り値を受ける時などに利用できる。

・戻り値のコピーは代入演算子ではなくコピーコンストラクタで行われる。ただ、戻り値を作るときに必ずコピーが発生するとは限らない。
　実際にはコピーのコストを減らすために「戻り値最適化」が行われる可能性があるため。このため、必ずコピーが発生することを期待した、
　あるいは必ずコピーが発生しないことを期待したプログラムは書かない方が無難となる。ただ、どちらにしろ戻り値が
　テンポラリオブジェクトになることに変わりはない。

・あるものを使いやすくするために作るクラスや関数をよく「ラッパクラス」や「ラッパ関数」と呼ぶ。生の値や関数などを包装紙(wrapper)に包んで隠し、
　代わりに便利な操作を提供するという感じ。例えば、IntArrayクラスはint型の配列を便利に扱うためのクラスなのでこれもラッパクラスとなる。

・参照は、「元のオブジェクトそのもの」「元のオブジェクトの別名」と考えてよい。変数宣言時に&をつけると参照変数の宣言となる。
　例えば、int& ref = num; とした場合、参照変数refを通して変数numを直接書き換えることができる。このように、参照を正しく宣言するには、
　宣言と同時に他のオブジェクトのアドレスで初期化する必要がある。参照とポインタの違いとしては、ポインタはメモリ上の位置を示すもので、
　ポインタが指す先には必ずしも何か(意味のある)データが存在することは保障されていない。宣言と同時に初期化をしなければどこを指しているかは不定。
　ポインタ変数に意味のないアドレスを渡すこともでき、NULLポインタのように「何も指していない」ポインタを作ることもできる。
　それに対し、参照は必ずオブジェクトを指していることが求められる。ポインタ変数のようにNULLポインタや意味の無いアドレスを渡すことはできず、
　ポインタ演算で指し示す先が変わることもない。参照はポインタ演算によって別のオブジェクトを指すように変更はできない。
　それどころか、代入で別のオブジェクトを指すように変更することもできない。このように参照は特定のオブジェクトと強く結びついていることが分かる。

・[]演算子がオーバーロードされていた場合、v.[i]はv.operator[](i)へと置き換えられる。例えば、cin >> v[i] は、cin >> v.operator[](i)
　であるとして実行される。p543

・上記のように、参照やアドレスを返す関数を作ればメンバ変数のメモリ領域を参照することができるようになる。ただ、これには気を付けなければならない点がある。
　1つ目には、メンバ変数をprivateにしている意味がなくなってしまう、あるいは薄れてしまう場合があるということ。一旦参照を取得できれば、後は好き放題
　値を変えることができる。2つ目には、変数の寿命に気を付ける必要があるということ。例えば、int& Hoge(int n) { return n; } といった関数がある場合、
　これはnへの参照を返す関数となっているが、このnは仮引数なのでその寿命は関数を抜けるまでとなっている。しかし int& ref = Hoge(1); のとすると、
　その「死んだ」変数nへの参照を取得することができてしまう。

　このように、参照やアドレスを返す関数を作る際には死んだ変数への参照や死んだ変数へのポインタを返さないように十分注意する。p545

・変数 代入演算子 値 という代入式があった場合、まず一旦代入(あるいは足しこみなど)が行われてから、その後 変数 の代わりとして使えるようになるということが分かる。
　複数の変数に同じ値を代入したい場合、a = b = 5; のようにできる。=演算子の結合法則は(a = b) = 5; ではなく、a = (b = 5); になる。
　このように、代入式をつないだ場合は右から順に処理されていく。このようにしてaとbに同じ値が代入されていく。

・インクリメントとデクリメントには ++i と i++ の2種類の書き方があるが、++を前に付けた場合は先にインクリメントをする。つまり、a = (++b); とした場合、
　先にインクリメントを行うため b += 1; → a = b; と同じことになる。このインクリメントを「前置インクリメント」という。一方、++を後ろにつけた場合は
　後でインクリメントする。つまり、a = (b++); とした場合、a = b; → b += 1; と同じことになる。このインクリメントを「後置インクリメント」という。
　前置、後置どちらがどの動作になるかは見た目から何となく判断できるようになっている。前に置かれていれば先に、後ろに置かれていれば後でインクリメントする。
　もちろん、デクリメントでも同様となる。

　そして、この性質のために後置インクリメント式や後置デクリメント式には代入演算を行えない。例えば、(b++) = 1; はコンパイルエラーとなる。後置インクリメント式と
　後置デクリメント式は代入式の中でも特殊であることが分かる。

・実体を参照する値のことを「左辺値」と、それ以外の値のことを「右辺値」という。非constな配列全体や、関数でない左辺値には代入を行うことができ、
　その時左辺に来るので左辺値と呼ぶ。左辺値に&をつけるとそのアドレスを取得することができる。例えば、生の変数、関数、参照、ポインタに*や[]をつけて
　(脱参照して)得られるものは左辺値となる。aやbという変数は左辺値だが、a + bという計算式の返す値は右辺値となる。また、関数の返す参照でない値は右辺値。
　(b = 1) += a という式をプログラム内で挙げたが、+= aという複合代入演算が可能なことからわかるように、この(b = 1)という代入式は左辺値となる。
　このように、代入式の「演算結果」はその左辺値そのものになる。b = 1の演算結果は、bを参照する左辺値になる。

・constメンバ関数にすると、オブジェクトが持つメンバ変数の値を変更する予定のないデータの読み込み専用の関数などでメンバ変数を変更できないようにすることができ、
　思わぬ変更によるデータの整合性の損傷を避けることができる。

・分子/分母を取得したいと思った時、Getメンバ関数を用意することもできるが、n = f.Get()のようにいちいちGetメンバ関数を呼ぶのも少々面倒。n = f;のように書けると便利。
　この方法にするには少し変わった方法が必要になる。それは「キャスト演算子のオーバーロード」となる。例えば、Tという型へのキャスト演算子(T)をオーバーロードするには
　operator T(); というプロトタイプの関数を作る。戻り値の型は当然Tになるため、戻り値の型を自分で書かなくても良いようになっている。

・「this」はメンバ関数を呼ぶのに使ったオブジェクトのアドレスを持つポインタ。つまり、*thisとすればメンバ関数を呼ぶのに使ったオブジェクトを指し示すことができる。

・インクリメント演算子をオーバーロードするには、前置と後置を区別するために後置インクリメント演算子をオーバーロードする際にはint型のダミーの引数を指定することになっている。
　これは後置デクリメント演算子でも同様となる。

・後置インクリメントでは足しこむ前の値を返す必要がある。足しこむ前の値を一旦保存しておいてから足しこんで、それから保存しておいた値を返すことになる。
　このため、後置インクリメントの戻り値は参照にすることができない。自動変数への参照を返してはいけないため。また、足しこむ前の値をコピーする必要があるため、
　後置インクリメントは一般的に前置インクリメントより効率が悪くなる可能性がある。基本型の場合は最近のコンパイラであれば最適化され、問題にはならないが
　演算子がオーバーロードされている場合には効率が悪くなる可能性がある。

・例えば、fをFraction型の、nをdouble型の変数とした場合、f * nではf.operator*(n)と解釈される。ただし、Fraction::operator*(double)が定義されておらず、
　Fraction::operator*(const Fraction&)しか定義されていなかった場合は、nがFraction型に暗黙にキャストされf.operator*((Fraction)n)であると解釈される。
　ここまでは特に問題はない。しかし、n * fとなった場合に左項の型はFractionではなくdoubleとなる。そのため、Fraction::operator*はここでは使われない。
　この場合はFraction(n) * fと自動的に解釈されたりはしない。その代わり、Fractionからdoubleへのキャスト演算子が定義されているため、fはdoubleへと暗黙にキャストされ、
　n * (double)f であると解釈されてしまう。この結果は当然double値であり、Fractionクラスのオブジェクトを返すことはない。f * nとn * fは当然同じ結果を与えるべきだが
　ここではそうはならなくなってしまう。

　この問題を解決するには、左項の型がdouble、右項の型がFractionである場合の乗算演算子をオーバーロードする必要がある。ただ、これは左項の型がFractionではないため
　Fractionクラスのメンバ関数にすることができない。ではどうすればいいかというと、メンバ関数にしなければいいだけ。つまり、クラス外で演算子をオーバーロードすればよい。
　その場合、左項も引数の中に入れて普通の関数として定義する。p556

・非メンバ関数として演算子をオーバーロードする際、クラスのメンバ変数に直接アクセスできた方が便利な場合がある。その場合、operator*の関数プロトタイプをそのクラスの
　宣言内でfriendというものを使って宣言すれば、operator*内でもクラスのprivateメンバ変数に直接アクセスできるようになる。このようにfriendつきで宣言された関数を
　そのクラスの「フレンド関数」と言う。フレンド関数のプロトタイプはクラス宣言内で宣言するが、そのクラスのメンバ関数になるわけではないという点に注意する。
　フレンド関数はあくまで非メンバ関数となる。なお、この形の演算子オーバーロードは=演算子に対しては使えない点に注意する。=演算子は必ずメンバ関数にする必要がある。

・暗黙のキャストが行われないようにするには、引数が1つのコンストラクタの宣言にexplicitをつける。なお、デフォルト引数のおかげで引数が1つで呼ぶこともできるコンストラクタにも
　explicitをつけることができる。暗黙のキャストは思わぬバグを引き起こしてしまう可能性もある。そのため、引数が1つになる可能性のあるコンストラクタがあれば、コピーコンストラクタを除いて
　とりあえずはexplicitをつけておいた方が無難。暗黙にキャストしても問題が無いとわかった時に初めてexplicitを外すようにする。

・キャストは今まで(int)や(int*)などとしてきたが、C++ではキャストを3種類に分類している。各特徴については以下の通り。

　　静的な普通の型変換 = signed char a = -1; → (unsigned char)a; のように明示的な型変換にキャストを使う。キャストとして一番普通の使い方で、比較的危険性の少ないキャスト。
　　　　　　　　　　　　 こういったキャストにはC++ではstatic_castという演算子を使うことができる。例えば上記のキャストはstatic_castを使うと
　　　　　　　　　　　　 static_cast<unsigned char>(a); となる。書式は static_cast<型>(値); となり、値の型が指定した方へと変換される。static_castは 型 tmp(値);
　　　　　　　　　　　　 という第一引数のコンストラクタを使って作られたオブジェクトtmpを使った場合と同じ結果を与える。static_castを使うとバグが表面化してくれる。

　　ポインタや参照の絡む強引なキャスト = int*からchar*へのキャストや、istream&からstring&へのキャスト、あるいはint*からintへのキャストなどのこと。こういったキャストは比較的危険。
　　　　　　　　　　　　　　　　　　　　 その結果は基本的に環境依存となる。このようなキャストが現れるのは、意図的に環境依存の処理を記述する場合か、あるいはタイプミスでうっかり*や
　　　　　　　　　　　　　　　　　　　　 &をつけてしまったという場合。ミスで偶然危険なキャストになったというのでは困るため、ポインタ型や参照型以外へのキャストに対して必ずstatic_cast
　　　　　　　　　　　　　　　　　　　　 使うようにすればミスで偶然危険なキャストになったとしてもコンパイルエラーとなってくれる。意図的にこのキャストを行いたい場合はreinterpret_cast
　　　　　　　　　　　　　　　　　　　　 というものを使う。

　　constを外すキャスト = void Hoge(const int* cp) { int* p = (int*)cp; ・・・} のようにconstを外すキャスト。constを外す必要性のある状況というのは非常に限られている。例えば
　　　　　　　　　　　　　void Hoge(int* p)という関数を誰かが作ったとする。pの型はint*にはなっているが、pの参照先は決して変更されないことが保証されているとする。こういう場合本来は
　　　　　　　　　　　　　const int*にすべきだが、constをつけ忘れていたとする。しかし、引数の型は非constなためconstポインタは渡せない。もし実装に手を加えることができるのであれば
　　　　　　　　　　　　　引数の型にconstをつければいいだけの話だが、ライブラリとしてのみ提供されている場合や、ライセンスの問題でソースを変更できない場合や、オブジェクトファイルは
　　　　　　　　　　　　　残っているけどソースが紛失した場合など、実装に手を加えられない状況というのも存在する。そのような場合であれば、const int*からint*へのキャストを行わざるを得ない。
　　　　　　　　　　　　　このキャストはstatic_castでもreinterpret_castでも行うことはできない。これにはconst_castというものを使う。

・C++特有のキャストは()を使ったキャストに比べ非常に冗長に見えるが、キャストというのは型を無理やり変更する処理であり、比較的危険な処理となる。そのため、キャストしたいと思った場合はまず
　「本当にキャストが必要なのか」ということを考える必要がある。冗長なキャストはまずキャストする気を失わせ、キャスト以外の解決法を考えようとする努力を促す効果があり、それによりキャストが
　危険な操作である意識も植え付けてくれる。さらにキャストしている部分が目立ち、「ここでは危険な処理を行っています」ということがわかりやすくなる。当然、キャストしてある部分を検索することもできる。
　これによりキャスト絡みのバグのデバッグが容易になる。

・2進数特有の演算には「ビット演算」というものがある。これにはAND,OR,XOR,NOT,そしてビットシフトの5種類があり、演算子オーバーロードされない限りは整数にしか使えない。

・ANDの演算子は & で、2項演算子となる。つまり、2つの値から1つの値を導き出す。計算例としては

　　0011
　&)0101
　-------
　　0001

　のように、上下のビットが両方とも1のところは1、それ以外は0となる。要するに、各桁ごとに独立して掛け算をすることとなる。これがAND演算子。このANDの挙動は条件判定の&&とよく似ており、
　&は&&と同じような演算を全てのビットに対して行う。

・ANDの利用法としては、以下の通り。

　　01111010 … A
　&)00001111 … B
　-----------
　　00001010 … C

　この計算を A & B = C と置く。要するにA = (01111010)2, B = (00001111)2, C = (00001010)2 とする。これを見ればわかる通り、Bで0であるビットはCでも全て0になっている。
　そして、Bで1であるビットはAのものがそのままCに現れている。要するに、BとANDをとることによりAの上位4ビットが0にされたことになる。あるいは、Aの下位4ビットが取り出されたといってもよい。
　つまり、取り出したいところのビットを1にした値とANDをとることによって、特定のビット取り出すことができる。これは逆に言えば、消したいところのビットを0にした値を使えば
　特定のビットを消せる、ということになる。要らないビットを0にして注目したいビットを取り出すというこの操作を「マスキング」と言い、マスキングに使われる値Bを「マスク」という。
　ANDはもっぱらこのマスキングに使われる。

・なお、NOTは例外として、ビット演算子はかなり優先順位が低い。例えば、a + b & c と書くと、(a + b)が先に計算される。特に問題となるのは、関係演算子よりも優先順位が低いという点。
　例えば a & b == c とすると、a & (b == c) と解釈されてしまう。この手のビット演算子の優先順位によるバグは見つけづらいため注意する。ビット演算子を使う時はとりあえずかっこをつけておくのが無難。

・ORの演算子は | で、やはり2項演算子となる。計算例としては

　　0011
　|)0101
　-------
　　0111

　のように、上下のビットが両方とも0のところは0、それ以外は1となる。どちらか一方が1でありさえすれば1になる、ともいえる。これがORとなる。条件判定の||とよく似ており、
　||と同じような演算を全てのビットに対して行う。つまり、1にしたいところのビットを1にした値とORをとることによって、特定のビットを1にすることができる。
　これは2つの値を合成できるとも言い換えることができる。ORはもっぱらこのビット合成に使われる。ANDとORを使うと、ビット単位で0と1の操作、そして判定ができる。これはビット演算の中でも最も重要な部分となる。

・XORの演算子は^で、やはり2項演算子。計算例としては以下の通り。

　　0011
　^)0101
　-------
　　0110

　上下のビットが同じところは0、それ以外は1となる。要するに、各桁ごとに独立して足し算をしたときの1桁目の値(？)になる。

・XORの利用法については以下の通り。

　　01111010 … A
　^)00001111 … B
　--------------
　　01110101 … C

　この計算を A ^ B = C と置く。これを見ればわかる通り、Bで1であるビットはCではAの逆になっている。そして、Bで0であるビットはAのものがそのままCに現れている。要するに、Aの下位4ビットの0と1が反転したということになる。
　つまり、反転したいところのビットを1にした値とXORをとることによって、特定のビットを反転することができる。XORはもっぱらこのビット反転に使われる。例えば、2人用のゲームでプレイヤーの切り替えを行う時などに便利。
　まずプレイヤーをplayerという変数で表し0をプレイヤー1、1をプレイヤー2とする。するとプレイヤーの切り替えは player ^= 1; でできる。これは結果だけを見れば player = 1 - player; と同じだが、
　XORを使った方が効率的になる可能性がある。もっともこれはプレイヤーが2人に限定されている場合にしか使えないが、この0と1の切り替えは他のいろいろな処理においても出てくることがあるため、覚えておいて損はない。

・NOTの演算子は ~ で、ビット演算子の中では唯一の単項演算子。つまり、1つの値から1つの値を導き出す。この辺は符号演算子とかと同じ。計算例としては以下の通り。

　~)01
　-----
　　10

　全ビットが反転されており、これがNOTとなる。

・NOTの利用法としては以下の通り。

　~)00011111
　----------
　　11100000

　1で指定されたところは0になり、それ以外の部分が1になっている。このように、NOTは特定のビット「以外」を1にしたい時に使う。このようにして得られた値とANDを取ることにより、次のようなことができる。

　　01111010 … A
　&)11100000 … B
　--------------
　　01100000 … C

　BがNOTで反転させた後の数。NOTする前は1であった箇所、つまり下位5ビットがすべて0になっている。このように、NOTはANDと組み合わせて特定のビットを0にするときによく使われる。
　これもマスキングの一種となる。もちろんNOT後の値を直接使えばAND単独でもできるが、NOTと組み合わせて使う方が便利でわかりやすいときもある。

・ビットシフトには右シフトと左シフトがある。それぞれ演算子は >> と << で、これらは2項演算子。計算例は以下の通り。

　　00010101　　　　00010101
　　>>)　　2　　　　<<)　　4
　　--------　　　　--------
　　00000101　　　　01010000

　その名の通り、ビットを右や左へとずらしている。その際、ビットのなくなってしまうところは0で埋められ、ビットの溢れてしまうところは切り捨てられてしまう。これがビットシフト。
　なお、負の数を右シフトする場合は特殊で、ビットのなくなってしまうところが1で埋められることがある。これを「算術シフト」と言う。これに対し、一番上を0で埋めるシフトのことを
　「論理シフト」という。

・複雑な演算の中には、ビット演算子を活用すると思いもよらないくらい単純で高速に行うことができるものもある。

・ビットフラグとは要するにbool値のようなもの。ある条件が満たされているかどうか、あるいはある設定がオンになっているかどうかなどといった状況を、0と1の数値で表現したもの。
　通常、0が不満足(設定オフ)、1が満足(設定オン)を表す。ビットフラグはbool値でも表現できるが、ビットフラグの数だけbool値の変数を用意する必要があるため、ビットフラグが非常に多い場合には
　効率が悪くなる。というのも、たった1ビットずつの情報のために数ビットのサイズを持つ変数をそれぞれに用意する必要があるから。

・インライン関数は呼び出しに時間がかからない。

・クラスの宣言部でメンバ関数を実装すると、inlineと書かなくてもインライン関数になってくれる。

・

================================================================================================================================

ミス履歴

・クラスで IntArray a; のようにコンストラクタの呼び出しをしていなかった、定義をしていなかった。

・


================================================================================================================================

わからないこと

・派生クラスの宣言内において 基底クラス名 メンバ変数名(オブジェクト名？)
　としている意味が分からない。推測ではもうここで基底クラスのオブジェクトを
　作成しているのだと思うが、本にはこれがメンバ変数と書いてある。オブジェクトなら本に書いてある
　初期化の文法も納得できる。

・p535 初期化時のテンポラリオブジェクトの挙動とコピーコンストラクタの関係性が何もわからない

・p540 戻り値について

・p558 非メンバ関数型の演算子オーバーロードを使用して自作のクラスをostreamへ直接出力、自作マニピュレータ

・

================================================================================================================================

やってみたいこと

・10進数から他の進数に値を変換するツールを作成する

・入力された値が素数かどうか判別するプログラムを作成する　✓
　それを親クラスとして入力された値を素因数分解するプログラムを作成する

・4 * 4の16マスの中から爆弾が隠れているマスを見つけるゲームを作る
　　1．16マスを表示して入力したマスに何か操作を行うプログラム
　　2．爆弾を埋め込んで各マスには爆弾までの距離を書く、
　　　 爆弾までの距離はマスを選択しないと見えない
　　3．爆弾がランダムに出現できるようにする

・

================================================================================================================================

発見

・

================================================================================================================================

気になったこと

・for文の外で変数を宣言するのと初期設定文で宣言するのだとやはり初期設定文の方が
　メモリの使用は少なくて済むのか？

・