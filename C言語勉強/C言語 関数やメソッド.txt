C言語 関数やメソッド

・scanf関数 = キーボードから入力する際に使用する関数。指定子を複数使うことで複数の入力を一度に行うことが可能。

　　scanf("入力変換指定子",&変数名);

　　　入力変換指定子 = 入力された数字をどのような数値に変換するかを表す文字のこと。
　　　　　　　　　　　 printf関数で使用する出力変換指定子とほぼ同じように使用できる。



・if文 = 指定された数値が0であるかそうでないかを判定し、真である(数値が0以外の)場合だけ横の分を実行する。
　　　　 そうでない場合、横の文は飛ばされてif文の後の文を実行する。
　　　　 C言語では、条件による判定を行う場合、0を偽の値、0以外を真の値と呼ぶ。

　　if (条件式) 文 ;

・switch文～case = 指定された条件式の値と同じ値のcaseまで処理の順番をジャンプし、ジャンプ先ではcase以下の文を実行し、
　　　　　　　　　　break文を見つけたらswitch文の後で囲っている{}の中から抜け出す。
　　　　　　　　　　break文を除いて複数のcaseを重ねて同じ処理を適用することもできるが、言い換えるとbreak文を忘れてしまうと
　　　　　　　　　　関係ないcase文が繋がってしまうため十分に注意する。

　　switch (条件式) {
    case 数値:
        実行文;
        break;
    case 数値:
        実行文;
        break;
    }

・for文 = 回数が決まっている繰り返しに使用する文。条件式が偽になった時に終了するのが普通だが、break文を使用して途中でfor文を終わらせることもできる。
　　　　　for文の中でbreak文が実行されると、for文は強制的に終了され、カウント変数はその時点の値のままとなる。

　　int i;
　　for (初期化; 条件式; 更新) {
        繰り返す文;
        (強制的にループを抜ける文)
    }

　　　初期化 = カウント変数の初期化を行うための文。ここに書かれた式は最初に1回だけ実行される。
　　　例) i = 1;

　　　条件式 = ループの終了条件を設定するための文。ここに書かれた式の値が真の間は、繰り返す分を実行し続ける。
　　　例) i <= 10;

　　　更新 = カウント変数の更新を行うための文。ここに書かれた式は、繰り返しを行う分を実行した後に実行される。
　　　例) i++

　　　(強制的にループを抜ける文) = ループを強制終了させるための文。ユーザが特定の入力をしたときにアプリを終了させるときなどに用いられる？
　　　例) if (i == 3) break;　　　　　　　　　　 

・while文 = 決まった回数だけループするfor文に対し、何回繰り返せば良いのか知りたい時に適している文。

　　while (条件式) {
        繰り返す文;
    }

・do-while文 = 繰り返す分の実行後に条件式を判定する文。while文との違いは条件式が後判定であるか先判定であるか、
　　　　　　　 そして繰り返し分が必ず1回は実行されるかされないかといったところ。
　　　　　　　 書き方の違いとしては、do-while文の場合にはwhile文の条件式の()の後に;が必要となる。

　　do {
        繰り返す文;
    } while (条件式);

・return文 = 数値を返す。

・sizeof演算子 = 変数や配列のサイズを求める演算子。()は付けなくてもよいが、付けた方が読みやすいため一般的には付ける。

　　sizeof(変数や配列名)
　　sizeof(配列名) / sizeof(配列名[0])

　2番目のプログラムでは、配列の要素数を求めることができる。この時、[0]にしているのは配列の長さが1であっても
　配列0番の要素は必ずあるから。[1]としてしまうと配列の長さが1のときにエラーとなってしまう。

・memcpy関数 = 配列の全要素を違う配列にコピーする。memcpy関数を使うには、memory.hファイルを#includeで指定しておく必要がある。

　　memcpy(コピー先配列名,コピー元配列名,配列全体のサイズ)

　配列全体のサイズは配列の方や要素数によって変わってくるので、この関数ではsizeof演算子で得られたサイズを元にする。

・char型 = 文字変数。文字を''で囲んで1文字を記憶しておくことができる。printf関数では%c指定子で指定する。
　　　　　 255種類しか記憶できないため、全角文字を扱うことはできない。

　　char 変数名 = '文字';

・isdigit関数 = 引数の文字が数字かどうかを調べる関数。引数の文字が数字なら0以外の値を返し、数字じゃなければ0を返す。
　　　　　　　　数字以外にもアルファベット、16進数の数字、記号などかどうかを調べる関数があり、isdigitとそれらは
　　　　　　　　「ctype.h」ファイルを#includeして使用する。

　　isdigit('文字')

・文字列変数 = 文字変数の配列。終端にEOSをつけることで文字数を判定している。EOS用の要素が必要となるので配列に必要な要素数は
　　　　　　　 文字数+1となる。

　　char 変数名[要素数] = {'文字1','文字2',・・・};
　　char 変数名[] = "代入する文字列";

　2行目の文字列リテラルを使用して代入する方法だと1字ずつ記入しなくてよい上に要素数も文字数+1で自動的に確保してくれるので楽。
　多めに領域を確保したい場合には指定することもできる。ただし、この方法は初期化の時にしか使えないため注意。

・atoi関数 = 数字を数値に変換した結果を変数に代入する。stdlib.hを#includeする必要がある。
　　　　　　 数字と関係ない文字列が指定された場合は0に変換される。実数に変換する場合にはatof関数を使用する。使い方は同じ。

　　変数 = atoi(文字列配列名);

・strcpy関数 = 文字列のコピーを行う。文字列配列同士のコピーに使うのが元々の役目だが、実際には文字列の代入に使われることが多い。
　　　　　　　 string.hを#includeする必要がある。

　　strcpy(コピー先文字列配列名, コピー元文字列配列名);

　コピー元文字列配列名は文字列リテラルでも可(むしろそっちの方が多い？)

・strncpy関数 = 先頭から指定された文字数だけをコピーする。場合によってはコピーされた文字列の最後にEOSが入っていないことがあるため、
　　　　　　　　必ずEOSをつけるプログラムも記述する。

　　strncpy(コピー先文字列配列名, コピー元文字列配列名, コピーする文字数)
　　コピー先文字列配列名[コピーする文字数] = '\0';

・strcat関数 = 配列に記憶された文字列を連結する。string.hを#includeする必要がある。
　　　　　　　 元の文字列が記憶された配列は、追加する文字列だけの長さが必要となるため、
　　　　　　　 文字配列の長さが足りない場合バッファオーバーランとなるので十分に注意する。

　　strcat(元の文字列が記憶された配列, 追加する文字列の記憶された配列);

・sprintf関数 = printf関数と同じ機能を持った関数だが、結果を配列の中に記憶することができる。
　　　　　　　　printf関数の様々な機能を自由に取り扱うことができ、あらゆる文字列合成に使用できる万能関数。

　　sprintf関数(結果を記憶する配列, 書式文字列, 各種変数・・・);

・strlen関数 = 文字列の文字数を数える。

　　変数 = strlen(文字配列);

・strcmp関数 = 文字列を比較する。2つの文字配列の中身が同じである場合には0を返す。

　　変数 = strcmp(文字配列1, 文字配列2);

・ポインタ変数 = ポインタ型で宣言された、ポインタ値を記憶できる実際の変数のこと。
　　　　　　　　 *がついていても、変数名はあくまでそのままとなる(例:int *p;なら変数名はp)
　　　　　　　　 宣言方法は、以下のように2通りある。

　　型名 *変数名;
　　型名* 変数名;

・ポインタ型の引数 = 関数から情報を2つ以上返したい時に使用する。

　　型名 関数名(引数の型* 仮引数)

・構造体 = 複数の異なる型をまとめて作られた型のこと。1行目の型を宣言しただけでは実際に使うことはできない。
　　　　　 実際に使うためには2行目の構造体の方の変数の宣言を行う必要がある。

　　構造体タグ名 構造体変数名
　　struct 構造体タグ名 構造体変数名;

　　　構造体タグ名 = 作成した構造体それ自体の名前。型名ではないため、扱い方は少し異なる。

・typedef = 新しい型を宣言する。構造体タグを新しい型として1度に宣言してしまう時などに使用。

　　typedef 新しい型の形 新しい型名
　　例)typedef struct student_tag student;

　以下のような使い方が普通となっている。

　　typedef struct
　　{
        int year;
        int clas
        ・・・
　　} student;

・fopen関数 = ファイルを開く関数。

　　FILE型のポインタ変数 = fopen(ファイル名,モード);

　　　モード = ファイルを開く目的を表す文字列。r,r+,w,w+,a,a+が指定できる。
　　　　　　　 バイナリファイルを開く際はモード文字列の最後にbをつける。

　fclose関数 = ファイルを閉じる関数。

　　fclose(FILE型のポインタ変数);

・fprintf関数 = ファイルへテキストを書き込む関数。printf関数とよく似ており、使い方はファイルポインタを指定すること以外
　　　　　　　　printf関数と全く同じ。指定した文字列は画面ではなくファイルに書き込まれる。

　　fprintf(ファイルポインタ,書き込み文字列,変数・・・);

・fscanf関数 = ファイルのテキストを読み込む。%d指定子を使用した場合、数字以外のテキストは無視されて表示される。
　　　　　　　　そのため、文字列全体を読み込みたい場合は%s指定子を使用する。しかし、スペースなどが含まれる場合にはそこまでしか読み込まれない。
　　　　　　　　また、複数の数値をカンマで区切って並べると、複数の変数を読み込むことも可能。

　　fscanf(ファイルポインタ,入力変換指定子,&変数名);

・fwrite関数 = ファイルに数値を直接書き込む。書き込む数値を変数に代入しておき、その変数のアドレスを指定する。
　　　　　　　　項目のサイズはsizeof演算子を使用して求めることができ、項目数は、変数を書き込むだけならとりあえず1でよい。
　　　　　　　　配列を1度で書き込むこともできる。

　　fwrite(書き込む変数アドレス,1項目のサイズ,項目数,ファイルポインタ);

・fread関数 = ファイルの数値を直接読み込む。使い方はfwrite関数と同じ。

　　fread(読み込む変数のポインタ,1項目のサイズ,項目数,ファイルポインタ);

・#define疑似命令 = 数値や文字列に名前を付ける。文の終わりに;をつけてはいけない。
　　　　　　　　　　また、名前には変数と同じ文字が使えるが、大文字のアルファベットが一般的。

　　#define 名前 数値

・const変数 = 値を変更できない変数のこと。特定の関数の中だけで使用する定数を宣言したい時などに便利。
　　　　　　　他にも関数の引数の型として使われることもある。これは、配列を渡すときにその値を変更させないため。

　　const 型名 変数名 = 値;

・enum定数 = 数値を指定する必要が無い。名前だけで自動的に数値が付けられるため、大量の定数を宣言する場合に便利。
　　　　　　 主にキャラの状態異常などを表すフラグ定数として使用される。
　　　　　　 しかし、整数値しか扱えず、実数値や文字列は扱えないためそれらを扱う際は#defineかconst定数にするしかない。
　　　　　　 enumの名前の後につける,は最後の名前にはつけても問題なく動作するため、付けて書いた方が名前の追加や修正が楽になる。

　　enum {
        名前,
        名前,
        名前
    };

    enum {
        名前 = 数値,
        名前 = 数値,
        名前 = 数値
    };

　enum定数で数値を指定する必要はないが、必要であれば指定することもできる。その場合は2つ目のように記述する。
　数値を省略した場合、1番先頭の名前を0として、以後は1つずつ増やした値が付けられる。
　どこかで数値を指定した場合、そこは指定した数値、以後はその指定した数値から1ずつ増やした値となる。

・malloc関数 = 自由に配列を作る関数。返されるポインタ変数には確保された配列の先頭アドレスが代入されるので
　　　　　　　 これに[]演算子を使用すれば配列と同様に扱うことができる。malloc関数で指定できるのはバイト単位のサイズなので
　　　　　　　 任意の要素数の配列を確保するにはsizeof演算子を使用する。なお、malloc関数で確保したメモリを「ヒープ」と呼ぶことがある。
　　　　　　　 ヒープとは、長期的に使用される大きなサイズのメモリを格納する領域のこと。
　　　　　　　 また、ヒープに確保された配列を「動的配列」と呼ぶことがある。深刻なメモリ不足などが原因でメモリ確保に失敗すると、
　　　　　　　 NULLが返され、これをそのまま使用すると強制終了してしまうのでmalloc関数の戻り値は必ずチェックする必要がある。

　　ポインタ変数 = malloc(必要なメモリのバイトサイズ);

・free関数 = メモリを開放する関数。malloc関数によって確保されたメモリが不要となった場合に必ず呼び出す。
　　　　　　 malloc関数によって確保されたメモリはプログラムが終了するまで残るが、そのメモリが不要になった場合に
　　　　　　 free関数を使って解放する。

　　free(ポインタ変数);

・exit関数 = プログラムを終了させる関数。

・abort関数 = エラーによる強制終了の時にプログラムを終了させる関数。

・realloc関数 = 要素数を変更する。中身を維持したまま、新しいサイズのメモリを確保する。
　　　　　　　　新しいポインタ変数には拡張されたメモリのアドレスが返されるが、特別な理由が無ければ以前のポインタ変数と同じ変数を指定できる。
　　　　　　　　malloc関数でメモリを確保してから使用されることが多い。

　　新しいポインタ変数 = realloc(以前のポインタ変数,必要なメモリのバイトサイズ);

・extern宣言 = 宣言だけを行い定義は行わない宣言方法。宣言だけを複数回行い、定義は1回で済ませるために使用する。
　　　　　　　 extern宣言を使うと、異なるソースファイルで変数を共有することができる。

　　extern 型名 関数名(引数);
　　extern 型名 変数名;

・#ifndef～#endif疑似命令 = ヘッダーファイルの重複インクルードそれ自体を防ぐ方法。
　　　　　　　　　　　　　　ある記号が定義されていなかった場合だけ、その間に挟まれたプログラムをコンパイルするという記号。

　　#ifndef 記号
　　・
　　・
　　・
　　#endif

・abs関数 = 絶対値を計算する。絶対値とは、数直線上における原点からの距離のこと。

　　abs(数値)

・pow関数 = 累乗を計算する。

　　累乗 = pow(数値,指数);

・sqrt関数 = 平方根を計算する。

　　平方根 = sqrt(数値);

・tan関数 = tan(正接)を計算する。

　　タンジェント = tan(ラジアン角度);

・rand関数 = 疑似乱数を作る。特にパラメータを渡す必要は無く、そのまま使うだけでランダムな値を計算する。
　　　　　　 rand関数で得られる最大値は「RAND_MAX」という定数の値でわかる。そのため、ある範囲の乱数を得たい場合は
　　　　　　 RAND_MAXを等分すると求められる。これを関数で定義して使用したりすると良い。公式は以下。

　　変数 = rand();
　　最小値 + (int)( rand() * (最大値 - 最小値 + 1.0) / (1.0 + RAND_MAX) )

・srand関数 = rand関数で使用される乱数の計算に使う元の数を変える。

　　srand(元の数);

・time関数 = 現在時刻を得る関数。

　　time();

・gets関数 = キーボードから1行の文字列を入力する。

　　gets(文字配列);

・puts関数 = 画面に1行の文字列を表示する。文字列の後で必ず改行される。
　　　　　　 printf関数よりも低機能だが、文字列の表示だけならputs関数の方が簡単。

　　puts(文字配列);

・fgets関数 = ファイルから文字列を読み込むための関数。

　　fgets(文字配列,配列の要素数,ファイルポインタ);

・strtok関数 = 文字列の中から単語を取り出す。1行目では初めの単語を取り出し、2行目では次の単語を取り出す。
　　　　　　　 区切り記号を検索し、その位置をEOSに置き換える。文字列を区切り記号の前と後ろに分割できる。

　　単語のアドレス値 = strtok(文字配列,区切り文字);
　　単語のアドレス値 = strtok(NULL,区切り文字)

・getc関数 = ファイルから1文字読み込む関数。

　　getc(ファイルポインタ);

・putc関数 = ファイルに1文字書き込む関数。

　　putc(書き込む文字,ファイルポインタ)

・

================================================================================================================================

ヘッダーファイル一覧とその中に入っている関数

<stdio.h>
　printf
　scanf
　sprintf
　fopen
　fclose
　gets
　puts
　fgets
　getc
　putc

<memory.h>
　memcpy

<ctype.h>
　isdigit

<stdlib.h>
　atoi
　atof
　malloc
　exit
　realloc
　abs
　rand

<string.h>
　strcpy
　strncpy
　strcat
　strlen
　strcmp

<math.h>
　pow
　sin
　cos
　asin
　acos
　atan

<time.h>
　time