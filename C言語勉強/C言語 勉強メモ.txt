C言語 勉強メモ

・C言語の関数の構造は以下のようになっている。

　　型名　関数名(引数)　{処理}

　　　型名 = 関数が計算結果を返す時に使う数値の種類のこと。例えば、「int」なら整数を意味する。

　　　関数名 = 関数の名前。命名規則としては半角アルファベット、半角数字、_が使用できる、1文字目には数字を使うことはできない、
　　　　　　　 あらかじめ決められた予約語は使用することができない、などがある。予約語とはC言語の中で使われているキーワードのこと。
　　　　　　　 予約語の他、予約済み識別子も名前として使用できない。例えば、_に大文字が続く名前は使用できない。

　　　引数 = 関数に渡す数値の種類のこと。情報を渡す必要が無い場合は、情報が無いことを表すvoidを使用する。

　　　処理 = 処理のこと。例えば、関数を終了させる処理をさせたい場合はreturn文を使用する。

・C言語ではmain関数が最初に動作すると決められており、main関数が無かった場合そのプログラムは動作できない。
　逆に、main関数さえあればC言語のプログラムは動作できる。

・コンパイラ = 高級言語(人間が考えたプログラミング言語)で書かれた文字列ファイルをマシン語に翻訳するソフトのこと。

　翻訳方法には主に2種類あり、C言語は全てを一気に翻訳する方法を使用する。
　インタプリタと呼ばれる同時翻訳を行うタイプは柔軟な構成ができるが速度が低速であることが欠点。

・コンパイラは実際には3段階の仕組みで動作している。まず始めに「プリプロセッサ」というソフトにより文字列の調整が行われ、
　次にコンパイラによってコンパイルされる時に「最適化」が行われ、最後に翻訳された機械語プログラムが「リンカ」というソフトによって
　結合される。リンカで結合することを「リンク」と呼ぶ。リンクされることでマシン語のデータが実行可能ファイルとなる。

　ソースコード(ソースコード) → プリプロセス(文字列の調整) → コンパイル(翻訳) → リンク(結合) → 実行可能なソフトウェア(実行可能ファイル)

　※プリプロセス、コンパイル、リンクをまとめてコンパイルと呼ぶことがある。
　　また、実行可能ファイルを作成することをまとめてビルドと呼ぶことがある。

・実行可能ファイル(.exeファイル)となったファイルはアプリケーションとして実行が可能となる。

・C言語のプログラムを文法的に分解した時、最小単位は「トークン」となる。
　int main(void) {return 0;}といったプログラムの場合は以下のように分解される。

　int
　main
　(
　void
　)
　{
　return
　0
　;
　}

　トークンを最小単位と呼ぶ理由は、これ以上分解すると意味が変わってしまうため。

・C言語はフリーフォーマット、つまり自由書式となっている。C言語のプログラムの書き方で明確なルールはたった1つだけとなっており、
　それが「トークン同士をつなげて書いてはいけない」ということ。しかし例外もあり、記号はつなげて書いてもよいことになっている。
　理由としては、記号はあらかじめ決められた1文字なので繋がっても区別できるため。

・C言語は大文字と小文字を区別するため、プログラムを打ち込む際には気を付ける。また、文の終わりには;を書くことになっており、
　これを忘れるとエラーとなってしまうため気を付ける。

・C言語では、/* */で挟むことによってその間をコメントにすることができる。

・C言語ではただ関数を記述しただけでは動作しないため、動作させるにはコンパイラにその関数の説明書を読ませる必要がある。
　この説明書を渡すための特別な命令のことを「#include疑似命令」と呼ぶ。疑似命令とは、プログラムコードではない命令のこと。
　この命令は機械語に翻訳されずにその前段階で処理される。

　#include疑似命令は次のようにして使用することができる。

　　#include <説明書のファイル名>

・改行文字以外によく使われるエスケープシーケンスとしては、頭ぞろえのためにタブを挿入する「\t」がある。

・""で囲まれた文字列を「文字列リテラル」と呼ぶことがある。

・printf関数はあくまで文字列を表示する関数のため、数値を表示させるには「出力変換指定子」を使用する必要がある。
　出力変換指定子とは、文字列の中に埋め込んで使われる記号の一種で、外部のデータを変換して表示したい時にその変換方法を指定する記号のこと。

　出力変換指定子にはいろいろな種類があるが、最もよく使われるのは整数値を文字列に変換する「%d指定子」。
　この指定子の部分には、後ろで指定した数値を文字に変換した結果が表示される。

・文字列の中に%d指定子を使うと、その部分が数値に置き換えられる。例えばprintf関数1回で1「100円」と表示したい場合は以下のように記述する。

　　printf("%d円", 100);
　　printf("%d+%d=%d", 100,200,300)

　2行目のように、複数配置することも可能。このプログラムでは%d指定子は前から順番に、後の数値に1対1で対応していく。

・整数計算の結果は四捨五入ではなく切り捨てとなる。理由は、四捨五入を行うと、「商*割る数」の逆計算を行った時に
　その結果が元の割られる数よりも大きいという矛盾が生じるため。
　例) 10/3*3

・先頭に0を付けた数は8進数と解釈されるので注意が必要。(0152は10進数の106と解釈される)

・コンピュータで実数を扱う方法はいろいろあるが、C言語では「浮動小数点方式」と呼ばれる方法を使用している。

　　浮動小数点方式 = 実数値を数値の並び(仮数部)と、小数点の位置(指数部)で表す方式。
　　　　　　　　　　 仮数部に10の何乗などの値を掛け算して実数を実現する。
　　　　　　　　　　 巨大な数から極小の数まで扱え便利だが、計算は遅い。

・実数値を数字に変換する場合は%d指定子ではな「%f」指定子を使用しなければならない。

・変数を宣言するには次のような書き方を使用する。命名規則は関数と同じ。

　　型名　変数名;

　変数の宣言は基本的に関数の先頭でしか行うことができないので注意する。
　しかしC++やC言語の新規格であるC99でも使えるため多くのコンパイラでは変数宣言をどこでしても動いてしまう。
　元々のC言語では使えないのだということを覚えておく。

・代入と演算を同時に行う演算子には以下のような種類がある。

　　+= → 変数の値との加算を変数に代入。
　　-= → 変数の値との減算を変数に代入。
　　*= → 変数の値との乗算を変数に代入。
　　/= → 変数の値との除算を変数に代入。
　　%= → 変数の値との余算を変数に代入。

　これ以外にも、変数の値を1増やす演算子は++演算子で「インクリメント」と呼ばれ、1減らす演算子は--演算子で「デクリメント」と呼ばれる。
　変数の値を1増やしたり減らすことが非常に多いのでこの演算子はよく使用される。

・C言語では様々な種類の数値を扱うことが可能なため、数値毎に別々の種類の変数を使って記憶する必要がある。
　このように様々な種類の数値のことを、データ型と呼ぶことがある。

　　データ型 = 数値の種類のこと。最大桁数、整数なのか実数なのかなどが異なる。

・C言語では整数と実数で計算した場合の結果は実数に変換される。

・消費税の計算など実数を整数に変換したい場合などに、肩を強制的に変換する機能として、「キャスト変換」がある。
　キャスト変換の使い方は以下の通り。

　　(変換する型名)数値や変数名

・数値の末尾をそろえて表示するには%d指定子を「%桁数d」といった形で使用する。
　マイナスの値も1桁として取り扱われるため、マイナスの値を表示する可能性がある場合は、1桁大きく指定しておく。
　更に、「%0桁数d」のように記述すると、先頭に0をつけることができる。

　実数値の桁揃えは「%全体桁数.少数桁数f」のように記述する。ここで注意するのは、全体桁数は少数の桁数と小数点を含むこと。
　たとえば%6.2fでは、整数部分が3桁、小数点が1桁、小数部分が2桁の6桁と解釈される。

・scanf関数で実数を入力する場合は%f指定子ではなく%lf指定子を使用する必要があるので注意する。

・int 変数名 = 値;のように変数の宣言と同時に代入を行っているこの書き方について、
　変数の値を最初に決められるため「初期化」と呼ぶことがある。

・if文で使われる演算子には以下のようなものがある。また、この系統の演算子を等値演算子と呼ぶ。

　　== → 2つの値が等しければ真、等しくなければ偽となる。
　　!= → 2つの値が等しくなければ真、等しければ偽となる。

・if文で使われる比較演算子や、関係、論理演算子は全て演算子、つまり普通に数式の中において計算に使うこともできる。
　answer = val1 == val2; といったプログラムでは、val1とval2が等しい時にはanswerに1を、等しくないときは0が代入される。

・論理演算子には以下のようなものがある。

　　&& = 右と左の条件が両方真であれば真、右と左の条件のどちらか片方でも偽であれば偽となる。
　　|| = 右と左の条件のどちらか片方でも真であれば真、右と左の条件が両方偽であれば偽となる。
　　! = 条件が偽であれば真、条件が真であれば偽となる。

・複数の文をひとまとめにする機能として、「ブロック文(複文)」と呼ばれる機能がある。{}で囲むことで、複数の文をまとめられる。
　ブロック文を使うと、if文の横の文など1つの文しか置けない場所に複数の文を置くことができる。

・for文などループの時に使用する変数を「カウント変数」や「ループ変数」と呼ぶ。

・一般的なアプリのように勝手に終わらないようにする時には無限ループが使われている。

・for文とwhile文は同じような使い方をすることが可能。while文に更新を入れれば定数会のループを実現できるし
　for文から初期化と交信の文を省略すればwhile文のように扱える。

・do-while文の必ず1回は実行されるという利点は、入力チェックを行う時にその特性を発揮する。
　例えば、数値を入力してほしいときに負の値を入力したときはもう一度入力を促すプログラムはこれを使用する。

・以前に作成したプログラムを再び使うことを「再利用」と呼び、関数として再利用することを「部品化」と呼ぶ。

・新しい関数が使えるのは、その関数よりも後にコンパイラが発見した関数の中だけとなる。これを解決する方法の1つには後に使いたい関数を
　先頭に持ってくる方法があるが、関数が沢山ある場合に常に順序関係を気にするのが面倒となる。
　そこで、どんな関数が作られているのか前もって一覧にしておくことでこの問題が解決できる。この解決方法を「プロトタイプ宣言」と呼ぶ。
　main関数だけは唯一プロトタイプ宣言が必要ない関数となっている。

　　プロトタイプ宣言 = あらかじめ先頭で関数の形を宣言しておくことで、他の全ての関数からその関数を使えるようにすること。
　　例) int sum(void);

・printf関数などのプロトタイプ宣言は、stdio.hファイルの中に書かれている。これが#includeを記述する最大の理由となっている。

・関数に渡す情報の総称を「引数」と呼ぶ。引数を使うと、関数に数値を渡すことができる。
　引数を使う場合、()の中には渡された数値を格納する変数を宣言する。使用する変数を指定する部分を「仮引数」と呼ぶ。
　プロトタイプ宣言では関数の変数を省略して方だけ記述する形でもよい。

・引数を持つ関数を呼び出す場合、数値を渡す必要がある。そのためには、呼び出すときに()の中に数値を書き込む。
　この関数に渡す数値のことを「実引数」と呼ぶ。

・関数名の前にある文字列(例:int)は、関数から返る数値の方を示している。

・関数から帰ってくる数値を「戻り値(関数値)と呼ぶ。これは、計算結果かエラーの有無を示す数値であることが多い。
　呼び出し元で戻り値を知りたい場合には、呼び出し元で value = sum(50, 100); のように変数に代入する必要がある。
　戻り値は1つだけしか返すことができない。戻り値が不要な場合はvoidを指定する。ごく単純な関数であれば、戻り値が不要なことは意外に多い。

・関数の中で宣言された変数は、関数が終了すると捨てられてしまう。そのため、再び同じ関数が呼び出された場合、もう一度変数を作り直す。
　この時、前回とは別のメモリが使われるので値が変わってしまう。
　このように、関数の中で寿命が終わる変数のことを「ローカル変数」と呼ぶ。また、変数の寿命や有効範囲などをまとめて
　「スコープ」と呼ぶことがある。

　　ローカル変数 = 関数の中で宣言された変数。仮引数の変数も同様。その関数が終わると捨てられ、再度関数が呼ばれたときには新しく作られる。
　　　　　　　　　 また、他の館数から使用することはできない。

　　スコープ = 識別子が有効な範囲を制限する仕組みの総称。一般的には、変数の寿命と有効範囲を決定する仕組み。

　なぜ関数ごとに変数が全く別々に作られるか、それは関数の独立性を高めて他のプログラムでもすぐに使えるようにするため。
　正確にはローカル変数の寿命は関数内ではなくブロック内となる。

・関数外で宣言された変数のことを「グローバル変数」と呼ぶ。

　　グローバル変数 = 関数外で宣言された変数のこと。プログラム全体が終了するまで生き残り続け、
　　　　　　　　　　 宣言されたソースファイル内の全ての関数から使用できる。したがって、変数が何度も呼ばれた場合でも、以前の数値を記憶している。

　グローバル変数はプログラムの開始時に自動的に0に初期化される。ローカル変数は関数の呼び出しのたびに作られる。そのたびに初期化していると
　無駄になるため自動的には初期化されないが、グローバル変数は最初に1回だけ初期化すればよいためこのように初期化される。
　どの関数からでも代入や値の取得ができることで便利だが、他の館数でどのような使い方をしているか十分に気を付けて使用しなければならない。
　グローバル変数はプログラム全体で共有する特別なデータだけに使い、基本的にはローカル変数を使用することでプログラムをわかりやすくできる。
　正確には全ての関数で共有されるのではなく、1つのソースファイル内で共有される。

・グローバル変数と同名のローカル変数ではローカル変数が優先される。

・関数内で変数を宣言する時に、型名の前にstaticとつけることで静的なローカル変数を宣言できる。
　静的なローカル変数は関数内で宣言されているため、使用できるのは宣言された関数内のみだが、
　その値はプログラムが終了するまで残る。また、特に初期化しなくても自動的に0に初期化される。
　この変数は、関数が以前に呼び出されたときの値を覚えておきたい場合に使用される。

・配列とは、複数の同じ型の変数をまとめて取り扱えるようにする仕組みのこと。
　配列として宣言された変数は、1つ1つが番号によって区別される。配列は次のようにして宣言する。

　　型名 配列名[要素数];

　　　型名 = 変数の方と同じ意味をもつ。ここで指定した方の変数が、要素数の数だけ作られる。

　　　配列名 = 配列全体の名前のこと。ここの変数を使う場合、この名前に番号を付けることで区別する。

　　　要素数 = 作られる変数の数のこと。ここで指定した数だけ、指定した方の変数が作られる。
　　　　　　　 ここで数として指定できるのは整数値のみで、宣言の時には整数型の変数を指定することはできない。

　配列の番号は1ではなく0から始まる点に注意する。

・配列の初期化は次のようにして行う。

　　型名 配列名[要素数] = {0番目の数値、1番目の数値、・・・};

　配列の要素数よりも少ない場合、残りにはすべて0が代入される。
　この方法で配列を宣言した場合、要素数を省略できる。その場合、指定した数値の個数だけの要素数が確保される。
　1度に配列に値を代入するのは宣言の時しかできないことに注意する。

・配列の要素番号には変数も使える。変数の値を変化させれば、様々な番号の要素に直接アクセスできる。

・sizeof演算子で配列全体のサイズを求め、それを要素1つのサイズで割れば要素の数が分かる。

・配列の全要素を違う配列にコピーしたい時はfor文でコピーできるが、for文を使わなくても「memcpy」関数を使うことでコピーができる。

・memcpyはコピー先よりもコピー元の配列が長い場合でも無理やり全部コピーしてしまう。その結果として長い部分がはみ出してコピーされてしまい、
　無関係の他の変数や配列を上書きして重大な計算エラーを引き起こす。これが「バッファオーバーラン」と呼ばれる悪名高いバグとなっている。
　アプリやパソコンが突然止まったりする原因の多くがこのバッファオーバーランとなっている。厳密にははみ出してコピーされただけの場合はバッファオーバーフローと呼ぶ。

・C言語には文字列を記憶する変数が無い。理由としては、文字列が何文字になるのかが事前に予測できず場合によって必要とされるメモリのサイズが異なるといった
　特殊な性質を持つため。文字列変数は無いが、文字変数は用意されている。文字列と違って文字は必ず1文字であるため変数で扱うことができる。
　C言語では文字変数としてchar型が用意されており、char型の変数には1文字を記憶しておくことができる。

・char型変数に文字を代入するのは、それぞれに対応する文字コード(数値)を代入しているのと同じ、つまりchar型は普通の整数型と全く同じとなる。
　このことを利用すればAに足し算を行って何番目のアルファベットを取り出す、'数字'から'0'を引き算して数値に変換するなど、
　このような計算を行うことも可能となる。

・文字列を記憶する変数は無いが、この文字変数の配列を作れば文字列にすることができる。C言語では文字変数の配列を文字列変数として使うことができる。
　文字列の最後に特別な値を記憶しておくことで文字数を判定する。このような文字を「EOS」と呼ぶことがある。C言語の場合、'\0'がEOSとして扱われる。
　文字列の最後にはEOSが入るため、配列の要素数は実際に格納する文字数より1つ多く必要になる。

　　EOS(End Of String) = 文字列の終わりを表す記号。終端文字とも呼ばれる。

　printf関数で文字列を表示させる場合は、%s指定子を使用する。

・文字列リテラルを連結するだけなら関数は使わずに文字列リテラルをただ並べるだけで連結できる。ただし、配列に記憶された文字列を連結する場合には配列名を並べてもできない。
　その場合はstrcat関数を使用する。

・printf関数で表示したい文字列中に%が含まれている場合、出力変換指定子と誤解して誤動作するため、その時は
　%s指定子を用いて表示させる。

・scanf関数では数値と同様に文字列も入力できる。その場合は%s指定子を指定する。ただし、配列名の前に&を付けない。
　これには非常に重大な理由がある。後々記述するが、簡潔に言うと配列はC言語の本質であるポインタそのものであるため。

・文字列配列同士の比較では==演算子を使うことはできない。文字配列の中身を比較するにはfor文で全要素を比較する必要がある。

・コンピュータのメモリとは、巨大な1列ロッカーのような構造。そしてこのロッカーは1つ1つがオンとオフの2つの状態を記憶している。
　このロッカー1つを1ビット、8つをまとめて1バイトと呼んでおり、メモリにはこの1バイトごとに番号が付けられて区別されている。
　プログラムで宣言した変数も、このメモリに番号付きで記憶されている。ただし番号で区別するのではわかりにくいので名前を付けている。
　実行ファイルにコンパイルすると、変数名は番号に変換される。要するに、全ての変数はメモリに作られており、そこでは番号を付けて区別している。

・CPUが1回で扱うメモリの2進数での桁数 = ビット数となる。つまり64ビットは64桁となる。
　64ビットのコンピュータは、64個のデータをひとまとめにして取り扱う。

・変数につけられた番号を調べるには、printf関数で%p指定子を使用し、変数名の前に&をつける。
　この変数に着けられた番号のことを「アドレス」と呼ぶ。

・配列のアドレスを参照すると、配列名と配列の最初の要素のアドレスが等しくなっている。これはつまり、配列名が配列の最初の要素のアドレスを表すということになる。
　つまり、各要素を参照する時に[1],[2]といった要素番号をつける意味は、「配列名のアドレス + 参照したい要素番号のメモリ」を参照するという意味になる。

・&は変数のアドレスを求める演算子。どんな変数でも&演算子を使うと、変数のアドレスを求めることができる。つまり、&演算子を使うとその変数のメモリ上の番号を知ることができる。

・引数で関数に渡されるデータは全て数値である。このように、引数で数値を渡す方式を「値渡し」と呼ぶ。
　ここで重要なのは、変数を実引数に指定しても、渡されるのは中身の数値であるといった点。通常はこれで問題ないが、
　もし変数の中身を関数によって直接変更したい場合、関数に渡されるのは変数の中身のコピーに過ぎないため、そのコピーをいくら変更しても
　呼び出し側の変数には何の影響もないといったことが起こる。そこで、&演算子を使ってアドレスを求め、そのアドレスの数値を渡すようにすると
　関数に呼び出し側の変数のアドレス、すなわちメモリ上の番号が分かり、その番号のメモリを書き換えてやれば呼び出し側の変数を書き換えることができる。
　これが、変数のアドレスを知る必要がある理由となっている。

　　値渡し = 関数に単なる数値として情報を渡す方法。

　C言語には値渡ししかないが、アドレスを渡すことを慣習的に「参照渡し」と呼ぶこともある。

・つまりscanf関数でなぜ&演算子をつける必要があるか、それはC言語では値渡ししかできないため、
　変数のアドレスを教えないと、関数によって変数に新たな値を記憶させることができないため。
　ではなぜscanfで文字列を入力する際には&がいらなかったのか、
　それは、配列名が配列の最初の要素のアドレスを表しているため。

　上記から、scanf("%s", &配列名[0]);　とすれば配列名を指定したときと同じように入力ができる。
　更に　scanf("%s", &配列名[6]);　のようにすれば配列の途中から入力させることも可能。

・関数に変数のアドレスを渡すと変数の中身を変更できると記述したが、それにはアドレスの値を記憶することのできる変数が必要となる。
　世間ではアドレスの値を記憶する変数を「ポインタ」と呼んでいるが、本当はあまり正確な呼び方ではない。
　なぜなら、ポインタとはアドレスを扱う機能3つの総称だから。正確には3種類に分かれている。

・ポインタ型 = アドレスを記憶する変数の型のことを意味する。int型やdouble型と同じような型。
　　　　　　　　 ただし通常の方とは異なり、他の方から作り出される派生型であるといった点を持っている。
　　　　　　　　 int型の場合は独立した型であり、他の型とは何の関係もない。それに対してポインタ型は、
　　　　　　　　 他の型とポインタ型を合体させて作る。int型とポインタ型を合体させると、intへのポインタ型という型ができ、
　　　　　　　　 double型なら、doubleへのポインタ型が作り出される。また、intへのポインタ型にさらにポインタ型を合体させると
　　　　　　　　 intへのポインタのポインタ型という、多重のポインタ型を作ることすらできる。要するに、ポインタ型は他の方と合体しなければ
　　　　　　　　 この世には存在できないといういわば寄生虫のような型となっている。

　ポインタ型は要するにアドレスを記憶する変数の方、アドレスとは結局は整数値に過ぎない。ならばどうしてその整数値を記憶する型が
　他の方と合体する必要があるのか。それは、指定アドレスに記憶された数値を取り出すため。たとえばint型、double型、char型は
　全てサイズが違い、int型の場合なら4バイトのサイズとなるので、int型の値を取り出すにはこの4個をまとめて取り出さなければならない。
　型によっては、メモリに記憶された2進数の読み方まで違ってくることもあるため、元々の方が何だったのかがわからない限り、
　記憶された数値を取り出せない。つまり、ポインタ型は「どんな型の変数のアドレスだったか」が分かる必要がある。
　そこで、あらかじめ他の変数と合体した形でポインタ型として作っておけば、そのポインタ型の変数に記憶された数値は、
　合体されている型であるとすぐわかる。実際には、単独で存在するポインタ型としてvoid型がある。
　この型は、どんな変数のアドレスでも記憶できるが、元々の変数の型が分からないため、値を取り出すことができない。
　戻り値がいらない場合にvoidを指定するのには、こういった理由があった。

・ポインタ値 = ポインタ型で扱える数値、要するに変数のアドレスの値のこと。
　　　　　　　 整数や実数といった数値の区別と同様にポインタ値という区別がある。

　ここで1つの疑問が残る。アドレスが単なる整数値であるならint型に記憶すれば事足りるはずなのに、なぜわざわざポインタ値などという
　新しい数値として扱う必要があるのか。実はint型に記憶すればよいというのは、ある意味ではその通りとも言える。
　32ビットのコンパイラではアドレスもint型も32ビットになるため、符号なしのint型に記憶したところで何の問題もない。
　それどころかC言語の先祖に当たるB言語では、C言語のint型に当たる型にアドレスを記憶する仕組みだった。

　しかし、C言語でポインタ値という数値として扱われているのには理由がある。
　まず、ポインタ値と通常の整数値とでは、その意味が明らかに異なるということ。
　通常の整数値はプログラムの中で計算などを行うための数値だが、ポインタ値は計算に使われる数値ではないから。
　つまり、この2つはどちらも単なる整数値だがその目的が全く別となっている。
　このことから、int型の変数で両方を扱っても、何のメリットもなく、むしろ変数に記憶される数値が整数値なのかポインタ値なのかが
　わかりにくくなってしまうため、それならいっそのこと2つを別々の数値とした方がよほど便利になる。

・ポインタ変数 = ポインタ型で宣言された、ポインタ値を記憶できる実際の変数のこと。
　　　　　　　　　int型やdouble型の変数と基本的には同じ。この変数にはその元となった型の変数のアドレスを自由に代入できる。
　　　　　　　　　更に記憶しているアドレスのメモリを読んだり書き換えたりできる。

　他の変数はどんな値を記録するにせよ何らかの計算に使うことが目的だったが、ポインタ変数では記憶しているアドレス値を
　計算に使うことはなく、アドレス値が指し示しているアドレス番号のメモリの値を計算することが役目となる。
　ポインタ変数そのものを計算に使うのではなく、それが指し示している変数を計算するのが、ポインタ変数の目的。
　言い換えると、普段はポインタ変数として振舞っているが、指し示している変数の計算が必要な時には
　普通の変数に変身する必要がある。この変身機能こそがポインタ変数の最大の特徴となる。ポインタ変数は、ポインタ変数モードと
　通常変数モードの2モードを備えており、必要に応じてそれぞれを切り替えて使うことができる。
　ポインタ変数モードでは、アドレスへの代入と足し算引き算だけの機能しかない。なぜなら、ポインタ変数モードに必要なのは
　アドレスの記憶だけだから。通常変数モードに切り替わった場合、その性質は通常変数と全く同じとなる。おかげで、通常の変数と
　同様に様々な演算子を使って計算ができる。当然その時に使われるメモリは、ポインタ変数モードで記憶したアドレスとなる。

・ポインタ変数にアドレスを代入する際に、適当なアドレス番号を代入するとOSにより異常動作だと判定されて強制終了してしまう。
　これは、仮想メモリと呼ばれる、OSがメモリを管理してそれぞれのアプリに適切にメモリを振り分けて個々のアプリが使うメモリが
　被らないように管理している機能が働いているため。そのため、ポインタ変数にはOSによって管理されたアドレス番号を代入する必要がある。
　OSに正常に管理されているアドレス番号を代入する簡単な方法としては、もう1つ別の変数を宣言し、そのアドレスを代入する方法がある。

・ポインタ変数も宣言した直後はでたらめな値が代入されており、その値が使用可能なアドレスなのかは全くわからないので、勘違いで
　そのアドレスを使ってしまうと確実にバグとなってしまう。これを防ぐにはアドレスを代入したかを区別する必要がある。そこで、
　C言語には「ヌルポインタ」が用意されている。NULLという記号をポインタ変数に代入しておけば、アドレスが代入されていない、
　つまりまだつける状態になっていないことを示せる。int *p = NULL;　のようにし、if文で p == NULLであるか比較すれば
　pにアドレスが代入されているかを区別できる。ちなみに、int *p = 0;　としてもヌルポインタが代入されるが、これはC言語の文法として
　決まっていることであり、NULLが0であるということではない。あくまでもNULLはNULLとなる。NULLは正しいアドレスが代入されていないことを
　示すための識別用の値であり、計算に使うための数値である0とは明確に区別されるもの。(もっとも、多くのコンパイラではNULL = 0となっている)

・ポインタ変数モードの時に読み書きしたいメモリのアドレスを代入して、その後通常変数モードに切り替えてそのメモリを操作する。
　といったことがポインタ変数の最も基本的な使い方となる。

・ポインタ変数を宣言する時に使用する*と、ポインタ変数を通常変数モードにする*は何の関係もない全く別の記号となる。
　たまたま同じ文字を使っているだけ。

・ポインタの本当の使い方は「ショートカット」として使用することにある。Windowsのデスクトップに並んでいるショートカットと同じように、
　どこか別の場所にあるものを指し示すもの。ショートカットを開けばその指し示しているものにアクセスできる、にもかかわらずショートカットは
　指し示すもの自体ではないため、ショートカットはどこにでも自由に作ることができ、複数個作ったり削除したりしても、指し示すものには
　何の影響もない。これこそが、まさにポインタの役割そのものとなる。ポインタ変数に実際に存在する変数のアドレスを記憶しておけば、
　そのポインタ変数が使える場所であれば、元の変数が使えない場所であってもポインタ変数を通常変数モードに切り替えれば
　元の変数と同じく使うことができる。まさにショートカットのような働きをさせることができる。

・一般的には、ポインタはC言語とC++のみの機能だと言われており、確かに指定したメモリのアドレスを操作するという意味ではその通りとなる。
　しかし、ポインタの本当の使い方はショートカットとして使うことであり、その観点ならば、「実用的なほとんどの言語にポインタがある。」
　Javaの参照はまさしくそんな機能で、しかも頻繁に使われる。VBのSETステートメントなども同様と言ってもよいぐらい。
　そもそもポインタが無いのでは連結リストや木構造などの複雑なデータ構造を実現できず、オブジェクト指向も困難となる。その意味では
　仕組みが不明なJavaやVBのポインタより仕組みがはっきりしているC言語のポインタの方が理解しやすい。他の言語の参照とC言語のポインタの
　最大の違いは、自動なのか手動なのか、といったところ。他の言語の参照はほとんど自動でショートカットとして機能するようになっているが、
　C言語のポインタは完全に手動であり、プログラマーが完全に理解して使わなければならない。
　そのかわり、上級者がC言語のポインタを使いこなすと、ポインタだけでほぼあらゆる制御構造、データ構造を実現可能にできる
　強力すぎる機能となる。実際、C言語のほとんどの機能がポインタで成り立っている。

・戻り値を使って情報を返すのがもっとも簡単に関数から情報を返す方法であることは間違いないが、この方法では常に1つの情報しか
　返すことができず、2つ以上の情報を返したい時に不便。そのような場合には、ポインタ型の引数を使って情報を返すことができる。
　ポインタ型の引数と言っても、単に引数の型がポインタ型であるだけで、普通の引数と何ら変わらない。
　C言語では関数へ情報を渡す場合、必ず元の変数の値のコピーを渡す。これを値渡しと呼び、元の変数の値が変更されないことが特徴。
　ポインタ型の引数であっても、値のコピーが渡される原則に違いはない。それでもポインタ型を使うのは、ポインタ型はアドレスを受け取ることができるから。
　関数を呼び出すときに、既に存在する変数のアドレスを指定すれば、呼び出された関数で受け取ったアドレスをポインタ変数に代入すれば
　後はポインタ変数を通常変数モードに切り替えて、返す情報を代入できる。
　返された情報は、呼び出し側で指定した変数に記憶されていることになる。

・配列を引数にすることもできる。しかし、配列の場合は通常の引数とは異なり、配列自体を値渡しするのではなく
　配列の先頭のアドレスを渡すため、要素数が完全に無視されたり、呼び出し先で配列の値を変えると呼び出し元も変更されるといったことが起こる。
　このことについてまとめると、次の3つの仮引数宣言は同じ意味の仮引数宣言となる。

　　int getaverage(int data[10]);
　　int getaverage(int data[]);
　　int getaverage(int* data);

　そして関数の中では、dataはいずれもポインタ型の変数となり、呼び出し先と呼び出し元では全く同じメモリ領域の配列を使うことになる。
　3つとも意味は同じだが、3番目は普通のポインタ型と紛らわしく、1番目は丁寧すぎるため2番目のように要素数を省略した形が良く使われる。

・しかし、関数に配列を渡すには配列の先頭要素のアドレスを渡す、つまりポインタ変数となるのに[]を使用して要素番号が指定できるのは
　なぜなのか。それは、単に配列名というアドレスに足し算を行っているだけとなる。数式の中に配列名を記述した場合、[]の記号の有無にかかわらず
　配列名は配列の先頭要素へのアドレス(ポインタ値)として扱われる。そして、その配列名に[]を付けた場合、そのアドレスに番号の値だけ足し算を行い、
　その結果として足し算された分の番号の要素として扱われている。

・配列を宣言する時には[]で要素数を指定し、配列の要素を使う時は[]で番号を指定するが、この2つも全く別の記号となる。
　宣言時の[]は要素数を指定するという意味を持つが、数式の中で使用する[]はアドレスに足し算する演算子となる。

・このことから、使えるメモリならばポインタ変数を配列のように使えることがわかる。
　普段はこのようなややこしいことをする必要はないが、いずれ動的メモリ確保をするようになった時に必要となる。

・このことから、配列とポインタが同じようなものに感じられるが、この2つは全くの別物となる。配列とは、多数の変数を順番付けでまとめて扱う方法であり、
　ポインタとは変数のショートカットを作る方法である。それなのに似たような使い方ができるのは配列の設計と関係がある。C言語では配列を実現する手段として
　ポインタを利用しているから。したがって、ポインタ変数では配列と同等のことができる。そのためこの2つは混同しやすいが配列はあくまでも
　多数の変数の先頭を示す固定された変数であり、ポインタ変数は好きな変数のアドレスを代入して好きなメモリ領域を使うことができる可変的な変数である。

・ポインタ変数に配列のアドレスを代入すると同じように使える、つまり[]演算子で要素番号の指定ができると記述したが、
　ポインタ変数にはポインタ変数用の書き方があり、これはポインタ演算と呼ばれる書き方で次のように書く。

　　*(ポインタ変数 + 要素番号)

　先頭にある*はポインタ変数を通常変数モードに切り替えるための演算子。かっこをつけてポインタ変数のアドレス値に要素番号分の足し算を行い、
　その足し算されたアドレス値を通常変数モードに切り替えることで、先頭アドレスから指定数だけ進んだ先のメモリにアクセスする方法。

　　ポインタ演算 = ポインタ変数に加減算を行って配列の要素を使う書き方。昔はこの書き方の方が高速だったため、広く使用された。
　　　　　　　　　 []を使わずに配列にアクセスすることができ、実行結果は[]を使った時と全く同じとなる。

・以下のように[]演算子を使って配列にアクセスする方法と、ポインタ演算を使用する方法がある。3つ目が最も高速に動作するとされているが、
　現代では多くのコンパイラが1つめや2つ目の記述でも自動的に3つ目の書き方に置き換えてコンパイルしてくれるためわかりやすい1つめや2つ目を
　使用した方が良い。ただし、これはパソコン向けに限った話であり、家電などに内蔵される低性能なコンピュータである「組み込み」の場合は
　そうとは限らないため、現代でも有用となる場合もある。

　　for (i = 0; i < 10; i++) {
        average += data[i]
    }

    for (i = 0; i < 10; i++) {
        average += *(data + i)
    }

    for (data = array; data != &array[10]; data++) {
        average += *data;
    }

・実際にプログラムを作るときはポインタ変数がアドレスを記憶する変数であることは忘れ、変数のショートカットとして使うことだけ意識する。
　ポインタ変数がアドレスを記憶するのはあくまでも仕組みであり、使い方ではないため。変数に&をつけてショートカットを設定し、*記号を付けて
　通常変数モードにして使用する。この手順に従って使う限り、アドレスは何の関係もない。

　しかし、C言語では時折非常に不可解なバグが出ることがあり、この場合の多くがポインタ変数の使い方を間違えているといった原因のため
　バグ修正の時にはポインタ変数がアドレスを記憶する変数であることを思い出し、どこかで間違ったアドレスが代入されていないかを意識する。

・同じ型の変数をまとめる場合にしようするものとして配列があるが、異なる型もまとめて扱いたい場合もある。
　そのような場合に、複数の異なる型の変数を1つにまとめて取り扱う方法として「構造体」という機能が用意されている。

　　構造体 = 複数の異なる型をまとめて作られた型のこと。

　構造体では、複数の型をまとめた新しい方を作り出すことができる。構造体タグは、関数よりも先に宣言するのが普通。
　なぜなら、そうすれば後に登場するすべての関数でこの構造体が使えるから。
　なお、C++ではstructをつけなくても構造体変数を宣言できるため現在のコンパイラのほとんどでは
　structをつけなくても動作してしまうことが多い。

・構造体変数は、元となった構造体タグで宣言されていた全ての型を持っている。配列の時には同じ型の変数を番号によって区別していたが、
　構造体変数では、型に関係なく全ての要素を名前によって区別する。構造体変数の持つ1つの要素にアクセスするには、次のようにする。

　　構造体変数名.要素名

　この様にしてアクセスした場合、普通の変数と全く同じように使える。また、同様にして配列にアクセスすることもでき、
　[]をつけて配列の各要素にアクセスすることも可能。

・上記で構造体の各要素にアクセスする方法を説明したが、実際の使い方は普通の変数と全く同じであまり意味が無いようにも思われる。
　しかし、構造体の場合、構造体変数自体を変数として取り扱うことができる。たとえば、構造体変数同士で、
　全要素を一括して代入を行うことが可能となっている。他にも、関数の引数として利用したりなど構造体変数は
　それ自体を1つの変数として使うことができ、1つ1つ代入しなければならなかった配列よりも便利。
　しかし、構造体変数同士での演算や比較は行えない。

・構造体タグを宣言してから構造体を使用する場合、構造体を使う時は必ずstructが必要となる。
　しかし、構造体タグを新しい型として1度に宣言してしまう方法がある。C言語では新しい型を宣言する「typedef(タイプデフ)」が用意されている。
　これを利用すると、構造体タグを直接新しい型にできる。今後、このような方法で宣言された型を、構造体型を呼ぶこととする。
　構造体型にすることで、型と同様に扱えるため便利なのだが、毎回typedefを使って型を定義するのは面倒。
　より簡単にするために、構造体タグと構造体型を同時に宣言してしまうことができる。さらに、この方法では構造体タグを省略できる。

・構造体型の引数も今までの引数と全く同じ方法で指定できる。ただし、typedefで宣言していない場合は、structをタグ名の前につける必要がある。

・構造体の中に配列が含まれている場合は、配列の中身もコピーされて渡される。したがって、中身を変更しても、呼び出し元の変数には
　影響しない。配列をコピーして渡したい時(たとえば、リバーシのプログラムで盤面情報を渡したい時)には、構造体にしてしまうのが一番簡単。

・構造体型のポインタ変数も作ることができる。構造体の各要素は宣言の時の順番通りに並んでおり、&演算子で求められるアドレスは
　「構造体の始めの要素のアドレス」となっている。構造体のポインタ変数の場合も*記号で通常変数モードに切り替えることができるが、
　. の方が優先されるのでかっこをつけて次のようにする。

　　(*構造体ポインタ変数名).要素名

　しかし、(*)をつけるのは面倒なので、次の書き方で代用できるようになっている。

　　構造体ポインタ変数名->要素名

　->となっているが、引き算とも比較ともまったく関係なく記号を流用しているだけ。

・普通に渡すことができる構造体をポインタ変数として渡す理由の1つめは、普通のポインタ変数と同じく関数内で値を変更できるようにするため。
　2つ目は、関数呼び出しの高速化のため。構造体を渡すとき、その中身は全てコピーされる。構造体の中に大きな配列があればその中身まで丸ごとコピーされるため
　それなりに時間のかかる処理となってしまうが、ポインタのアドレスを渡すだけなら非常に高速となる。現代のコンピュータは高速になっているため
　値渡しでもそれほど問題にはならない。慣れないうちは値渡しの方法で行うのもあり。

・構造体も配列にできる。宣言方法は型名の部分を構造体型に変えただけ。使い方も、要素番号を指定して構造体配列の要素にアクセスしたり
　その他の点もこれまでの配列の使い方と同様となる。構造体の配列があるということは、つまり内部ではポインタ変数を使っているということ。
　したがって、(*data).year、data->year、data[0].year　の3つは同じ意味となる。この3つが全く同じ意味であることを説明するには
　構造体とポインタの仕組みをしっかり理解している必要がある。

・構造体配列を引数にして関数に渡すこともできる。その場合にはこれまでの配列と同じように構造体配列の最初の要素のアドレスを渡す形となる。

・構造体の配列は、要素1つ1つに構造体が入っているような形となる。

・FILE型は構造体となっている。慣習的に、FILE型へのポインタ変数を「ファイルポインタ」と呼ぶ。

・現代のパソコンでは、同時に複数のアプリが動作できるため、もし同じファイルを同時に別々のアプリで書き換えてしまうとどちらを反映すればよいのか
　わからなくなってしまう。そこで、fopen関数で書き込みができるように開いたファイルには他のソフトで書き換えられないようロックがされている。
　fclose関数はそのロックを解除して、他のアプリから使えるようにするために必要となっている。

・ファイルを読み込みモードで開いた場合、当然だが書き込み用の関数を使っても何も起きない。追加モードで開いた場合は、
　元のファイルの最後にデータが追加される。

・ファイルには様々な種類があるが、最も基本的な区別としてテキストかバイナリか、といった違いがある。全てのファイルは本質的にはバイナリファイル。
　バイナリを直訳すると2進数という意味で、バイナリファイルとはその名の通り、2進数で記録されたファイル、要するに数値のみで記録されたファイルのことを意味する。
　それに対しテキストファイルは、文字列だけが記録されたファイル。テキストファイルは文字列で記録されているため、テキストエディタなどで修正を行うことが容易。
　バイナリファイルも特定のエディタで閲覧、修正できるが全てのデータが数値の塊になっているため中身を見てもその意味が全く分からない。しかし、数値を直接書き込むため
　サイズが少なく高速。取り扱いを容易にする必要がある場合はテキストファイル、高速性が必要とされる場合はバイナリファイルを利用することが多い。
　実際にはバイナリで開いてもテキストデータを読み書きできるし、逆も可能だが、開業の扱いなどで不便な点が多くなる。

・100を16進数に変換すると、0064となる。しかし、バイナリエディタで閲覧した結果では6400となっている。これは、インテル互換CPUの特徴で
　「リトルエンディアン」と呼ばれる表現。この表現では、16進数を2桁ずつに区切り逆の順番で保存する。一方、16進数の順番通りに表現する方式を採用する
　CPUもあり、こちらは「ビッグエンディアン」と呼ばれている。リトルエンディアンは一見わかりにくく見えるが、先頭に意味がある数値が来やすいという利点があり、
　現代ではリトルエンディアンが主流となっている。

・C言語にはアプリケーションの起動時にファイル名を渡す機能がある。それが「コマンドライン引数」と呼ばれるもの。

　　コマンドライン引数 = アプリケーション起動時に渡される文字列のこと。主に処理するファイル名や動作オプションを指定する。

　コマンドライン引数を受け取るためには、これまでvoid型としてきたたとえばmain関数の引数に
　int argc, char* argv[]のような引数を指定する。argcはコマンドラインの数、argvは文字配列へのポインタ変数。
　文字配列へのポインタ変数は　printf("%s",argv[0]);　のようにする。このようにすると、0番目のコマンドラインを表示できる。
　コマンドラインの0番目はアプリケーション自身のファイル名となるため、エクスプローラなどからドラッグしたファイル名は1番目に格納されている。

・一般的にコマンドラインにはファイル名の他に、アプリケーションの動作を指定するオプションを指定することがある。
　たとえば、windowsでファイル名を指定して実行でdefragと指定して起動すると出倉具が起動して何もせずに終了するが、
　defrag c:と指定すると、Cドライブのデフラグを開始したり、defrag c: -aと指定するとCドライブの分析結果だけを表示する。
　この例ではc:と-aという2つの文字列がコマンドラインに渡され、それをアプリケーション内で解析して動作を決定している。
　これは、コマンドラインの文字列を調べ、c:と-aというオプションの有無を解析するプログラムがある。

・実行中は変化しない値を「定数」と呼ぶ。これまでプログラム中に直接書き込んできた数値は全て定数。直接書き込まれた文字列も定数で、
　文字列リテラルと呼ばれる。プログラム中では何度も同じ数値や文字列を使うことがある。この場合、同じ値や文字列を何度も書いたり
　その数値や文字列を変更する必要が生じた場合、修正が面倒。たとえば、消費税を計算する機能の付いた電卓ソフトがあった場合に、
　突然消費税が3%から5%になったとしたら、プログラム中の0.03という数値を全て0.05に置き換えなければならない。
　もしかしたら、消費税とは別の意味の0.03があるかもしれないため、それを間違って変更しないよう1つ1つ確認しながら書き換えるのは大変。
　そこで、あらかじめ数値に名前を付けてその名前を使うようにすると、名前を付けた部分を修正するだけで全ての数値が修正され、
　名前で書かれていればただの数値よりも意味が分かりやすくなる。
　
　上記から、C言語では数値に名前を付ける方法が用意されている。それが、「#define疑似命令」と呼ばれるものである。使い方は以下の通り。

　　#define 名前 数値

　まず、#define疑似命令では文の終わりに;をつけてはいけない。また、この文はプログラムの先頭に置くのが一般的。
　また、名前には変数と同じ文字が使えるが、大文字のアルファベットが一般的。

・#define疑似命令では、数値だけでなく文字列にも名前を付けられる。使い方は数値の場合と同じだが、当然""をつける必要がある。

・C言語には#defineを使って定数を宣言する方法の他にも定数を宣言する方法がある。その1つに「const定数」として宣言する方法がある。
　const定数とは、値を変更できない変数のこと。変数を宣言する時、その先頭でconstを指定すると、その変数は宣言時に代入された初期値を
　変更することができなくなる。変数なので、#define疑似命令とは違い、関数内で宣言する。
　一般的には、定数を宣言する時には#defineを使用することがほとんどだが、特定の関数の中だけで使用する定数を宣言したい時などには便利。

　constは、他に関数の引数の型として使われることもある。これは、配列を渡すときにその値を変更させないため。

・C言語ではconst定数を配列の要素数にできないが、C++やC99では可能となっている。#define疑似命令ならどちらでも可能。

・#defineやconstの他に、「enum定数」がある。

・#define疑似命令の機能は単なる置き換えで、数値でなくともなんでも置き換えできる。たとえば定数PRINT_TEMPにprintf文を定義した場合、
　プログラム内で記述したPRINT_TEMPが変数を表示するprintf文にそのまま置き換わる。つまり、プログラム的にはその部分にprintf文を書いている
　のと全く同じとなる。これは、あらゆるプログラムを強引にまとめることができる非常に強力な機能となる。しかし、このテクニックを乱用すると
　プログラムが省略表現だらけになってしまい、最初にプログラムを書いた人にしか読めなくなってしまうため十分に注意する必要がある。

・上記の説明からわかるように#define疑似命令は非常に強力だが、さらに強力な機能が備わっている。それは、#define疑似命令で簡単な関数を
　作ってしまうことが可能となること。#define疑似命令では、名前の後に()で文字を指定すると、以後の置き換える内容で同じアルファベットの
　部分を置き換えることができる。たとえば、#define PRINTM(X) printf("%d", X)とし、int a1 = 100,a2 = 50;としてから
　PRINTM(a1)、PRINTM(a2)とするとそれぞれ違う結果が表示される。つまり、Xの値がa1やa2に置き換わった内容になる。
　この機能は簡易的な関数の代わりに使われており、「マクロ」と呼ばれている。

　　マクロ = #define疑似命令による置き換えで式などを簡単に表現すること。

　マクロの使い方は普通の関数と全く同じだが、仕組みは大きく異なる。関数の場合、その実態は1か所にあり、必要な時に呼び出されて使われる。
　しかしマクロでは使用している場所のプログラムそれ自体が置き換わり、呼び出しなどの作業が必要ないため、若干高速になる。
　しかし、マクロを使う場所全てが置き換わるので、あまり巨大なマクロを作るとそのためにプログラムのサイズが極端に大きくなることもある。
　そのため、一般的にはマクロは「決まり切った数式」などに利用される。たとえば、台形の面積を求める数式など。

・#define疑似命令によるマクロは手軽で便利だが、使い方を間違えると思わぬ現象に遭遇することがある。たとえば台形の面積を求めるプログラムにおいて
　何らかの事情で高さを常に+3しなければならない場合を考えてみると、#define D(A, B, H) (A + B) * H / 2　といったマクロを作成した際に
　s = D(up, down, h + 3)とすると、#define疑似命令は単なる置き換え命令でしかないため　D(up, down, h + 3)を(A + B) * H / 2　と置き換えると
　(up + down) * h + 3 / 2といった想定外の式になってしまう。このように、置き換えで予期しない計算結果になることを「マクロの副作用」と呼ぶ。
　これを解決する方法は2つある。1つは、呼び出し時にかっこをつけること。D(up, down, (h + 3));とかっこをつけておけば
　先に高さに3が加わるので正常に計算できる。もう1つの方法はマクロの方にかっこをつけておく方法。マクロで使われている置き換え部分全てに
　かっこをつけ、更にマクロ全体にもつける。#define D(A, B, H) (((A) + (B)) * (H) / 2)　のようにすれば全ての数値にかっこがついているので
　問題ない。しかしこのように気を付けて使用するのは面倒でうっかり忘れてしまう可能性もあるため、マクロはあまり多用しない方が良いとされている。
　#define疑似命令は定数の宣言にのみ使用し、数式などの計算にはできる限り関数を使用する方が良い。

・配列は多量のデータの取り扱いに非常に有効な手段なのだが、いくつかの欠点がありいささか実用性が低い。
　配列の最大の欠点は、要素数をプログラム中で変更できないこと。配列を宣言する時に要素数を定数で直接指定するしかない。
　たとえば、会社の社員の給料を管理するソフトを作る場合、社員の給料を記憶する配列は社員人数分以上必要となる。
　ところが、世の中には社員数人の会社から数千人の会社までさまざまあるため、要素数を10個にすると11人以上の会社では使えず、
　要素数を1万にすると、10人の会社では残りの9990個が無駄となる。その無駄な分にもメモリを使用するので
　巨大なメモリの無駄となる。このように、配列の要素数は自由に変更することができないため、メモリを有効利用するのが難しく、実用性に欠けている。

・malloc関数が返すアドレスはvoid型のポインタで、この型はどんなポインタ変数にも代入できるという型なので
　本当は(int *)にキャストする必要はないが、C++コンパイラではキャストしないとエラーが出てしまう。

・malloc関数は好きなように好きなサイズの動的配列を作ることができるため非常に便利だが、実はその仕組みはメモリにマークを
　つけているだけ。これは冷蔵庫に入っているお菓子に名前を書いておくのと同じことで、勘違いによって他の人にお菓子が食べられてしまう可能性が
　ある。malloc関数にも似たような性質があり、上手く使うのは意外に難しい。したがって、プログラムの時はできる限り普通の配列を使うようにして
　どうしても必要な部分だけmalloc関数を使うようにした方が良い。

・realloc関数を何回も呼び出すとメモリが散らかってくる。このような状態を「フラグメンテーション」と呼び、不安定になる。
　初めのmalloc関数である程度大きめに確保しておき、realloc関数を呼び出す場合も一階で大きめに確保するべき。

・malloc関数については必要な大きさの配列を作り、不要になったらfree関数で解放する。たったこれだけの説明だが、
　これこそがC言語最大の問題でもある。動的メモリ(malloc関数で作成した配列)が不要になった時に、free関数でメモリを開放することを忘れると
　そのメモリは使われもしないままずっと残り続けることになり、いわゆる「メモリリーク」となってしまう。

　　メモリリーク = 動的メモリの開放を忘れてしまうこと。長時間コンピュータを使っているうちに
　　　　　　　　　 だんだん動作が遅くなってきて再起動することになる、といった現象の原因がまさにfree関数の呼び出し忘れとなっている。

　今回記述したシンプルなプログラムであればfree関数の呼び出しを忘れないことは簡単だが、大規模や超大規模なプログラムでは
　一転して、使われているメモリともう不要になったメモリを区別することが極めて困難となる。事実上、C言語やC++言語ではこの問題を
　スマートに解決することはできておらず、膨大且つ徹底したテストによって何とか対策しているのが現状。
　そのため、Java言語など「ガベージコレクション」という自動的にメモリを解放する機能を備えたプログラミング言語が登場し、
　幅広く使用されている。

　　ガベージコレクション = 使用されているメモリを自動的に監視することでメモリリークを解決する機能。
　　　　　　　　　　　　　 ほとんどのメモリリークを自動的に解決してくれるため、現代のアプリ開発ではこの機能を備えた言語を
　　　　　　　　　　　　　 使用することが多くなった。ただし、メモリの利用効率上の無駄が多くなってしまう弱点も抱えている。

　ガベージコレクションはどうしても無駄が多くなってしまうことから、「Rust言語」というメモリの自動開放と、メモリの効率利用を
　両立できる言語も登場した。Russt言語は今最も期待されているプログラミング言語となっている。

　　Rust言語 = 所有権システムにより、メモリリークに対して根本的な対策を行った言語。凄く雑に言うと、メモリリークするプログラムは
　　　　　　　 コンパイルエラーになる言語。メモリの利用効率を全く無駄にすることなく、ほぼ完全なメモリリーク対策ができるが、
　　　　　　　 ちょっとしたミスでもコンパイルできなくなってしまうため、プログラムを記述するのがかなり疲れるプログラミング言語となっている。
　　　　　　　 しかしメモリリーク問題に対して、現時点で最も優れた言語には間違いない。今後のOSやシステムアプリはRust言語で
　　　　　　　 開発されるものが多くなることが予想される。

・規模の小さなプログラムでは1つのファイルの中に全てのプログラムを記述することは有効な方法だが、規模が大きなプログラムでは
　1つのファイルに全てを書き込んでいると、どこにどのプログラムがあるのかが分かりにくくなり、さらに何人かで1つのプログラムを作ろうとする場合には
　1つのファイルに2人以上の人が同時に書き込むことは基本的に不可能なため2人以上でのプログラミングは事実上不可能となってしまう。
　この問題を解決するには、複数のファイルに分割してプログラムを書く必要がある。

・これまで先頭に<stdio.h>と記述してきたのも、実はプログラムを複数のファイルに分割するということ。#include疑似命令は指定されたファイルの内容を取り込む
　という命令で、stdio.hはprintf関数などの様々な関数の宣言を含んでいる。ここで重要なことは、stdio.hにはprintf関数の宣言だけが書かれているだけであり、
　実際のプログラムは、stdio.hの中には書かれていないということ。printf関数の実際のプログラムは、stdio.hとは別のファイルに記述されている。

・stdio.hのような、宣言だけが書かれたファイルを「ヘッダーファイル」と呼ぶ。これに対して、実際にプログラムを記述するファイルを「ソースファイル」と呼ぶ。
　今迄に記述してきたのは全てソースファイル。なお、拡張子は.cとする。ソースファイルとヘッダーファイルは通常1対1で対応するように作成する。ソースファイルの中から
　宣言の部分を抜き出して同じ名前(拡張子だけ変える)にしてヘッダーファイルを作成する。

・今まではヘッダーファイル名を<>囲んでいたが、自分で作成したヘッダーファイルを取り込むには""で囲むことになっている。
　なお、#include疑似命令でヘッダーファイルを取り込むことを「インクルード」という。

・main.c内に含まれる関数を他のソースファイルから使う必要はないため、main.hは作成する必要はない。

・使用するコンパイラによっては、2つ以上のファイルを使用する場合にはコンパイル時パラメータで使うファイルを
　指定しなければならないものもある。

・このように別のファイルに分けておくようにすれば、sum関数を直接書き込まなくてもsum.hとsum.cのファイルをコピーして
　先頭で#include "sum.h"とするだけでsum.c内に含まれる関数を全て利用できる。sum.c内の関数がある場合を同じファイルに
　コピーするよりもすっきりするし、関数の名前と引数さえ決めておけば他の人にその関数を作ってもらってファイルを送ってもらい、
　後で一緒にコンパイルするという多人数開発も実現できる(現代ではGit一択)

・宣言には2種類の機能がある。変数や関数の宣言を行うと、コンパイラがその名前と形を記憶する。これが「宣言」と呼ばれる機能。
　そして同時に、コンパイラは実際に変数や関数を作成する。これが「定義」と呼ばれる機能。これまでの変数ではこの宣言と定義を
　常に同時に行っていた。宣言は変数や関数の形をコンパイラに教えるだけなのでその形さえ同じであれば、何回宣言しても問題ない。
　しかし定義では、関数や変数の実態を作成することになるため、同じ関数や変数が何回も作られると区別がつかなくなるためにエラーとなる。
　プロトタイプ宣言だけを記述して成功したのは、プロトタイプ宣言は宣言だけを行い、定義は行わないから。
　したがってプロトタイプ宣言は同じかきかたならいくつでも書ける。

・ヘッダーファイルにexternで変数を宣言すれば、そのヘッダーファイルをインクルードしている全てのソースファイルで
　その変数を共有することができる。しかし、extern宣言だけでは定義がされていないため、変数publicは作られない。そこで
　どこか1つのソースファイルの中で普通の宣言を行って実態を作成する必要がある。

・変数の共有は大変便利なテクニックだが、あまり乱用しないように気を付ける。本来、複数のファイルに分割するのは機能ごとに独立させるため。
　しかし、変数の共有を使用すると同じ変数が使えるようになってしまい、機能ごとに独立させる意味合いが薄れてしまう。
　したがって、可能な限り関数の引数や戻り値を利用し、変数の共有はどうしても必要な場合にのみ使用する。

・extern宣言を使用することで重複して定義されることを回避する以外にも、ヘッダーファイルの重複インクルードそれ自体を
　防ぐ方法もある。それには#ifndef～#endif疑似命令を使用する。

・関数を説明するコメントはヘッダーファイルの中に書くべきで、ソースファイルの中には書くべきではない。
　ヘッダーファイルはその関数を利用するすべての人が読むが、ソースファイルの方は誰もが読むとは限らないため。

・ヘッダーファイルは書き方が決まり切っているため、ソースファイルから自動的に生成することができるような気もするが、
　ヘッダーファイルにはソースファイルの設計書という意味もある。先にヘッダーファイルを作り、それに合わせてプログラムを作っていく。
　また、ソースファイルにはヘッダーファイルに書く必要のないそのソースファイル固有の関数や変数が使われていることもよくあるため、
　自動生成などで不要な宣言までヘッダーにしてしまうと、ある種の無駄が出てしまう。

・アーク系三角関数は普通の三角関数の逆計算をする。普通の三角関数は角度から辺の長さの割合を求めるが、
　アーク系三角関数は辺の長さの割合から角度を求める。

・普通の角度からラジアンへ変換する式は、　ラジアン = (度 * 3.14159 / 180)　ラジアンとは、円弧と半径の長さが
　等しくなる位置を1ラジアンとする角度の単位。コンピュータの世界ではほとんどの場合にラジアンを使用する。
　毎回この計算を行うのは面倒なため、#defineでマクロを作成するのがよい。

・三角関数などの計算は繰り返し行うと誤差が出てくるので注意する。

・コンピュータは非常に正確な機械のため、本質的にはランダムに数を作るということはできない。
　そこで、計算によってランダムな数を得る「疑似乱数」という手法が使われている。

　　疑似乱数 = 計算によってランダムな数値を得る方法。本当のランダムではないが、現実的にはランダムだと考えてよい。

　疑似乱数では、あくまでも計算によってランダムに見える数を作っている。しかし、実際にかなりバラバラな数値を得ることができるので
　ほぼランダムな数であると考えてよい。

・疑似乱数には様々な計算方法があるが、C言語で用意されるのはほとんどが「線形合同法」。
　簡単に説明すると、 X = 適当な数 * X(上行桁の部分を切り捨てて増加を防ぐ)　をひたすら繰り返すことで
　毎回異なる値を得る計算。この方法は単純だがそれほどランダムにはならず、何回か組み合わせて使うと同じパターンになってしまう。
　しかし、ゲームなどの用途であれば十分ランダムな値になる。

・疑似乱数は計算によるもの、つまり同じ数を元に作った場合は同じ乱数となってしまう。
　その問題を解決する方法として、srand関数とtime関数を組み合わせる方法がある。計算式は以下の通り。

　　srand((unsigned int)time(NULL));

　unsigned intという方にキャストしているが、これは符号なしの整数値といった意味。この処理はプログラムを開始する時に1回行えば十分。

・C言語では全ての周辺機器はファイルとして扱うことができる。例えば、キーボードにはstdinという名前のファイルポインタが割り当てられている。
　fgets関数のファイルポインタでこのstdinを指定すればファイルから読み込む関数がキーボード用に早変わりする。
　ここから更に数値を入力できるようにするには、atoi関数を使用する。

・アルゴリズムとは、ある問題を解くための手順、すなわち公式のこと。もう少し厳密には、明確で有限個の手順を有限回繰り返す計算方法のこと。

　　アルゴリズム = 明確に定義された有限個の規則の集まりであって、有限回適用することによって問題を解くもの。

・アルゴリズムの性能を比べる基準としては、次の基準が良く使われる。

　　計算量(少ないほど優秀)
　　メモリ使用量(少なく済むほど優秀)
　　計算の精度(正確に計算できるほど優秀)
　　プログラムの作りやすさ(簡単に作れるほど優秀)

　この中で最も注目すべき点は計算量。その他の基準はアルゴリズムによる差がさほど大きくないが、計算量だけは
　アルゴリズムが違うと天と地ほどの差があるため。

・高度なアルゴリズムほど実装には時間がかかり、バグも増えやすくなるため、プログラムの作りやすさを重視して
　多少遅くともわかりやすいアルゴリズムを選んだ方が無難なこともある。

・アルゴリズムの計算量を比較するためにコンピュータで実行して実際にかかった時間ではなく計算回数で比較したが、
　これは実行するコンピュータによって時間が変わってしまうため。性能の高いコンピュータと低いコンピュータでは
　当然高い方が早く計算でき、コンピュータとアルゴリズムの相性もあるため不公平となる。そこで、アルゴリズムの比較では
　計算回数を元にして比較する。アルゴリズムの計算で時間がかかる繰り返して処理している部分を比較すればアルゴリズムの
　計算量はだいたいわかる。しかし、計算元のデータが増えると、繰り返し回数が莫大に増加するようなアルゴリズムもある。
　したがって繰り返し回数自体を比較するよりも、計算量のデータの増加に対して繰り返し回数がどれだけ増加するかが重要となる。
　このような理由からアルゴリズムの計算量にはO記法が使われる。

　　O記法 = データ件数に対して繰り返し回数の増加を、漸近的に求めた値。

　O記法では、nこのデータに対して繰り返し回数がnに比例するならO(n)と表す。
　ただし、nこのデータに対して繰り返し回数が2nとなる場合でもO(n)と表す。
　2乗などに比べ整数倍の影響はたかが知れているため、整数倍は無視する。
　O記法ではデータ件数が非常に大きい場合の増加の度合いを最重視するため。

・O記法を使用すると、コンピュータで実行せずともアルゴリズムの性能が分かる。
　しかも、データ件数が増えるとどれだけ計算が遅くなるのかがわかるため、
　アルゴリズムの性能判断に非常に役に立つ。
　(計算量と書いてきたが正確には最大計算量。最大計算量が遅いと、計算が終わらない最悪の事態になりかねないため。)

・データ構造とアルゴリズムは切っても切れない関係にある。

　　データ構造 = 情報の表現方法のこと。

　データ構造とは、情報を記憶する時にどのような形をとるかを意味する。既に説明済みのデータ構造としては
　配列と構造体がある。配列は同じ型の変数を複数並べることで複数の情報を表現する。構造体は、異なる型の変数をまとめて
　関連性のある情報を表現する。これらは単純なデータ構造だが、いずれも普通の変数では表現が難しい情報。
　アルゴリズムでは、データを計算して答えを出さなければならないが、この時にどんな方法でデータを記憶するかは
　非常に重要。不自然な形でデータを記憶すると、その扱いに時間がかかってしまう。場合によっては、データ構造自体が
　アルゴリズムである場合すらある。

・暗号化は元のデータを変形させて、意味が分からないようにする技術。ただし、意味が分からないのでは無意味なので、
　元に戻せることが前提。元のデータに戻すことを複合化と呼び、元のデータ自体を平文と呼ぶ。暗号化の意図は、当然ながら
　第三者にデータを盗まれないため。そのため、他のアルゴリズムと異なり、何よりも暗号強度が重視される。
　いくら高速でも、簡単に解読されるアルゴリズムは使い道が限定される。

・世界で初めて暗号を使用したのは有名なシーザーであると言われている。その方法は極めて単純で、文字を数文字ずつずらすだけ。

・シーザー暗号は単純なので簡単に解読されてしまう。そこで、もう少しわかりにくくするために排他的論理和を使用する。

　　排他的論理和 = 2進数の計算で、同じ数が入力されたときに出力が0となる。

　排他的論理和では一見するとでたらめな数値になるため、暗号化に適している。
　C言語で排他的論理和を計算するには^記号を使用する。

・排他的論理和の結果は一見でたらめだが、実際には明確な規則性がある。
　これを防ぐには疑似乱数を使って規則性をわかりにくくしている。疑似乱数では初期値が同じであれば
　同じ結果を返し続けるので、パスワードから初期値を設定すれば必ず同じ計算結果を得られる。

・

================================================================================================================================

ミス履歴

・処理の最後にセミコロンをつけ忘れた
・scanfの変数の前に&をつけ忘れた
・配列の要素数を1つ少なく記述した(要素数指定の段階では純粋に何個ほしいかを指定すればよい)
・文字にしたい数字を''で囲み忘れた
・文字数配列に文字列リテラルを代入する際に、配列に[]をつけ忘れた
・文字列配列同士のコピーでコピー元の長さに考慮せずバッファオーバーランを起こした
・関数の引数のスペルを間違えていた
・!= が = になっていた
・等値演算子 == を = と使っていた
・似たようなプログラムだからとコピペした中身の変数などを変更し忘れていた
・do-whileでi++;を忘れていた
・main関数の引数をvoidに直すのを忘れておりエラーがすんごい出た
・呼び出し関数の仮引数に型名をつけ忘れていた
・scanfの指定子を間違えた(整数なのに%sを指定していた、コピペ修正忘れ)
・

================================================================================================================================

やってみたいこと

・他のファイルから構造体にデータを取り込む
・

================================================================================================================================

発見

・関数内でポインタ変数や配列の値を直接変更しつつ、戻り値もほしいとなった場合に
　戻り値を格納する変数 = 関数　といった形でプログラムを実行すると戻り値も格納されて
　値も変更されるのか試してみたところ、この一行でどちらも実行できた。

・