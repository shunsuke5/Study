java勉強メモ

・ソースファイルは開発用に作成したプログラムフォルダに保存し、
　コンパイルや実行する時はそのフォルダに移動する。
　コンパイルはjavacコマンドにソースファイル名を指定して実行する。
　何も表示されずに次のプロンプトが出てくればコンパイルは成功している。
　なお、複数のソースファイルからなるプログラムをコンパイルする場合は
　java Main.java Sub.java などのようにして全てのソースファイルを指定する方法が推奨される。

・クラスファイルの実行はクラスファイル名から.classを取り除いたものをjavaコマンドに指定して行う。

・Javaのソースコードにある波カッコで囲まれた部分を「ブロック」と呼び、
　外側のブロックはクラスブロック、内側のブロックはメソッドブロックと呼ばれ、
　Javaのソースコードは必ずこれらのブロックによる二重構造を持っている。
　メソッドブロックはmainブロックとも呼ばれる。

・Javaのソースコードを記述したファイルを保存する時には、ファイル名は「クラス名.java」にしなければならない。

・複数行コメントは /* */で記述し、単一行コメントは//で記述する。

・文の末尾には必ず;をつける。

・ソースコードに単体の文字データを記述する際は'で囲み、文字列データを記述する場合は"で囲む。

・変数の宣言と同時に代入することを変数の初期化と呼ぶ。

・b = a + 5を分解すると、変数a,bや値の5、そして+と=の計算記号に分けることができる。
　Javaを含む多くのプログラミング言語ではこのa,b,5を「オペランド(operand)」と呼び、
　+,=を「演算子(operator)」と呼ぶ。より複雑な式であっても同じで、全ての式はこの2つの要素だけで構成される。

・"を3連続で用いるリテラル表記法を「テキストブロック」と呼び、ソースコード中の改行自動的に\nが適用される。
　改行を何回も使う時に\nを使うとソースコードが煩雑になり読みにくくなってしまう時に使うと便利。
　"""に挟まれている各行は、最も左側に文字が記述されている部分が複数行リテラルの左端とみなされる。

・Javaが式に従って計算処理することを式の評価と呼ぶ。Javaは3つの単純な原則に従いながら式を少しずつ部分的に処理してゆき、
　最後には式全体の計算処理が完了する。

・原則1に「評価結果への置換の原則」がある。これは、演算子は周囲のオペランドの情報を使って計算を行い、
　それらオペランドを巻き込んで結果に化ける(置き換わる)といったもの。

・原則2に「優先順位の原則」がある。これは、式に演算子が複数ある場合はJavaで定められた
　優先順位の高い演算子から順に評価されるといったもの。

・原則3に「結合規則の原則」がある。これは、式の中に同じ優先順位グループに属する演算子が複数ある場合、
　演算子ごとに決められた方向から順に評価されるといったもの。
　全ての演算子には左から評価をするか右から評価をするかという方向が結合規則として定められている。

・代入演算子はいずれも優先順位が最低のため、基本的に代入は最後に行われると覚えておくとよい。

・++a と a++ では他の演算子のと一緒に利用した場合に加算されるタイミングが微妙に違うためバグになりやすい。
　そのため、単項演算子は単独で使うようにする。

・Javaは式を評価する過程で自動的に型を変換しているため、違う型に代入したり、違う型同士で計算しても
　文法エラーにならないケースがある。型を変換する仕組みは3つ備わっており、代入時の自動型変換、
　強制的な型変換、演算時の自動型変換がある。

・代入時の自動型変換では小さな型の値を大きな型の変数に代入する場合に限り、
　値を箱の型に自動的に変換してから代入する。たとえば、long型の値はint型変数には代入できないが、
　int型の値はlong型の変数に代入することは可能となる。

・byte型やshort型の変数に数値リテラルを代入できないと困るため、
　byte b = 3; のようにbyte型やshort型の変数に対しては、実害が無い範囲でint型リテラルを代入することだけは
　例外的に認められている。

・強制的な型変換では、キャスト演算子を用いて大きな型の値を小さな方の変数に無理やり押し込む。
　キャスト演算子は、元のデータの一部を失ってでもデータを強制的に変換しようとするため、
　情報の欠損が発生する。たとえば小数をint型に変換すると小数点以下の情報が失われるなど。
　そのためよほどの理由が無い限りは使わないものと覚えておく。

・演算時の自動型変換では、異なる方で演算を行った場合、意味的に大きな型に統一されてから演算が行われる。
　たとえば、片方のオペランドがdouble型ならもう一方もdouble型に自動的に型変換されてから演算が行われる。

・byte型とshort型は演算時にも無条件で強制的にint型に変換される。そのため、byte型の変数b1とb2を足す場合、
　byte a = b1 + b2 ではなく int a = b1 + b2 としなければならない。

・数値型と文字列型の組み合わせでは、片方のオペランドがString型なら、もう一方もString型に変換してから連結する。

・文を実行する順番を「制御構造」と呼び、代表的なものとして順次、分岐、繰り返しがある。

・制御構造を表す文のことを「制御構文」と呼ぶ。制御構文は条件式とブロックといった2つの要素から成り立っている。

・ブロックは内容が1文しかなければ、波かっこを省略できるというルールがあるが、もちろん推奨はされない。

・ブロックの中で新たに変数を宣言することもできるが、ブロック内で宣言した変数はそのブロックが終わると同時に消滅する。
　このように変数が利用可能な場所の範囲を「スコープ」と呼ぶ。変数を宣言しているはずなのに「シンボルが見つかりません」と
　エラーが出た場合、変数名のつづりやスコープを確認する。

・Javaのルールでは文字列は==では正しく比較できないことがある。
　文字列を比較したい時はequalsを使用する。

・Javaは複雑な条件式を評価する際、少し賢い動作をする。
　たとえば、if (age >= 18 && month == 5) といった条件式の場合、ageに1が入っていると
　前半部分を評価した時点で条件式全体の結果はfalseになることが確定する。そのため、後半部分のmonth == 5については
　無視して評価を行わない。Javaのこのようなふるまいを「短絡評価」と呼ぶ。

・switch文のcaseの右に複数の値をカンマ区切りで記載すると、そのいずれかに該当する時には同じ処理を実行できる。

・switch文は制御構文だが、条件によって多数のルートに処理を分岐させたうえで
　全体が異なる結果に化けるという使い方(switch式)も可能となった(p123)
　具体的には、switch文全体があるcaseの結果に化けて変数に格納されるイメージ。

・配列のようなある一定のルールに従ってデータを格納する形式を「データ構造」と呼び、
　配列以外にも「マップ」や「スタック」と呼ばれるデータ構造などがある。

・配列の要素は自動的に初期化されるため、いきなり利用してもコンパイルエラーにはならない。
　要素が初期化される値は要素の型によって決められている。intやdoubleなど数値の型は0、
　boolean型はfalse、String型はnullとなっている。

・配列と繰り返しを組み合わせた配列活用の定石としては、ループによる全要素の利用、
　ループによる集計、添え字に対応した情報の利用の3つがある。

・ループで配列の要素を順に利用することを「配列を回す」ともいう。

・Javaには配列の要素を1つずつ取り出すループを簡単に書くための特殊なfor文である「拡張for文」が準備されている。
　拡張for文ではループが1周するたびに、「任意の変数名」に指定した変数に配列の要素の内容が格納される。
　ループ変数や配列の添え字を記述する必要がなくなるため、バグが混入する可能性を低く抑えて
　すっきりとしたコードを書くことができる。

・int[] scores = new int[5] を実行したとき、まず1つめにint型の要素を5つ持つ配列がメモリ上に作成される。
　2つ目にint[]型の配列変数scoresがメモリ上に作成される。3つ目に配列変数scoresに配列の先頭要素のアドレスが代入される。
　といった流れとなっている。

・プログラムからscores[n]と指定された場合、scoresから番地を取り出し、配列(先頭要素)を見つける。
　次に、見つけた配列の先頭要素からn個後ろの要素の区画を読み書きする。と言った順番になる。
　最初に行う「配列の実体は〇〇番地にあります」と指し示す動作のことを「参照」と呼ぶ。
　メモリ上の番地を代入する変数のことを「参照型変数」という。int型やboolean型は基本型変数と言い
　参照型の変数とは区別して考える。

・変数の寿命は自分が宣言されたブロックが終了するまでだが、これは配列変数でも同じ。
　しかし、newで確保される要素は普通の変数ではないためブロックが終了しても寿命は迎えない。
　その結果、配列はどの配列変数からも参照されない状態でメモリに残ってしまう。
　残った配列はJavaのプログラムからどのような方法を使っても読み書きできず、
　事実上メモリ内のごみとなってしまう。ゴミとなった配列を放置し続けると、
　こういったごみがたまり続け、メモリを圧迫してしまう可能性がある。
　本来ならばメモリの後片付けを行わなければならないが、Javaには「ガベージコレクション」という
　仕組みが常に動いており、実行中のプログラムが生み出したメモリ上のごみを自動的に探し出して片づけてくれる。

・ある番地を参照していた配列変数にnullを代入し、参照しない状態にすることを「参照を切る」ともいう。

・メソッドとは、複数の文をまとめそれを1つの処理として名前を付けたもので、部品の最小単位。

・ソースコード中に複数のメソッドが定義されている場合、その順序には特に意味や制約は無い。
　上に記述したメソッドが先に動くといったことはない。

・メソッドの定義では、メソッドを定義する立場と、メソッドを呼び出す立場の2つの立場を
　イメージすることが重要。メソッドを定義する人はメソッドを呼び出す人のことを考え、
　わかりやすいメソッド名をつけることがとても重要となる。メソッド名が分かりづらいと
　メソッドの内容を想像しづらいだけでなく、そのメソッドを呼び出したプログラムでも何の処理をしているのか
　読み取れなくなってしまう。

・戻り値は複数用意できないので気を付ける。

・メソッドの戻り値は絶対に変数で受け取らないといけないわけではなく、
　add(add(30,40),add(50,60)) のようにも使用できる。

・return文は値を戻すだけでなく、メソッドの終了も行うため、return文の後に処理を書いても実行されない。

・メソッドに同じ名前は付けられないが、例外的に同じ名前のメソッドを複数定義する方法として
　「オーバーロード(多重定義)」がある。これは仮引数の型が異なれば同じ名前のメソッドを複数定義することが
　許される、といったもの。JVMが呼び出し元の引数(実引数)を見て、その引数の型に一致するメソッドを呼び出してくれる。
　また、仮引数の型だけでなく、個数が違う場合もオーバーロードができる。

・メソッド宣言に対するメソッド名、引数の個数やその並び順の情報をまとめて「シグネチャ」という。
　(戻り値の型は含まれない)オーバーロードはシグネチャが重複しない場合のみ許されると覚えるのもよい。

・int[]型のような配列型の変数には、配列の実体を指し示すメモリの番地が格納されているため、
　配列を引数として渡した時に渡しているのは配列丸ごとではなくアドレス情報のみであることに注意する。

・引数として通常の変数を指定した場合、メソッドに渡されるのは変数ではなく変数に入っている値。
　正確にはメソッドを呼び出した時点で変数に代入されている値がメソッドの仮引数にコピーされる。
　このように、値そのものが渡される呼び出しを「値渡し」と呼ぶ。

・メソッド呼び出しで基本型変数ではなく配列を渡すと、まずコピーされるのは配列の内容ではなく
　配列の先頭要素のアドレス(〇〇番地)となる。すると、複数の配列変数が1つの配列を参照することとなる。
　つまり、呼び出し先のメソッドで配列の内容を書き換えることができてしまう。
　この例のように引数としてアドレスを渡すことを「参照渡し」という。(厳密には参照の値渡しと呼ばれ、
　狭義の参照渡しと区別することがある。)

・戻り値にも配列を指定することができ、この場合も渡されるのは配列の先頭要素のアドレスとなる。
　戻り値で配列を返せば、複数の値を呼び出し元に返すことも可能となる。

・Javaのプログラムを起動する際、さまざまな追加情報を指定して起動することができる。
　このプログラム起動時の追加情報を「コマンドライン引数」という。
　たとえば、java Main シュンスケ 勇者 のように主人この名前と職業を指定して起動するような
　RPGプログラムなども作れる。そしてプログラムが起動すると、JVMは半角スペースで区切られた
　情報の1つ1つを配列に詰め込んで実引数とし、mainメソッドを起動する。
　よってargs[0]には「シュンスケ」が、args[1]には「勇者」が格納され、args.lengthは2となる。

・Javaで開発されたプログラムは「複数のクラスファイルの集まり」であることが多く、
　他のプログラムのようにダブルクリックで起動させるのではなく、javaコマンドで起動する。
　そのため、Javaプログラムを誰かに渡す、納品する場合は複数のクラスファイルが入っているフォルダを
　まるごと「1つの完成品」として渡すことになる。

・JVMは起動時に指定されたクラスの中にあるmainメソッドを呼び出してプログラムの実行を開始するため、
　複数の完成クラスファイルを渡す際は「mainメソッドが含まれるクラス名」も伝える必要がある。

・Javaでは複数のクラスファイルを1つにまとめるファイル形式として「JAR(Java ARchive)」が定められている。
　これはZIPファイルとよく似たアーカイブファイルで、JDKに付属するjarコマンドでも作成することができる。

・Javaには各クラスをパッケージと呼ばれるグループに所属させて、分類や管理できる仕組みが準備されている。
　package文はソースコードの先頭に記述する必要がある。

・パッケージはそのままWindowsのフォルダと同じだと考える。
　package calcapp.main ならcalcapp\main フォルダ内にそのソースコードを置かなければならない。

・Javaの部品化の流れとしては、「main()の行数が増えたら複数メソッドに分割」 → 
　「メソッド数が増えたら複数クラスに分割」 → 「クラス数が増えたら複数パッケージに分割」といった流れとなる。

・パッケージの中にパッケージを入れることはできず、パッケージに親子関係や階層関係は無い。

・package文が無くどのパッケージにも所属していない状態を「デフォルト(無名)パッケージに属している」という。
　デフォルトパッケージに属するクラスはimport文でインポートすることはできない。

・あるクラスから別パッケージのクラスを利用する場合、「パッケージ名を頭に着けた完全なクラス名」を
　使う必要がある。この完全なクラス名のことを「完全限定クラス名」や「完全修飾クラス名」
　または略してFQCNという。

・FQCNを何度もコードの随所に入力する場合、import文を使うことによってFQCN入力の手間を軽減できる。
　import文はソースコードの先頭、ただしpackage文がある場合はその後に記述する。

・javacコマンドは実行したディレクトリ直下にあるパスを検索してパッケージ名と同じディレクトリがあれば
　それを辿って目的のファイルを見つける。つまり、package calcapp.logics と記述しているのに
　calcappディレクトリでjavacコマンドを行うと、calcappが見つけられないためパッケージが見つからないと
　エラーが出る。

・import文はあくまでもFQCNの記述を省略して手間を軽減するための構文に過ぎず、
　c言語のinclude命令などのように新しい機能を有効化したり、機能が増えることは無い。

・javaコマンドを序盤のように省略して書く形にすると、たとえばjava Calcではデフォルトパッケージに
　あるはずのCalcクラスを実行しようとしてしまうため、java calcapp.main.Calc のように
　完全限定クラス名を指定して実行するとよい。

・JVMが内部に持っている「クラスローダー」は、完全限定名を指定されたらその名前を持つクラスのクラスファイルを
　PC内から検索し、JVMに読み込んで利用可能にするという役割を担っている。
　たとえば、クラスローダーに対してJVMがcalcapp.main.Calaを利用するから読みこんで利用可能にしてという
　指示を出すと、クラスローダーはコンピュータのハードディスク内のどこかのフォルダにおいてあるCalc.classを探し出し、
　それを読み込む。この時、JVMは使いたいクラス名を指定しているだけであって、クラスファイルが置いてあるフォルダの場所を
　一切指定していない点に着目する。Calc.classと言う姥久手区のクラスファイルはc:\にあるかもしれないし、c:\Program Files\
　にあるかもしれない。しかし、クラスローダーは膨大な容量を持つハードディスクの中から一瞬でCalc.classファイルを
　探し出して読み込んでくれる。なぜこんなことができるかというと、クラスローダーは「クラスパス」と呼ばれるヒント情報を
　使って極めて高速に目的のクラスファイルを探し出すため。
　クラスパスとは、クラスローダーがクラスファイルを探す際に見に行くべきフォルダの場所で、
　あらかじめ1つ以上のクラスパスを指定しておく。たとえばクラスパスとしてc:\workが指定してある場合、クラスローダーはc:\workの中に
　Calc.classがあるかを探しに行くだけでよいため高速に検索できる。このようなクラスローダーの働きによって
　我々はjavaコマンドにクラス名だけを指定してJavaプログラムを実行することができる。

・クラスパスの指定方法には次の3つの方法がある。1つめは起動時にjavaコマンドの-cpオプションまたは-classpathオプションで指定する。
　java -cp c:\work Calc のようになる。2つ目は検索場所をOSの環境変数に登録しておく。
　3つ目は特に指定しない場合、javaコマンドが実行されたフォルダがクラスパスとなる。
　たとえば、c:\workでjavaコマンドを実行すれば、c:\workがクラスパスに設定される。

・クラスパスとして指定することができる物は次の3つとなる。1つめはフォルダパスで、c:\workのように指定すると
　workフォルダ内のクラスファイルが検索対象となる。2つ目はクラスファイルが入ったJARファイルやZIPファイルで、
　そのファイルの場所(絶対パス)をクラスパスとして指定できる。この場合は指定するパスにファイル名も含む。(c:\work\jars\calcapp.jarのように)
　3つ目は複数のフォルダ、JAR/ZIPファイル、それらの組み合わせで;を用いて区切って指定する。
　(Linuxやmacの場合は:) そのため、クラスは作ったのにプログラムが上手く起動できないときは
　クラスパスを確認する癖をつけるとよい。

・パッケージに対するクラスローダーの動作としては、パッケージx.y.zに属するクラスCが対象なら
　「クラスパスで指定されたフォルダ\x\y\z\C.class」を探す、といった動作となる。

・大規模な開発現場では、複数の開発者が分担して各自が受け持ったクラスを開発する。すると、それぞれの開発者が
　偶然「同じクラス名を使ってしまう」可能性が出てくる。このように内容が異なる別々のクラスで同じ名前を取り合うことを
　「名前の衝突」という。しかし、Javaではパッケージが異なれば同じクラス名を使ってよいルールになっているため、
　パッケージの利用によってそれぞれのパッケージの中ではクラス名を自由に決められる。

・Javaでは自社と他社でパッケージ名が重複しないように自社が保有するインターネットドメインを
　前後逆順にしたものから始まるパッケージ名の使用を推奨している。たとえばfoo.example.com という
　インターネットドメインを取得している企業であればcom.example.fooで始まるパッケージ名を使用する。
　インターネットドメインはそれぞれの組織ごとに世界で1つだけなので、パッケージ名が重複することは無い。

・最初に動かしたHelloWorldプログラムをjava -verbose:class Main と実行するとHelloWorldプログラムが
　動作するためにJVMに読み込まれたクラスの完全限定クラス名が数百行にわたって表示される。
　つまりHelloWorldプログラムとは、我々が作った1つのプログラムが他の数百個のクラスと連携して動く
　多数のクラスからなるプログラムだったのである。我々が作った1つのクラスを除く他の数百個のクラスは
　Javaに初めから存在するクラスであり、それらは「API(Application Programming Interface)」と総称される。
　JavaではAPIとしておよそ200を超えるパッケージ、3500を超える多くのクラスが標準提供されていて、
　我々はそれらのクラスをいつもで自由に利用できる。入力や乱数などで出てきたjava.utilは正にその一例。
　5つの要素を持つint型配列に入っている5つの整数を並べ替えるプログラムを開発する場面を想定したときに、
　並び替えのロジックを自力で開発するのは少し大変だが、わざわざ開発しなくても
　java.util.Arrays.sort(heights); というようにAPIを呼び出せばすぐさまこのロジックが使用できる。
　このコードは「java.utilパッケージのArraysクラスにあるsortメソッド」であり、
　「java.util.ArraysはJavaが標準で提供するAPIの一部であること」が理解できる。
　実際にAPIに含まれる3500を超えるクラスはそれぞれクラスファイルの形でJDKをインストールしたときに
　コンピュータに保存されている。これらのクラスファイルもJava言語を作った人たち(多くが海外の技術者)
　がソースコードを書き、コンパイルして作ったもの。

・APIのクラスには「java.」または「javax.」で始まるパッケージ名が利用されている。以下が代表的なパッケージ。

　java.lang → Javaプログラミングに欠かせない重要なクラス群。
　java.util → Javaプログラミングを便利にする様々なクラス群。
　java.math → 数学に関するクラス群。
　java.net → ネットワーク通信などを行うためのクラス群。
　java.io → ファイル読み書きなど、データを逐次処理するためのクラス群。

　この中でも、java.langパッケージに属するクラスは頻繁に利用する物が多いため、
　import文を記述しなくても自動的にインポートされるという特別扱いを受けることになっている。
　java.langパッケージに属する代表的なクラスにはSystem,Integer,Math,Object,String,Runtime
　などがある。System.out.println の System も java.lang.System クラスとなる。

・JavaのAPIクラスを調べるには「APIリファレンス」と呼ばれる説明書を読む必要がある。
　「Java API 仕様」などのキーワードで検索すると、Java SE 17 API仕様 といったタイトルの
　Webページが見つかる。数字はJavaのバージョンを示しているため、自分が利用しているバージョンの
　ページを探して閲覧する。

・Javaのクラスローダーは必要なクラスだけを必要になったときにロードするしくみのため、
　動作が遅くなったりメモリがパンクするのではといった心配は無用。

・1970年代、様々なプログラム言語が登場し、これによって大規模なプログラムの作成が理論上は可能となっていた。
　しかし、いざ大きなプログラムを記述しようとすると開発に時間がかかったり、完成しても不具合だらけのプログラムになったり
　してしまうことが少なくなかった。その原因はコンピュータの性能ではなく、大規模なプログラムに人間の頭が追いつかず、
　人間自身がプログラム開発のボトルネックになってしまうことにあった。

　そこで誕生したのが「オブジェクト指向プログラミング」という考え方だった。
　オブジェクト指向を用いると「ラクして、楽しく、良いものを」作れるといったメリットがある。

・これまで行ってきたような従来のプログラミング手法は「手続き型プログラミング」と呼ばれており、
　開発者が頭を捻り、コンピュータがどのように動けばよいかという手順を考え、
　プログラムの先頭から順番に命令として記述していく方法。
　一方、オブジェクト指向で開発を行う場合、プログラマはいきなりコードを書き始めることはしない。
　まず、プログラムで実現しようとする部分の「現実世界」を観察する。たとえば、銀行振り込みの手続きを
　プログラム化する際には銀行窓口での取り扱いを観察してp268のようなイメージ図を描く。
　ここで着目するのは、この設計図はITの知識がない一般の人に見せても理解できる
　「現実世界における銀行取引の構図そのもの」ということ。そして、設計図の中の登場人物や
　物の1つひとつを部品と捉え、それを「クラス」というJavaにおける部品で記述していく。

・開発者が作成する部品(クラス)とは、たとえばATMのプログラムであればUketsuke.javaのようなファイルとして
　PCに保存され、プログラムとして実行されるとそれぞれ「仮想的な登場人物」のオブジェクトとしてJVMの中に
　その存在が生み出される。そして「仮想的な口座」「仮想的な受付」「仮想的な印刷担当」などが
　JVMという「電子的な仮想世界」の中に作られ、現実世界をそっくりまねた「Java仮想世界」とでもいえるような世界を形成する。

　オブジェクト指向プログラミングにおいて開発者はまるで「Java仮想世界における神様」のような存在となる。
　なぜなら仮想世界にどんな登場人物や物を生み出し、それらをどのように連携させるかを決め、それぞれの部品を作っていく立場だから。
　たとえば国内の複数の倉庫に在庫のある書籍をインターネットで販売するプログラムを作るなら、本の販売業務を観察したうえで
　「必要な者(オブジェクト)」は本、倉庫、顧客、購入記録…と判断し、設計図を書いていく。

　手続き型プログラムのように「コンピュータが実行すべき手順を1行ずつ定める」ではなく、
　「オブジェクトをどう作るか、どのように連携させるか」を第一に意識しながら開発していく。
　このことが「オブジェクト指向プログラミング」という名前の由来になっている。
　〇〇指向というのは、〇〇を大切にした、〇〇を中心に据えた、といった意味。

・「なぜオブジェクト指向の考え方を使うと、大規模で複雑なプログラムも把握しやすくなり、その結果ラクして楽しく良いものを作れるのか？」
　この問いの答えは

　「私たち人間が慣れ親しみ、よく把握している現実世界をマネして作られたプログラムもまた、私たち人間にとって把握しやすいものだから」

　さらにオブジェクト指向には以下のメリットがある。
　プログラム開発時に「手続きを想像して作る」必要はない。現実世界をお手本に、それをマネして作ればよい。
　現実世界の登場人物に変化があった場合、対応する部品(クラス)を修正、交換すれば簡単にプログラムを修正できる。
　このようなメリットは「現実世界をマネる」からこそ生まれてくる。

　つまり、「現実世界の登場人物たちを、コンピュータの中の仮想世界にオブジェクトとして再現し、
　現実世界と同じように連携して動くようにプログラムを作ること」こそがオブジェクト指向の本質となる。

・オブジェクト指向プログラミングでは開発者はそれぞれの部品に「責務」をプログラムとして書き込む。

・たとえば、サッカー選手オブジェクトでは「ボールを受けたら前に走る」「シュートする」などあらかじめ設定された
　役割を果たす「行動責任」を負っている。同様にATMの受付オブジェクトにも振込依頼を受け付けたら口座オブジェクトが管理する
　2つの口座間でお金を移動し、その結果を印刷係オブジェクトに渡してATM利用控えの印刷を依頼するという一連の流れが
　受付の「行動責任」となる。この時、口座オブジェクトはいったいどんな責任を負っているのか？
　口座オブジェクトは行動責任を負ってはいないが、残高をしっかり覚えておくという「情報保持責任」を負っている。

　このような「情報保持」と「行動」の責任を果たすためにそれぞれのオブジェクトは「属性」と「操作」を持っている。
　属性 = その登場人物に関する情報を覚えておく箱
　操作 = その登場人物が行う行動や動作の手順

　RPGにおける「勇者」という登場人物は、自分の名前やHPをしっかり覚えておかなければならない(情報保持責任)
　もし戦えと命令されれば目の前の敵と戦い、眠れと命令されれば眠ってHPを回復させる責任(行動責任)がある。
　そのオブジェクトがどんな属性や操作を持つかは開発者が部品を作成する際に決定する。そのためには現実世界の登場人物を
　よく観察し、どのような属性を持ち、どのような操作ができるかを忠実に再現する必要がある。

・RPGを例にして考えると、勇者や敵キャラは複数の操作を持っている。そしてmainメソッドや他のオブジェクトから
　それらオブジェクトの操作を呼び出す(行動指示を送る)ことができる。
　たとえばmainメソッドから勇者に座れと指示を出せば勇者は仮想世界で座ってHPを回復させる動きをし、
　同様にお化けキノコに対して逃げろと指示を出せば仮想世界のお化けキノコは逃げ出して戦闘が終了する。

　また、あるオブジェクトから別のオブジェクトへ操作の指示を出す例としては、
　mainメソッドからお化けキノコに催眠ガスの指示を出すと、お化けキノコは勇者が持っている操作の中から
　眠るを呼び出し、勇者は眠ってしまう。

　オブジェクトは別のオブジェクトが持つ操作を呼び出すだけでなく、他のオブジェクトの属性を取得したり書き換えたりもできる。
　たとえばmainメソッドから勇者に戦う指示を送ると、勇者は戦い、結果としてお化けキノコのHP属性を書き換えて減らす動作をする。
　このように考えると、コンピュータの中の仮想世界で各オブジェクトが互いの属性を書き換えたり操作を呼びあったりして
　物語を繰り広げて行く姿がイメージしやすい。そして、仮想世界の中で仮想的な受付や仮想的な口座が現実世界同様に
　正確に動いてくれるからこそ、現実世界の本物の受付係や神の口座帳簿は仕事から解放され、
　コンピュータによる自動化が可能となる。

・オブジェクト指向の本質はあくまでも「現実世界を仮想世界に再現すること」。よって口座や受付と言う単位で
　クラスを分割して適切な責務を与えたプログラムであれば、それだけで十分オブジェクト指向の考え方に沿ったプログラムと言える。

　さらにJavaのような「オブジェクト指向言語」、つまりオブジェクト指向の考え方に沿ってプログラムを作りやすい配慮がなされている
　プログラミング言語には、開発者が「より便利に」「より安全に」現実世界を模倣できるよう、文法などに専用の機能が準備されている。
　それが「継承」「多態性」「カプセル化」といった「オブジェクト指向の三大機能」となる。

　「継承」は、過去に作った部品を流用し、新しい部品を簡単に作れる機能。すでに勇者という部品があれば
　空を飛べるスーパー勇者は簡単に開発できる。
　「多態性」は、似ている2つの部品を同じような物とみなし、いいかげんに利用できる機能。敵キャラそれぞれで厳密には攻撃の仕方が
　微妙に異なるはずだが、違いを気にせずどちらも同じようなものとみなし、「戦う」操作で攻撃できる。
　「カプセル化」は、属性や操作を一部の相手からは利用禁止にする機能。現実世界では
　剣が勇者に「眠れ」という指示を出すことはない。そのため「眠る」操作は剣オブジェクトから呼べないようにしておいた方が安全。

・Javaでは仮想世界の中で動くオブジェクトそのものを開発者が直接定義することは許されない。その代わりに開発者は、
　オブジェクトが生み出される際に用いられる「オブジェクトの設計図」である「クラス」を定義できる。
　そのためオブジェクト指向の考え方に沿ってプログラムを開発する手順としては
　1．クラスを定義する。
　2．そのクラスに基づいてオブジェクトを生成する　といった手順になる。
　なぜオブジェクトを直接定義できずにクラス定義→オブジェクト生成の方式を採用しているかと言うと、
　同じオブジェクトを大量に作る必要がある場合、そのオブジェクトそれぞれに対して属性などの定義を繰り返すとしたら
　作業が膨大なものとなってしまうが、「属性として残高、名義人、開設日があって…」と定義した「口座クラス」を1つだけ作っておけば
　このクラスから必要な数だけオブジェクトを生み出すことができるため。

・実際の開発現場における会話や文章の中で単に「オブジェクト」という表現が用いられる場合、クラスか、オブジェクトかを
　厳密に区別しないことがある。もし厳密に区別する場合クラスから生まれたオブジェクトのことを「インスタンス」と呼ぶ。
　また、クラスからインスタンスを生成する行為を「インスタンス化」と表現する。

・各オブジェクトに指示を出すmainメソッドだけは現実世界の登場人物を模したものではなくインスタンス化して利用するものではない。
　あくまでも仮想世界の神様としてそれぞれの登場人物を生み出し、それらに対して指示を出す役割を担っている。プログラムを作る場合には
　「登場人物のクラス」と「指示を出す神様のクラス」の2種類を作る必要があることを意識する。

・p292の図のように、クラスに「どのような属性や操作を持っているか」を上から一覧として並べる書き方は
　「クラス図」と呼ばれる設計図のルールに準じたもの。

・属性用の変数など、クラスブロック内に宣言された変数を、Javaでは特に「フィールド」という。
　フィールド宣言と同時に値の代入も記述すると、そのフィールドの初期値を設定できる。
　さらに、フィールド宣言の先頭にfinalをつけると、値を書き換えられない「定数フィールド」となる。
　定数フィールドは一目見てわかるように大文字の記述が推奨される。

・「操作」を定義するには、「操作の名前」「操作する時に必要な情報の一覧」「操作の結果として指示元に返す情報」
　「処理内容」の4つを考える必要がある。たとえば「眠る」操作の具体的な要素として次のように考えたとする。
　名前 → sleep、必要情報 → なし、結果 → なし、処理内容 → HPが100に回復する

・フィールドとメソッドは「メンバ」と総称される。そしてクラス名は「名詞」で「単語の頭が大文字」、
　フィールド名とメソッド名は「最初以外の単語の頭が大文字」でフィールド名は「名詞」、
　メソッド名は「動詞」とするのが望ましいとされる。

・同じクラスのフィールドにアクセスする場合、this.を省略しても動作はするが、
　ローカル変数や引数にも同じ名前の変数があるとそちらが優先されてしまうなど予想外の動作をする可能性がある。
　フィールドを指示するときには、明示的にthisを付けるようにする。

・Heroクラスを定義するとHero型の変数が利用できるようになる。
　このように、クラスの定義によって利用可能になる型を「クラス型」という。

・インスタンスは通常、クラス型変数に入れて利用する。クラス型変数を用いる理由としては、仮想世界に複数存在しうる
　同名インスタンスの中から特定の1つのインスタンスをプログラムとして識別するため。

・勇者に指示を出すプログラムコードを手続き型とオブジェクト指向型で見比べると、オブジェクト指向型は
　HPを増やしたり減らしたりする計算や、画面に表示するメッセージの指示がmainメソッドに一切出てこない。
　mainメソッドに記述されているのは勇者を登場させて座れ、転べ、逃げろといった指示だけ。それにもかかわらず
　動作結果として勇者が行動するたびにHPの増減が処理され、画面には10行表示され、最終的なHPが125であることが
　正しく出力できている。小規模な例ではあるが、「オブジェクト指向を使うとプログラムが把握しやすくなる」ことを体験できた。

・第Ⅰ部のクラスと第Ⅱ部のクラスは、どちらも同じ public class クラス名 で宣言されたクラスであり、文法的には
　どちらも正しいクラス。しかしこの両者には「クラスを何のために用いるか」という「思想が伴っているか否か」に
　決定的な違いがある。第Ⅰ部のクラスでは何を基準にクラスとするか、何を基準にメソッドとするかという明確な思想はなかった。
　強いて挙げるなら「そろそろメソッドが大きくなってきたので分割しよう」あるいは
　「この機能のメソッドはこのクラスにまとめておこう」などという「開発者の都合や機能の単位に即して」クラスやメソッドを作った。
　一方、第Ⅱ部のHeroクラスなどは「オブジェクト指向」という明確な思想に基づいてクラスやメソッドが作られている。
　すなわち現実世界の登場人物を1つのクラスとして捉え、その登場人物の持つ属性をフィールドに、
　そして操作をメソッドとしてコードを書いた。第Ⅰ部で「現実世界とは無関係のクラス」のみを取り扱ってきたが、
　この章で初めて「現実世界と意味がつながったクラス」に出会ったのである。これが第Ⅰ部と第Ⅱ部のクラス間で
　印象が違うと感じた理由となる。オブジェクト指向を意識したプログラム開発とは、「現実世界の人や物、
　出来事をクラスに置き換えていく作業」にほかならない。

・「プログラム化の対象となる現実世界」のことを専門用語では「ドメイン」という。そして、オブジェクト指向は
　このドメインが複雑で大規模な時に、特にその威力を発揮する道具となる。逆に言えば、とてもシンプルなドメインを扱う開発や
　小規模なプログラム開発ではオブジェクト指向の考え方を使うまでもないケースも存在する。たとえば、単純なデータ変換や
　保存のツールを作る程度であれば、手続き型の利用に合理性がある。しかし、Javaを学習すれば次の理由から
　オブジェクト指向の考え方も手札として揃えておくのは決して損にはならず、可能性を広げていくことにもつながる。

　1．近年、シンプルで小規模な開発にはJavaではない、より軽量なプログラミング言語の利用が増加しており、Javaを用いる場合は
　　 複雑で大規模なドメインを扱う可能性が高い。
　2．大規模な開発において、個々のプログラム単体はシンプルで小規模に抑えつつ、システム全体ではそれらを複雑に連携させる
　　 方式が採用される場合も、全体設計の検討や構築に「オブジェクト指向の考え方や経験」は役立つ。
　3．「オブジェクト指向の考え方」は、概念を学ぶだけではなかなか理解しづらく、実際にプログラミングして動かしてみるのが
　　 習熟の近道である。
　4．選択肢の1つとしてオブジェクト指向を知っているからこそ、それを「使うべき状況」「避けるべき状況」を
　　 合理的かつ主体的に判断し、自信をもって実践できる。

・HPやMPを回復する際は、あらかじめ定数として決めたMAX_HPをhp変数が超えないように
　math.min(this.MAX_HP - this.hp,回復量); のように計算を行う。

・これまで「Java仮想世界」と表現してきたものは、実際には「コンピュータのメモリ領域」である。
　この領域はJavaプログラム実行時にJVMがメモリ領域を大量に(通常は数百MB～数GB)使って準備するもので「ヒープ」という。
　そして、我々がnewを用いてインスタンスを生み出すたびにヒープの一部領域(通常は数十～数百バイト)が確保され、
　インスタンスの情報を格納するために利用される。そのため、多くの属性を持った大きなクラスをインスタンス化すると、
　消費されるヒープ領域は必要とする用量に従って大きくなる。つまりインスタンスとは、
　「ヒープの中に確保されたメモリ領域」にすぎない。

・クラス型変数とその内容は以下の3ステップで行われる。
　1．Hero型変数の確保 → 「Hero h;」
　2．Heroインスタンスの生成 → 「new Hero();」
　3．参照の代入 → 「h = new Hero();」
　4．フィールドへの値の代入 → 「h.hp = 100;」

　Step1では、Hero h;のようにクラス型変数を確保するコードが実行されると、JVMは「Hero型の変数h」をメモリ内に準備する。
　JVMは広いヒープ領域の中から現在利用していないメモリ領域を探し出して、確保してくれる。
　仮に1928番地が空いていたのでここが変数h用に確保されたとする。この段階ではまだ勇者自体は生まれていない。
　「Hero型のインスタンスだけを中に入れることができる」Hero型の箱が準備されるだけ。この箱には数値や文字列を
　入れることはできず、Hero型でないお化けキノコインスタンスを入れることもできない。

　Step2では、h = new Hero();のnew Hero(); の部分から評価されるためこの部分に焦点を当てる。
　new Hero();が実行されると、JVMはヒープ領域から必要な量のメモリを確保する。今回は仮に3922番地から24バイト分
　(3922～3945番地)が確保できたとする。これで勇者と言う存在が仮想世界に生まれた。しかし、まだHeroインスタンスの
　「名前」は空っぽ、「HP」は0である。

　Step3では、new Hero();によって生み出された勇者インスタンスが変数hに代入される。
　これまで変数hに入るのは「勇者インスタンス」だと紹介していたが、より厳密には勇者インスタンスの情報が書き込まれた
　「メモリの先頭番地」が入る。今回の場合、new Hero();により、勇者インスタンスが3922～3945番地に生成されているので
　「変数hには3922という数値が代入」される。変数hに入っている3922は、ただの数値に過ぎない。Heroインスタンスに関する
　名前やHPなどの様々な情報は変数hの中ではなく、別のところにある。これは見方を変えれば、「この変数hにはHeroインスタンス
　の情報の全部は入りきらないから、詳しくは3922番地を参照してね」と解釈できる。
　このことから、変数hに入っているアドレス情報を「参照」という。int[]型やString[]型といった
　「配列型」も変数に入っているのは配列内の各データが保存されているメモリ領域の先頭番地だった。
　Hero型のような「クラス型」も同じとなり、このことからクラス型と配列型は総称して「参照型」と呼ばれる。

　Step4では、h.hp = 100;によって変数hに格納されている勇者のHPを100に設定する。
　この行をJVMは以下のように解釈して実行する。
　1．変数hの内容を調べると、「3922番地を参照せよ」と書かれている。
　2．メモリ内の3922番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える。
　このように、まず変数から番地情報を取り出し、次にその番地にアクセスする、というJVMの動作を「参照の解決」や
　「アドレス解決」という。

・仮想世界に勇者が2人生成され、それぞれh1,h2という変数に格納されていたとする。
　当然、勇者h1のhpフィールドを10減らしても、勇者h2のhpフィールドの値は減らない。同じクラスから生まれても、
　異なるインスタンスであれば互いに影響を受けないことを「インスタンスの独立性」という。

・いくつかの特殊な例を除いて基本的にインスタンスを生み出す方法はnewしかなく、new Hero()した回数が勇者の人数となる。

・フィールドにクラス型の変数を宣言することもできる。「あるクラスが別のクラスをフィールドとして利用している関係」を
　「has-aの関係」といい、p324のような図で表すことができる。has-aと呼ぶ理由は、
　「Hero has-a Sword(勇者は剣を持っている)」というような英文が自然に成立するため。

・クラス型はフィールドの型に用いるだけでなく、メソッドの引数や戻り値の型としても利用できる。
　これを確認するために、勇者クラスに加えて魔法使いクラスを作ってみる。魔法使いは勇者のHPを回復する魔法を使うことができる。
　public void heal(Hero h) {h.hp += 10;} のようなメソッドを作り、このhealメソッドが呼び出されると魔法使いインスタンスは
　勇者のHPを10回復させる。ただし、仮想世界には勇者が2人以上生み出されている(2回以上newされている)可能性もあるため、
　呼び出される時に「どの勇者を回復するのかを引数hとして受け取る」必要がある。

・String型は、実はint型やdouble型の仲間ではなく、Hero型と同じ「クラス型」である。これまで、「String型変数の中には
　文字列がそのまま入っている」と解釈していたかもしれないが、実際にはStringインスタンスである文字列の
　先頭番地が変数に入っている。Hero型やSword型は我々自身がHeroクラスやSwordクラスを定義したので利用可能になった。
　しかし、Stringクラスを定義していないにもかかわらず、我々がString型を利用できるのはなぜか？この答えはAPIリファレンスが
　明らかにしてくれる。MathクラスやSystemクラスのようにAPIとして標準添付されている膨大な数のクラスの中に
　Stringクラス(正式名称はjava.lang.Stringクラス)が含まれているため。
　java.langパッケージに所属しているためimport文を記述する必要が無く、単に String s; と書けば利用できるようになっていたり、
　通常、インスタンスを生成するにはnew演算子を利用する必要があるが文字列はプログラムの中で多用されるため、
　ソースコードがnewだらけになるのを防ぐために「二重引用符で文字列を囲めばインスタンスを生成して利用できる」ようになっていたり
　Javaと言うプログラミング言語が作られる時にこれらのような特別の配慮がされた。
　Stringもクラスには違いないため、newでインスタンスを生成することもできる。その場合以下のような記述となる。
　String s = new String("こんにちは");
　Stringクラスはnewするとき、ついでに追加情報を指定できる特別な仕組みに対応している。
　Stringはインスタンスが生成された直後に、追加情報("こんにちは")を自分自身の中に書き込む。

・これまではnewでインスタンスを生成した直後、必ずフィールドの初期値を代入するプログラムを記述していたが、
　これは煩わしく、さらに大規模な開発において自分以外の開発者がHeroクラスを利用する場面も考えておかなければならない。
　うっかり初期化し忘れるかもしれないし、負の数や非常に大きな数で初期化してしまうかもしれない。これではゲームは正しく動作しない。
　「勇者の初期HPがこの数値であってほしいこと」は、Heroクラスの開発者が一番よく知っているはず。
　逆に、Heroクラスを使う側にとっては「初期値が何であるか」は知らないのが当然ともいえる。そのため、Heroクラスを作る側で
　責任を持つべきという主張はもっともな話である。このような場合に備え、Javaでは「インスタンスが生まれた直後に自動実行する処理」
　をあらかじめ定義できるようになっている。

・厳密に言うと、newで生成直後のインスタンスのフィールドには値が「入っていない」わけでなく、次のような初期値が設定されている。

　int,short,longなどの数値の型 → 0
　char型 → \u0000
　boolean型 → false
　int[]型などの配列型 → null
　String型などのクラス型 → null

・HeroクラスにHero()というメソッドを追加し、this.hp = 100; とする。attack()などの通常のメソッドは
　誰かから呼ばれないと動かないが、Hero()だけはHeroクラスが「newされた直後に自動的に実行される」という特別な性質を持っている。
　このようなメソッドを「コンストラクタ」と呼ぶ。Hero()はコンストラクタとして定義されており、newされると自動的に実行されて
　HPに100が代入される。そのため、mainメソッド側でHPに初期値を代入する必要はない。コンストラクタはインスタンスの生成時に
　JVMによって呼び出されるものであり、開発者がプログラムで直接呼び出す手段は用意されていない。

・次の条件をすべて満たすメソッドだけがコンストラクタとみなされ、自動実行される決まりになっている。
　1．メソッド名がクラス名と完全に等しい
　2．メソッド宣言に戻り値の型が記述されていない(voidもダメ)

・HPに100などの固定地を代入するだけならコンストラクタを用いずにフィールド宣言を int hp = 100; としても対応できる。
　しかし勇者の名前は生み出すインスタンスによって異なるため、こういったケースではコンストラクタが「毎回異なる追加情報」を
　引数で受け取れるように宣言する。

・我々は直接コンストラクタを呼べないため、引数を直接渡すことはできない。しかしJVMに対してnewするときに
　「コンストラクタを呼ぶときはこの情報を使ってね」とお願いすることができる。
　この処理は以下のような順序となる。

　1．Hero h = new Hero("shunsuke") のようにnewする
　2．仮想世界にインスタンスが生まれる
　3．JVMによって自動的にコンストラクタが実行される。この時引数として「shunsuke」が利用される。

　特に1で指定したものが3で利用されている、といった点がポイントとなる。

・現在のHeroクラスには「文字列の引数を1つ受け取るコンストラクタ」が定義されている。そして、コンストラクタはnewされたときに
　必ず自動的に実行されるものなのでnewする側としては必ず引数となる文字列を1つ与える必要がある。
　つまり、このコンストラクタを作ったことによって「インスタンスを生成するときには、必ず名前を指定する必要が生じる」こととなる。
　この問題は「引数を受け取らないコンストラクタ」も同時に定義すれば解決できる。
　複数のコンストラクタが定義されていた場合、newする時に渡した引数の型、数、順番に一致するコンストラクタ1つだけが動作する。

・コンストラクタのないHeroクラスは new Hero(); で生成できたのに、引数有コンストラクタの定義でこれが不可能になったのはなぜか？
　Javaでは、全てのクラスはインスタンス化に際して「必ずコンストラクタを実行する」決まりになっている。
　そのため、本来は「全てのクラスは最低でも1つ以上のコンストラクタを持っていなければならない」といったこととなる。
　しかし、わざわざ中身のないコンストラクタを定義するのも面倒なため、Javaでは次の特例を設けている。
　クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理内容なし」の
　コンストラクタ(デフォルトコンストラクタ)がコンパイル時に自動的に追加される。
　コンストラクタを定義する前のHeroクラスは、この特例によって引数なしのコンストラクタがこっそり自動的に定義されていたため、
　new Hero();によるインスタンス化が可能だった。しかし、新たに引数を1つ含むコンストラクタを定義した時点でこの特例は適用
　されなくなり、new Hero();によるインスタンスの生成はできなくなったというわけである。
　このデフォルトコンストラクタは「継承」と作用して複雑なトラップが発動することがある。

・複数のコンストラクタを作ると、内容が重複することが多く、将来この内容に変更があった場合
　それぞれのコンストラクタの内容を修正する必要が生じてしまい面倒になる。そこで思いつくのが、
　コンストラクタの中で違うコンストラクタを呼び出す方法となる。しかし this.Hero("shunsuke"); のように記述すると
　コンストラクタを呼び出せるのはJVMだけであり我々は直接呼び出せないためエラーとなってしまう。
　しかしthis(引数);とすることによってJVMにコンストラクタの起動を依頼することができる。
　この分はコンストラクタの先頭に記述し、同じクラスのコンストラクタが対象となる。]
　このthis()はthis.メンバ名のthisと似ているが何の関係もない別物と考えた方が良い。
　this.メンバ名のthisは自分自身のインスタンスを表すもの、this(引数)のthis()は同一クラスの別コンストラクタを呼び出すためのもの。

・Javaで大きなプログラムを作り始めると、「以前作ったクラスと似通ったクラスを作る」必要に迫られることがある。
　ほとんど同じだけどフィールドが2つほど多い、ほとんど同じだけれどメソッドが1つ多いなど。元のクラスを丸々コピペして
　追加すれば簡単に元のクラスを発展させることができるし、コードも問題なく動作するが、この方法によって作成された
　クラスには2つの問題がある。1つ目は追加、修正に手間がかかること。元のクラスを変更する場合、
　派生クラスにもその変更を行う必要がある。なぜなら派生クラスはいわば「進化系」だから、元のクラスができることは
　当然派生クラスもすべてできなければならない。2つ目は把握や管理が難しくなること。派生クラスは元クラスをコピーして
　作っているため、この2つのクラスのソースコードの大半が重複している。これによりプログラム全体の見通しが悪くなり
　メンテナンスがしづらくなる。

　このようなコードの重複を懸念することなく類似したクラスを作成できる機能である「継承」がある。
　extendsを用いて元となるクラスとの「差分」だけを記述して新たなクラスを宣言できる。

・今回、Heroクラスを継承してSuperHeroクラスを作成した。このような2つのクラスの関係を「継承関係」という。
　そして、そのもととなるクラスを「スーパークラス」「基底クラス」「親クラス」などと呼び、新たに定義されるクラスを
　「サブクラス」「派生クラス」「子クラス」などと呼ぶ。なお、継承関係を図で表現する場合は、p355のような矢印で
　記述するルールが定められている。継承の矢印は直感とは逆に、子クラスから親クラスに向かって引く。

・1つのクラスをベースとして複数の子クラスを定義することもでき、孫クラスやひ孫クラスの定義も可能。
　ただし、Javaでは複数のクラスを親として1つの子クラスを定義する「多重継承」を許可していない。

・SuperHeroクラスに限ってrun()メソッドの動きを変えたい場合、
　親クラスであるHeroにもrun()はあるが、子クラスSuperHeroでも改めてrun()を定義する。
　このように、親クラスを継承して子クラスを宣言する際に、親クラスのメンバを子クラス側で上書きすることを
　「オーバーライド」という。オーバーロードと名前は似ているが全く異なるものなので混同しないように注意する。

・継承を用いて子クラスに宣言されたメンバの扱いとしては、
　親クラスに同じメンバが無ければ、そのメンバは「追加」される。
　親クラスに同じメンバがあれば、そのメンバは「上書き」される。

・Stringクラスを継承することはできない。このように、「このクラスを継承して他のクラスを作ってはいけません」
　と特別に指定されているクラスがある。JavaのAPIリファレンスを見ると、Stringクラスは次のように宣言されている。
　public final class String extends Object…
　Javaでは「宣言にfinalが付けられているクラスは継承できない」ことになっている。
　もちろん、我々が作成するクラスにもfinalをつければ継承禁止にできる。
　なぜStringのような便利なクラスにfinalがつけられているかというと、
　オーバーライドによってメソッドの内容をめちゃくちゃに上書きしてしまったら「異常な動作をする子クラス」が
　できてしまい、この「異常な子クラス」は親クラスと似ているようでその内容は全く異なる
　類似品であり、バグの原因となる危険性がある。Stringクラスはプログラム内で多用される大切なクラスなので
　「正しく動作しないStringの類似品」が出回ると致命的な不具合の原因になりかねない。
　このような理由からStringクラスにはfinalが付けられていて、全てのメソッドはオーバーライドできないようになっている。

　クラスの継承は許可したいが、一部のメソッドについてのみオーバーライドを禁止したい場合は、
　そのメソッドの宣言にfinalをつけることで可能となる。宣言にfinalが付けられたメソッドは、子クラスで
　オーバーライドができないことになっている。

・フィールドはオーバーライドしてはならない。

・SuperHeroインスタンスは外から見れば1つのSuperHeroインスタンスだが、内部にHeroクラスから生まれたHeroインスタンスを
　含んでおり、全体として「二重構造になっている」ことに着目する。
　親、子、孫と3つのクラスが継承関係にある場合、孫クラスのインスタンスは三重構造となる。

・インスタンスの外からメソッドの実行依頼が届く(呼び出しがある)と、多重構造のインスタンスは
　「極力、外側にある子インスタンス部分のメソッド」で対応しようとする。たとえば、fly()が呼び出されれば
　SuperHeroクラスで定義されたfly()が動く。一方、attack()への呼び出しは、まずは外側の子インスタンス部分で
　対応しようとするが、外側にattack()は存在しない。そこで内側にある親インスタンス部分のattack()に呼び出しが届き、
　それが動作する。run()は、SuperHeroとHero両方のクラスで定義(オーバーライド)されており、
　SuperHeroインスタンスは「SuperHeroとしての逃げ方」と「Heroとしての逃げ方」の両方を持っている。
　この状態でrun()を呼び出された場合、外側にあるSuperHeroとしてのrun()が優先的に動作するため、
　内側のrun()が動くことはない。

・super.attack()のようにすると親クラスのメソッドを呼び出せる。
　superとは「今より1つ内側のインスタンス部分」を表す予約語。これを利用すれば親インスタンス部分のメソッドや
　フィールドに子インスタンス部分からアクセスできる。superをつけずに単にattack()と呼び出すと、
　this.attack()と書いたのと同じ意味となってしまう。thisは「自分自身のインスタンス」を意味するが、より正確には
　「インスタンスの最も外側の部分」を指す。そのため自分自身のattack()を呼び出し続ける無限ループが発生してしまう。

　親の親インスタンス部分へのアクセスは不可能となっている。たとえば、Aクラス(親の親)、Bクラス(親)、Cクラス(自分)という
　3つのクラスが継承関係にある時、Cクラスから生成されたインスタンスは三重構造になる。このとき、一番外側に相当する
　Cインスタンスは自分自身へはthis、親インスタンス部分へはsuperでアクセスできるが、親の親にあたるAクラスへ
　アクセスする手段は準備されていない。

・多重構造はクラスがnewされると次のような段階を経て構築される。
　1．まず親インスタンス部が作られる。
　2．外側に子インスタンス部が作られる。
　3．JVMにより自動的にコンストラクタが呼ばれる。

　上記のようにSuperHeroインスタンスが完成すると、JVMは自動的にSuperHero()コンストラクタを呼び出す。
　この時、コンストラクタの動作を確認するようなコードを実行してみると、SuperHero()コンストラクタが実行される前に
　内側インスタンスのHero()コンストラクタも勝手に動作している。
　Javaでは「全てのコンストラクタは、その先頭で必ず内部インスタンス部分(親クラス)のコンストラクタを呼び出さなければならない」
　と決められている。同じクラスの別コンストラクタを呼び出すためのthis()に似たsuper()という記述で親クラスのコンストラクタを呼び出せる。
　よって本来は子クラスのコンストラクタの最初にはsuper();のような記述をしなければならないが、
　もしコンストラクタの1行目でsuper()を呼び出さない場合、コンパイラによってsuper();という行が自動的に挿入される。
　super()はsuper.メンバ名とは全く関係が無いので混同しないよう注意する。

・親クラスに引数ありのコンストラクタしか作っておらず、かつ子クラスでコンストラクタの記述を省略するとコンパイルエラーとなってしまう。
　なぜこうなるかというと、コンストラクタを記述しないとpublic weapon() {} のようにデフォルトコンストラクタが定義され動作するが、
　子クラスのコンストラクタの先頭行にはsuper();が挿入されるため、実際にはpublic weapon() {super();} のようになる。
　このように自動生成されたWeaponクラスのコンストラクタは、親クラスItemのコンストラクタを「引数なし」で呼ぼうとする。
　呼び出される側のItem(親)クラスのコンストラクタの宣言に引数0個のコンストラクタは存在しないため、
　super();のように引数が無い呼び出しはできない、となる。
　内部インスタンスの初期化を行うコンストラクタ(Item()コンストラクタ)に引数を与える必要がある場合は、
　super()の呼び出しで明示的に引数を渡す。super("名無しの剣")とすればWeaponクラスのインスタンス化によって
　内部でItemクラスが作られるタイミングで親クラスのコンストラクタが動作し、常に「名無しの剣」という名前になる。
　また、super("名無しの剣",300);と記述すれば、常に引数を2個持つ方のコンストラクタが動作する。
　つまり、super()に与える引数の数と型によって、「親インスタンス部分が初期化される時に利用されるコンストラクタ」を明示的に指定できる。

・正しい継承とは、「is-aの原則」と呼ばれるルールに則っている継承のこと。
　そしてis-aの原則とは、子クラスと親クラスの間に次のような概念的な関係が成立しているべきとする原則。
　「子クラス is-a 親クラス(子クラスは、親クラスの一種である)」
　スーパーヒーローは特殊能力を持った特別なヒーローだが、あくまでもヒーローの一種であることに違いない。
　「SuperHero is-a Hero」と言えるので正しい継承となる。もし、子クラス is-a 親クラスという文章に当てはめて
　不自然さを感じたら、継承の誤りを疑った方が良い。

・間違った継承の例として、「名前」と「値段」のフィールドを持つItemクラスがある。このクラスは勇者たちが冒険のために持ち歩く
　薬草やポーションなどのアイテムを表すクラス。そして今、我々は新たにHouseクラスを作ろうとしている。Houseクラスには所有者や
　床面積、間取りや住所などの他、「家の名前」「家の値段」のフィールドも必要。
　この時、Itemクラスを継承してHouseクラスを作ればラク、といった発想こそが「間違った継承」の原因となる。
　Itemクラスを継承してHouseクラスを作るのは文法上はもちろん可能であり、実際名前と値段のフィールドも継承され、
　問題なく動作する。しかし「House is-a Item」という文には違和感を覚える。勇者は冒険のために家を持ち歩くことはない。
　このように「フィールドやメソッドが流用できるから」という安易な理由で継承をしてはいけない。
　「動くか動かないか、便利か便利でないか」ではなく、「is-aの関係であるかどうかに基づいて継承は利用すべき」である。

・is-aの関係ではない継承をしてはいけない理由は2つある。
　1つめは「将来、クラスを拡張していった場合に現実世界との矛盾が生じるから」
　2つ目は「オブジェクト指向の三大機能の1つである多態性を利用できなくなるから」
　1つめの問題を例にして考えると、たとえば、アイテムは敵に投げつけてダメージを与えられるとする。
　そこでItemクラスに敵に投げつけた時に与えるダメージを返すメソッドであるgetDamage()を追加する。
　このメソッドは継承されてHouseクラスでも利用可能になるが、現実に沿って考えると「家を投げることなどできるわけがない」し、
　そのダメージを算出する、getDamageメソッドがHouseクラスに対して呼べること自体が極めて不自然となる。
　「投げつけた時のダメージがある家」を表すHouseクラスはすでに現実世界の「家」と乖離しており、
　オブジェクト指向の原則から外れている。

・正しい継承がis-aの関係で結ばれるという事実は、子クラスになるほど「特殊で具体的なもの」に具体化(特化)していき、
　親クラスになるほど「抽象的であいまいなもの」に一般化(汎化)していくことを示している。特化すればするほどより詳細にフィールドや
　メソッドを定めるため、メンバは増えていく。逆に汎化すればするほど、フィールドやメソッドを定めるのは難しくなってくる。
　たとえば、キャラクターであれば必ず名前とHPは持っていると予測されるため、Characterクラスにはnameとhpフィールドくらいは定義できる。
　より具体的なキャラクターとして、例えば魔法使いになると、最低でもMPを持っていて火の玉ぐらいは放てるはずであり、
　クラス定義にはmpフィールドやfireballメソッドが加わる。更に具体的な「ひとにぎりの魔法使い」は雷を落とすlightningメソッドなど
　Wizardが持っていないメソッドも持つことになる。このような継承関係を表すp378のような図を「継承ツリー」などと呼ぶ。
　ちなみに、クラス図において継承関係を表す矢印は「クラスが汎化していく方向」を表すための矢印となる。

・これまで継承とは、重複するコードの記述を減らすための道具だと捉えてきたかもしれないが、
　継承は「ある2つのクラスに特化・汎化の関係があることを示すための道具」でもある。

・高度な継承を学ぶにあたって、この章では主に継承ツリーの情報に登場する「あいまいなクラスたち」の定義方法について学ぶ。
　これまでに学んできた方法でこれらのクラスを定義してもプログラムは動作する。しかし、「あいまいなクラスたち」専用の
　クラス定義方法を理解し、高度な継承を実現すれば、より安全で便利にクラスを利用できるようになる。

・高度な継承は文法的に難しいものではない。それにもかかわらずつまずく人が多い理由は、
　「高度な継承を使う時の立場が、これまでの立場とは全く違うこと」ということを意識せずに学習を始めてしまうから。
　今までは作る必要があるプログラムは明確に決まっていて、「そのプログラムのためだけに必要なクラスを作って
　目的のプログラムを完成させる立場」だったのではないだろうか。そして、もし開発すべきクラスと類似した
　「既存のクラス」があれば、継承を利用して子クラスを作ることにより、一から開発せずとも、いくつかのメンバを利用するだけで効率よく
　クラスを開発できた。ここで「既存クラス」に注目して、少し想像を膨らませてみると、きっとこのクラスを事前に開発しておいてくれた
　開発者がどこかにいるはず。その作者は自分の作ったクラスがどんなプログラムに利用されるか想像もつかない過去の段階で
　「いつか誰かがこのクラスを継承して開発したら便利だろう」と未来に思いをはせ、継承の材料となる既存クラスを作ってくれたのである。
　ここで異なる立場が存在することが分かる。現在、目の前のプログラム開発に必要なクラスを作る開発者(既存クラスを継承して子クラスを作る)と、
　未来に備え、別の開発者が将来利用するであろうクラスを準備しておく開発者(親クラスとなるクラスを作っておく)の2つの立場である。

　この章の内容をスムーズに理解するためには、この「2つの立場」の存在を明確に意識し、区別できるかがポイントとなる。
　前章までに私たちが学習して句た知識は全て前者の立場として開発するために必要なものだった。
　一方、この章で学習する知識は、後者の立場としてプログラムを作るときに必要となるもの。
　なぜなら、この章で学ぶ「抽象クラス」「インタフェース」とは後者の立場の人たちが、「前者の立場の人たちに安全で便利に使ってもらえる
　親クラスを作るための道具」だから。そのため、後者の立場である開発者になってクラスを作ることを想像しながら本章を読み進めるとよい。

・自分の作るたった1つのクラスの優劣が、それを利用する複数の開発者たちの開発効率に影響する。そのため高度な継承を行う立場の開発者が
　意識すべきことは「利用する側の開発者が効率よく安心して利用できる継承の材料をいかに作るか」というポイントに絞られる。

・高度な継承に関する2つの不都合と3つの心配事が存在する。これらはp389のような図の関係にあり、それぞれを例にとって見ていく。

　まず最初の不都合として、Characterクラスを書こうとするとattackメソッドのダメージ量で手が止まってしまうはず。
　なぜ手が止まってしまうのかより深く考えてみる。このCharacterクラスは将来、様々な開発者によって継承され、HeroやWizardやDancerなどを
　開発する際の材料として利用される。しかし、未来に完成するであろうHeroやWizard、そしてDancerは、それぞれお化けキノコを攻撃したときに
　与えるダメージが違うはず。腕っぷしの強いHeroであれば10ポイント、ひ弱なWizardなら5ポイント、さらに今は存在しないが、
　未来に追加されるかもしれない強力なキャラクターでは100ポイントなどもあり得る。つまり、Characterクラスを作っている時点では
　まだ「attackメソッドの内容を確定できないため、書きようがない。」これが不都合Aとなる。
　この不都合に対して間違った解決方法として「そもそもattackメソッドを記述しない」という方法がある。HeroやWizardなどの
　新しいキャラクターのクラスを作成する時に、それぞれ継承先のクラスでattackメソッドを追加してもらう。
　しかし、この方法で不都合Aを解決しようとすると、もし継承先のクラスにattackメソッドを追加し忘れると「攻撃できないキャラクター」ができてしまう。
　そもそも「現実世界の全てのキャラクターはHP属性を持ち、攻撃ができる」という前提でCharacterクラスを作り始めたのに
　attack()を持たないキャラクターができてしまっては困る。そもそもオブジェクト指向とは、「現実世界を正確に写し取る」こと。
　「キャラクターであれば少なくとも攻撃ができるはず」というゲーム世界の前提を考えると、攻撃できないキャラクターが作れてしまう可能性は
　万が一にもあってはならない。「Characterクラスは必ずattackメソッドを持っているべき」なのだ。

　不都合Aの対応策として、空のattackメソッドを作り、他の開発者がその職業に最適なattackメソッドでオーバーライドしてもらう、
　といった考え方が思いつくかもしれない。なかなか悪くない方法だが、Characterクラスを利用してくれる未来の開発者たちを思いやる気持ちが強いほど、
　次の2つの心配事が頭をよぎるだろう。

　第一の心配事は「オーバーライドを忘れる」こと。未来の開発者がattack()のオーバーライドを忘れてしまうと、
　重大な不具合に直結してしまう。たとえば、Heroクラスでattackメソッドをオーバーライドし忘れたとする。
　Heroクラスは親クラスであるCharacterから内容が空のattackメソッドを受け継いでいる。そのため、他のメソッドから
　h.attackメソッドを「呼び出せるが、何も起きない」という不具合を抱えたクラスになってしまう。
　これに対する解決策の1つとして、attackメソッドを作成する時にコメントを残しておくという方法がある。
　しかし、コメントを逃したり無視したりする可能性は残る。仮に読めたとしても、atack()のように
　スペルミスをしてしまい、オーバーライドしたと思い込んでいて実際はできていない可能性はある。

　第二の心配事は「本当に何もしないと区別がつかない」こと。characterクラスのattackメソッドをもう一度よく見ると、
　public void attack(Matango m) {} のようになっているはず。そもそもこの書き方は「呼ばれても何もしない」メソッドを
　作りたい場合に行うもの。しかし今回のattack()は「何もしない」のではなく「何をするかが未定で記述できない」のである。
　未来の開発者がこのメソッドを見た時に、何もしないのが正しいのか、何をするか未定なのか、区別がつかない恐れがある。

　不都合Bは「クラスには2つの利用方法があり、開発者はそれを自由に選ぶことができる」こととなる。
　そして不都合Bからくる第三の心配事は「意図せずnewして利用されてしまう」こと。
　なぜこうなってしまうのかというと、たとえば、プロジェクトに新しく入ったDさんに「便利なクラスだからどうぞ使ってください」
　とCharacterクラスを渡したら、Dさんは Character c = new Character(); のように記述してしまうかもしれない。
　実はCharacterクラスから実体であるインスタンスが生み出されたり、そのインスタンスが
　仮想世界の中で活動してしまったりするのは「かなりの異常事態」である。なぜなら、詳細未定なattackメソッドを含むCharacterクラスは
　詳細未定につき、作りこんでいない部分が残っている未完成な設計図のようなものだから。このようにnewされるべきでないクラスが存在する。
　ではなぜこんな心配事が出てきてしまったのか、今まであまり意識することは無かったが、そもそもクラスには2つの利用方法がある。
　1つ目に「newによる利用」、つまり「インスタンスを生み出すため」にそのクラスを利用する。
　2つ目に「extendsによる利用」つまり一からクラスを開発すると効率が悪いので、あるクラスを「継承元として」利用する。
　HeroやWizardはnewするためのクラスとして、Characterはextendsするためのクラスとしてそれぞれ開発されている。しかし残念ながら、
　Characterクラスの作者が「extendsして利用してほしい」と願っても、未来の開発者はnewによる利用とextendsによる利用のどちらも選べてしまう。
　そのため、Characterのような未完成なクラスが誤ってnewされてしまうという事態が起きる。クラスには自由に選べる2つの利用方法があるという利点が、
　皮肉にも意図せずnewされる心配事の原因になってしまっている。

・第二の心配事である「空のメソッドを作っておくと、現時点で処理内容を確定できないメソッドなのか、何もしないメソッドなのか区別がつかない」
　といった問題に対して、Javaには「詳細未定のメソッド」を記述する専用の構文が用意されている。
　たとえば、Characterクラスのattackメソッドは次のように書く。
　public class Character {
    public abstract void attack(Matango m);
}
　abstractとは、抽象的、あいまいという意味の英単語。これをメソッド宣言に付けると、attack()というメソッドは宣言すべきであるが、
　具体的にどう動くか、内容がどうなるかまでは現時点では確定できないのでメソッド内部の処理はここでは記載しません、という意思の表明になる。
　メソッドの処理内容は未定で記述できないわけなので、メソッド宣言の後ろにはブロック記号の{}さえつけず、その代わりにセミコロンを書く。
　abstractキーワードが付けられたメソッドは、「抽象メソッド」と呼ばれる。

・次に第三の心配事である「未完成のためnewしてはいけないクラスの宣言」といった問題に対して、
　Javaでは未完成部分(抽象メソッド)を1つでも含むクラスは、次の構文に従って宣言しなければならない。
　public abstract class クラス名 {…}
　このように、abstractがついたクラスは特に抽象クラスと呼ばれる。Characterクラスを普通のクラスではなく
　抽象クラスとして宣言すると、次のような特殊な制約がかかる。
　「抽象クラスは、newによるインスタンス化が禁止される。」
　そのため、抽象クラスをnewしようとしてもコンパイルに失敗するため、間違ってnewされることがなくなる。

・最後に第一の心配事である「未来の開発者が、詳細未定のメソッドをオーバーライドし忘れる可能性がある」問題に対して、
　実はこの問題は既に解決している。Characterを継承してDancerを作る新人開発者Dさんの立場になって考えてみる。
　DancerはHeroやWizardと同じように、newして実体を生み出し冒険させるためのクラスである。Dさんは、Dancer特有の能力である
　「踊る(dance)」というメソッドの作成に気を取られてattack()のオーバーライドを忘れてしまったとする。
　しかし、このソースをコンパイルしようとすると、「抽象メソッドをオーバーライドしなければならない」という意味のエラーメッセージが
　表示され、コンパイルは失敗する。Dancerクラスに抽象メソッドは無いはずなのになぜか、実はDancerには「隠れた抽象メソッド」が潜んでいる。
　ここで継承の基本を再確認すると、DancerクラスはCharacterクラスを親クラスとするので、Characterクラスが持つすべての
　メンバを継承している。そして、親クラスから継承したメンバの中には抽象メソッドattack()も含まれている。
　つまり、「Dancerクラス自体のソースコードに抽象メソッドは無くても、親クラスから抽象メソッドを継承して持っている」のである。
　抽象メソッドが1つでもある以上、Dancerクラスも抽象クラスにしなければコンパイルエラーが出て当然、といったことである。

　このエラーに対処するには2つのやり方がある。
　1つ目はDancerクラスの宣言にabstractをつけて抽象クラスにする。
　2つ目はDancerクラス内部の「未完成部分」をすべて完成させる。
　1つ目の方法で解決を図ればコンパイルエラーを消すことはできるが、抽象クラスとなってしまったDancerはnewできないため、
　インスタンスを生み出すことができない。DancerをHeroやWizardのようにインスタンス化して冒険できるクラスとして開発したいならば
　残された選択肢は2つ目の方法だけとなる。すなわちDancerクラスの中でattack()をオーバーライドし、未完成メソッドをすべて完成させればよい。
　このオーバーライドにより、その存在だけが宣言されていたattackメソッドの動作が決定された。
　このように、それまで未定だったメソッドの内容を確定することを「実装」と表現する。Dancerクラスは全てのメソッドの動作が実装されており
　「詳細未定」な部分は残っていない。よってabstractをつける必要はない。Dancerは「newして使える通常のクラス」になった。
　今回のDancerの例を振り返ってみると、抽象クラスはnewできないルールがJavaに備わっているため、
　あるメソッドを抽象メソッドとして宣言しておけば、未来の開発者にオーバーライドを強制できる(オーバーライドしないとnewして使えない)
　効果があると考えられる。

・以上で3つの心配事が全て解決した。抽象クラスと抽象メソッドを用いて、未来の開発者が安全かつ便利に利用できる「継承の材料」となる
　クラスを開発できるようになったのである。

・ここまで抽象メソッドには、未来の開発者が継承するとオーバーライドを強制する効果があることを解説してきた。
　ちなみに、抽象クラスを継承した子クラスで全ての抽象メソッドをオーバーライドしてメソッドの内容を実装する必要は必ずしもなく、
　親クラスを継承していくどこかの時点で全ての抽象メソッドを実装できれば良い。つまり、孫クラス、あるいは曾孫クラスで
　オーバーライドして内容を確定させても構わない、ということ。その代わり全ての抽象メソッドを実装しなければクラス宣言から
　abstractを外すことは許されず、つまりnewして利用することはできない。といった点に注意する。

　たとえば、様々なモンスターたちの親クラスとなるMonsterというクラスを考えてみる。
　Monsterクラスはattack()とrun()のメソッドを持っているが、モンスターによって、どう攻撃するか、どう逃げるかについては
　現時点ではわからない。よって、両方ともabstractがついた抽象メソッドとなる。
　次に、もう少し具体的なMonsterを定義するとする。WalkingMonsterは「トコトコ走って」、FlyingMonsterは「バサバサ飛んで」
　逃げていくと決まれば、run()だけはオーバーライドして内容を実装できる。しかし、WalkingMonsterとFlyingMonsterにはまだ抽象メソッドが
　残っている。attack()の詳細が未定なので、これら2つのクラスは共に抽象クラスでなければならず、
　クラス宣言からabstract宣言を外すことはできない(つまりnewできない)。さらに、WalkingMonsterの子クラスとしてGoblinクラスを
　定義し、このクラスではattack()をオーバーライドすると、ここでやっと抽象メソッドがなくなる。
　Goblinクラスはabstract宣言をつける必要は無くなり、通常のクラスとしてnewして利用可能になる。同様に、FlyingMonsterの子クラスとして
　DeathBatを定義し、このクラスでattack()をオーバーライドすると抽象メソッドは無くなり、これもnewして利用できるようになる。

　このようなモンスターたちの継承ツリーを眺めると、継承が繰り返されるたびに内容が具体化していくのが分かる。
　Monsterというクラスは大変にあいまいで、「HPとMPがある」「詳細は未定だが攻撃と逃げることができる」程度しか決められていない。
　もう少し具体化したWalkingMonsterやFlyingMonsterでは、逃げる処理の内容が確定する。さらに具体化したGoblinやDeathBatは、
　攻撃の方法も確定し、あいまいさが全くない。継承を正しく用いたJavaのクラスは、継承ツリーの階層を降りていくほどに具体的になり、
　メソッドの処理内容が実装されていく。

・前節では継承階層が下がっていくたびにクラスは具体化していき、最終的には全てのメソッドについて処理内容が実装されていくのだった。
　では今度は逆に、階層を下から上に昇ってみる。以下の条件に沿ってMonsterクラスの親クラスを作っていくとする。
　1．MonsterとCharacterの共通の親として戦闘に参加する生き物(BattleCreature)を定義する。
　　 戦闘に参加する生き物の中には、専守防衛的な生き物もいるかもしれないのでattack()は定義できない。
　2．BattleCreatureの親として生き物(Creature)を定義する。これは村人やお姫様のように戦闘に参加しない登場人物も含んでいるため、
　　 HPフィールドがあるとは限らないが、どのような生き物であっても脅威から逃げるためのrun()は持っている。
　GoblinであればHP、MP、名前、攻撃力などのフィールドと、attack()やrun()、useItem()などの内容が確定した具体的なメソッドを
　備えているだろう。しかしCreatureのようにあいまいになると、攻撃力やuseItem()はおろか、名前さえも持っているとは限らない。
　もはや、最低でも逃げるためのrun()ぐらいは持っていることしか決められない。
　この例に限らず、正しく継承が用いられている継承ツリーを上へ辿ると、次のような現象が順に起こる。(p413)

　Goblin → WalkingMonster　「抽象メソッドが現れる」
　WalkingMonster → Monster　「抽象メソッドばかりになる」
　Monster(Character) → BattleCreature　「フィールドや抽象メソッドが減り始める」
　BattleCreature → Creature　「抽象メソッドだけになる」

　継承階層を上に辿るということは、どんどんあいまいなものになっていくことを意味する。クラスがあいまいになるにつれ、
　「どのような内部情報を持っているか(フィールド)」「どのような動きをするか(メソッド)」はあやふやになり、決められなくなっていく。

・ここまで見てきたように、継承階層を上に辿ると、上流のクラスは全て抽象クラスになる。
　そしてJavaでは、次の条件を満たす、特に抽象度が高い抽象クラスを「インタフェース」として特別に扱うことができる。
　1．全てのメソッドは抽象メソッドである。
　2．基本的にフィールドを1つも持たない。

　インタフェース宣言は public interface インタフェース名 {…} のように記述する。
　なお「インタフェースに宣言されたメソッドは、自動的にpublicかつabstractになる」というルールがあるため、
　通常は void run(); のようにメソッドを宣言する。
　つまりインタフェースとは、「抽象クラスの親玉みたいな存在」のようなもので、初めのうちはあまりにあいまいすぎて
　特別扱いされた抽象クラス、と理解しておけばよい。

・インタフェースは基本的にフィールドを持たない。しかし、public static final がついたフィールド(定数)だけは宣言が許される。
　さらにその場合は、public static final を省略してもよいことになっている。つまり、インタフェース内でフィールドを宣言すると
　自動的にpublic static finalが補われ、定数を宣言したことになる。

・なぜ2つの条件を満たした抽象クラスにインタフェースという全く新しい別の名前がついているのか？
　たとえば以下のように3つの抽象メソッドを持ったCleaningServiceインタフェースがあったとする。

　public interface CleaningService {
    Shirt washShirt(Shirt s);
    Towl washTowl(Towl t);
    Coat washCoat(Coat c);
}

　このCleaningServiceはシャツとタオル、そしてコートを渡せばそれを洗って返してくれる。
　しかし布団やマフラーは扱っていないようだ。また、全てのメソッドは抽象メソッドであり、処理内容が記述されていない。
　つまり、「クリーニング店の内部で行われる詳細な洗い方については明かされていない」わけとなる。
　CleaningServiceインタフェースは、まるでクリーニング店の店頭メニューのようだ。
　店頭メニューは、クリーニング店が「こういう仕事を受け付けますよ」と表明するためのもの。
　そしてお客さんはメニューを見て「この仕事をお願いします」と依頼をする。
　つまり、メニューは店とお客さんとの接点(英語でinterface)の役割を果たしている。
　CleaningServiceインタフェースが店頭メニューだとすれば、それを継承してp418のように記述したkyotoCleaningShopクラスこそが
　「クリーニング店そのもの」といえるだろう。この1行目にあるように、インタフェースを継承して子クラスを定義する場合は
　extendsではなく「implements」を使う。これを「CleaningServiceインタフェースを実装してKyotoCleaningShopを実装する」
　などと表現する。

・なお、クラス図ではインタフェースの実装を点線の矢印記号で表す。
　implements(実装する)という用語が使われるのは、「親インタフェースで未定だった各メソッドの内容をオーバーライドして実装し確定させる」から。

・ところで、全国チェーンのクリーニング店では、どの店でも同じ店頭メニューを使っていることがある。
　恐らく本社で作ったメニューを、全ての店で掲示しているのだろう。チェーン店とはいえ、京都店、大阪店、奈良店は
　別の店なのでそれぞれの店が持つ設備や選択の手順も様々だろう。つまり、共通のCleaningServiceを実装していたとしても、
　個々の店のクラスが持つフィールドやメソッドの詳細は異なってもよい。しかし、このクリーニングチェーンの加盟店は
　共通の店頭メニューを出している以上、どの店もシャツ、タオル、コートの洗濯はできる必要がある。個々の店のクラスは、
　CleaningServiceインタフェースで定められた抽象メソッドをオーバーライドして処理を実装する必要がある。

　このように考えると、あるインタフェースに複数のメソッドを定義しておくと、次のような2つの効果を生み出すと考えられる。
　1．同じインタフェースを「implementsする複数の子クラスたちに、共通のメソッド群を実装するよう強制できる。」
　2．あるクラスがインタフェースを実装していれば、「少なくともそのインタフェースが定めたメソッドは持っていると保証される。」

・クリーニング店の例で見たように、インタフェースは「このようなメソッド群を持ち、このような引数を与えればこのような結果を返す」
　という表面的な確約をするだけで、その「内部実装(メソッドの処理動作)」を一切定めていない。インタフェースが特別扱いされるのは、
　この「内部実装を一切定義しない」という性質があるから。この性質のおかげで「インタフェースでは特別に多重継承が許されて」いる。

・多重継承はあるクラスを作成する際に2つの親クラスを使うことができる、とても便利な機能。しかし、多重継承は誤用されやすく危険なため
　Javaでは基本的にクラスの多重継承は禁止された。なぜ多重継承が危険なのかをp422の図で考えてみよう。
　PrincessHeroは、PrincessとHeroの両方からメソッドを継承している。このとき、PrincessHeroのrunメソッドが呼び出されたら、
　このキャラクターはどのよう逃げるのだろうか？Princessのように「スカートのすそを持って」逃げるのか？それともHeroのように
　「衣類なんて気にせず」逃げるのか？このように、多重継承を用いると、両方の親クラスから「同じ名前でありながら異なる内容の2つのメソッド」
　を継承してしまう現象が起こりえるため、「お姫様としての逃げ方」と「勇者としての逃げ方」のどちらが動くべきなのか、混乱を招いてしまう。

　しかし、これがHeroインタフェースとPrincessインタフェースからの多重継承ならばどうだろうか？
　PrincessHeroはPrincessとHeroの両方から抽象メソッドであるrun()を継承するため、
　これを必ず「勇者として旅に出たお姫様の独自の逃げ方」でオーバーライドすることになるだろう。
　この場合、PrincessHeroのrun()が呼び出されても、先程のクラスの多重継承のような混乱は起こらずに、
　PrincessHeroでオーバーライドして定義されたrun()が動く。

　そもそも多重継承が問題なのは、両方の親クラスから同じ名前でありながら異なる内容のメソッドを継承して衝突してしまうから。
　しかし、両方の親がインタフェースの場合、「どちらもメソッドの内容をいっさい定めていない」ので、
　親から継承した2つの処理内容が衝突することは起こりえないのだ。
　つまりクラスにはないインタフェースの特権としては、
　「異なる実装が衝突する問題が発生しないため、複数の親インタフェースにより多重継承が認められている。」

・ところで、あるインタフェースを定義する場合、一から開発せずに既存のインタフェースを継承してその機能を拡張することもできる。
　p425の例のように、新たにHumanインタフェースを定義する時、親インタフェースであるCreatureのrun()に加え、
　新たな抽象メソッドとしてtalk(),watch(),hear()を追加している。
　この時、HumanはCreatureのrunメソッドをオーバーライドして「処理の内容を確定しているわけではない」ため、
　implements(実装)ではなくextends(拡張)を使う。同じ種類(クラス同士、インタフェース同士)の継承はextends、
　違う種類(インタフェース → クラス)ならimplementsを使う、という風に覚えるとよい。

・クラス定義の際にextendsとimplementsの両方を利用することもある。この場合、p426のような使い方をする。
　この場合、片方の親であるCharacterはインタフェースではなくただの抽象クラスだが、
　それでもextendsとimplementsを同時に使えるということは、親にクラスが2つ以上無い場合に限って、
　クラスも多重継承の親にする、みたいなことが可能となる？

・インタフェースが持つことのできるメソッドは、原則として処理内容を持たない抽象メソッドに限られる。
　しかし、例外的にdefaultキーワードによる処理のデフォルト実装を添えた抽象メソッドの定義は認められている。
　default 戻り値の型 メソッド名(引数リスト) {処理のデフォルト実装} のように記述する。
　もし継承先でオーバーライドされなかった場合、自動的にデフォルト実装して定めた処理内容でオーバーライド
　されたものとみなされる。オーバーライドの手間を省ける便利な機能だが、多重継承によるデフォルト実装の衝突を
　招く可能性のある点には注意が必要。なお、近年のJavaでは、利便性を優先してstaticメソッドやprivateメソッドの
　作成も可能となった。しかし、インタフェース本来の機能は、「実装を持たずに定義のみを持つ」ことに変わりない。

・クラスの継承を行っていく中で、フィールドを持つクラスが出てきたらそのタイミングでコンストラクタを作り始めれば
　その子クラスたちはその親クラスのコンストラクタを利用すればよいので子クラスたちでわざわざ親クラスメンバの
　初期化をするコンストラクタは必要なくなる。

・「多態性」はオブジェクト指向プログラミングを支える三大機能の1つで、多様性やポリモーフィズムと呼ばれることもある。
　この多態性をマスターすると、RPG作りなども何倍もラクになる。
　そもそもオブジェクト指向は「ラクしてよいものを実現する」のが目的だった。特に、「多態性を上手に活用すると、
　とても効率よく楽しく開発できる」と聞けば、やる気がわいてこないだろうか？
　継承と同じく、多態性の学習にもコツがある。実は、多態性を定義や文法規則から学び始めると、大変難しく感じる。
　しかし、イメージを理解してから文法や定義を学べばそれほど難しいものではない。

・多態性のイメージとして、現時点では「あるものを、あえてザックリ捉えることで、様々なメリットを享受できる機能」
　と理解しておけば十分。この章を学ぶにあたっての大事なキーワードは「ザックリ」となる。
　ザックリ捉えるとは、たとえば以下のような考え方となる。

　「厳密にいえばSuperHeroなんだけど、まぁザックリいえばHeroだよね。」
　「厳密にいえばGreatWizardなんだけど、まぁザックリいえばWizardだよね。」
　「厳密にいえばSlimeなんだけど、まぁザックリいえばMonsterだよね。」

　このような捉え方をして様々なメリットを享受しようというのが多態性という機能である。

・ザックリ捉えることによるメリットは、私たちの日常生活にも多く見ることができる。
　たとえば、レンタカーを借りて車を運転する場面を考えてみる。「厳密にいえば」初めて乗る車であるにもかかわらず、
　多くの人は問題なく運転できる。なぜ、初めての車なのに運転できるのかとドライバーに聞けば
　恐らく次のような答えが返ってくるだろう。

　「まぁハンドルは同じだし、右ペダルがアクセル、左がブレーキ。"細かいところはあれこれ違うけど、
　まぁザックリ見ればどの車も同じ"だよ」

　この人は高級車や軽自動車、ライトバン、さらには来年発売の新車(現時点では未知の車)でも問題なく運転できるだろう。
　「そんなの当り前じゃないか」と思うかもしれないが、もし運転するのがロボットだとしたらこうはいかない。
　ロボットに内蔵される運転制御プログラムには、次のような無数の細かい設定が必要だろう。

　「もし2021年式のプリウスなら、ハンドルはシートから〇cmの高さにあり、それを10度回すとタイヤが〇度曲がり…」
　「もし2014年式のインプレッサなら、…(以下延々と続く)」

　ロボットは、それぞれの車種について細かい条件を完全に把握している必要があり、かつ「把握していない車」は操作できない。
　明らかに人間の方が「ラク」をして同じ成果が得られていますが、それは「車の厳密な車種についてはあまり考えていない
　=ザックリと車として捉えている」から。車に限らず、私たち人間は、世の中にある様々な複雑なものをザックリ捉えることによって、
　厳密には違うものも、似たようなものとして上手に利用している。この私たちが現実世界でラクするためにザックリと捉える方法を
　プログラムでも実現する機能こそ、オブジェクト指向三大機能の1つ、「多態性」なのだ。

・継承ではextendsやimplements、interfaceなど特有のキーワードが登場した。
　そこで多態性についても、何か専用の文法があって、それを書けば利用できると思い込んでしまいがちだが、
　実は「多態性には専用の文法はない。」今まで何度も使ってきた「代入の文法」を使えば、ザックリ捉えることができるようになっている。
　SuperHeroクラスを用いて解説していくと、前提としてSuperHeroは親クラスにHeroクラスを、さらにその親クラスにCharacterクラスを持っている。
　通常、SuperHeroのインスタンスを生成して利用するには、次のような文を記述するのだった。

　SuperHero h = new SuperHero();

　この時の状態を表すと、SuperHero型の変数にSuperHeroのインスタンスが入っているが、
　通常、変数にはその型と同じ型のインスタンスが入るので、これはごく当たり前の状態。
　次に、SuperHeroを「ザックリCharacterとして捉える」書き方が以下となる。

　Character c = new SuperHero();

　第8章では「newをするときは左辺と右辺に同じ型を書く」と紹介したが、実は、上記のように左辺と右辺の型を変えることもできる。
　今回の場合、左辺の型がCharacterに変わり、p439のようなイメージになる。箱の中身のインスタンスは正真正銘のSuperHeroだが、
　箱の表面には「Characterです」と書かれている。したがって、この変数cについては、以後、
　「本当はSuperHeroインスタンスだが、Characterとして捉えて利用する」ことになる。
　このように、多態性を活用するには、「箱の型」と「中身の型」の2つの型が関係する。
　そして、「あるインスタンスの捉え方は、代入する変数の型(箱の型)で決まる」のである。
　上記の例では Character cの「Character」の部分がインスタンスを「何」とみなすか、
　new SuperHero();の「SuperHero」の部分がインスタンスが「何」か、という認識となっている。

・代入式は基本的に「左辺の型と右辺の型が異なる場合はエラー」になる。たとえば、String str = 1;
　がエラーになるのは当然。しかし、基本に従えば先程のコードも左辺はCharacter型、右辺はSuperHero型なので
　エラーになるはず。なぜこのコードがエラーにならず、特例として許されているのだろうか？
　代入が許される判断基準は絵を描いてみればわかる。先程のイメージをもう一度考えると、
　箱には「Characterです」と書いてあり、SuperHeroが入っている。そしてこの「絵の内容は(厳密ではないが)嘘ではない。」
　スーパーヒーローもキャラクターの一種(SuperHero is-a Character)だから、「キャラクターが入っています」と書かれた箱に
　入っていても矛盾はないのだ。Javaではこのように、「絵に描いてみて嘘にならないインスタンスの代入は許される。」
　一方で次のような代入はエラーになる。

　float f = new Hero();　→　「小数が入っています」と書いてあるのに、ヒーローが入っている。
　Item i = new Hero();　→　「アイテムが入っています」と書いてあるのに、ヒーローが入っている。
　SuperHero sh = new Hero();　→　「スーパーヒーローが入っています」と書いてあるのに、ただのヒーローが入っている。

　絵に描いてみればわかるように、いずれも嘘になってしまうから。
　「子クラスのインスタンスは親クラスの型に代入可能」などどいう定義を丸暗記しようとすると混乱してしまうだろう。
　「イメージ図を描いてみる」ほうが忘れにくいしおすすめ。

・絵に描いてみて嘘が無いならば代入は可能なのはわかったが、そもそも絵に嘘が含まれるかを判断するには
　「〇〇は△△の一種である」という前提知識が必要となる。たとえば、我々は「Heroの中で特に選ばれたものがSuperHeroである
　(SuperHeroはHeroの一種である)」という前提知識があるからこそ嘘ではないと判断できた。我々人間には常識があるので、
　「魔術師が生き物の一種である」「剣が武器の一種である」と知っている。しかし、Javaには「何が何の一種なのか」という
　一般的な知識は備わっていない。そこでJavaは、extendsやimplementsを用いた継承関係にあるクラスについて、
　「片方のクラスは、他方のクラスの一種(is-aの関係)」であると判断する。
　言い換えると、「extendsやimplementsは開発者がis-aの関係をJavaに伝える手段」でもあるのだ。
　そのため、たとえば、Humanクラスがあり子クラスとしてMan、Womanクラスだけがあったとする。
　このとき Human h = new Hero(); としても図に書くとおかしくはないが、
　HumanクラスとHeroクラスはプログラム上の関係が無いため、Javaはこれを認めず代入はできない、となる。
　「is-aの関係(特化・汎化の関係をJavaに知らせる」のも継承の重要な役割となる。

・ここで仮に命あるあらゆるものの親として、新たにLifeインタフェースを作ったと考える。
　CharacterクラスもLifeインタフェースを実装するように変更したと仮定する。抽象クラスやインタフェースは
　インスタンス化できないため、Lifeインタフェースが定義されている場合、new Life()とすることはできない。
　しかし、インタフェースであるLifeはインスタンス生成のためには利用できないが、
　変数の型(Lifeが入っていますと書かれた箱)として使うことはできる。これは、たとえば以下のコードのように
　Life型の変数にWizardインスタンスを代入できることを意味する。

　Life lf = new Wizard;

　抽象クラスやインタフェースからインスタンスを生み出せないが、それらの型をこうした形で利用することは可能。

・「捉え方の違いは使い方の違い」であることがわかるように、1つたとえ話をすると

　「この紙切れを石器時代の人に渡すと"絵"と捉えるでしょう。これを見て楽しむことはあっても、何かに使えるとは思わない。
　一方、同じものを現代人に渡すと大喜びする。絵の人物が"福沢諭吉"であり、その紙切れが厳密には"貨幣"だと
　知っているから。現代人はその紙切れを眺めて楽しむこともできるが、どこかの店に持ち込み、何かと交換してしまうだろう。」

　このたとえ話が示唆してるのは、「まったく同一である1つの存在に対して複数の異なる捉え方ができる」ことと、
　「捉え方によって利用方法が変わる」こと。あいまいで抽象的なほど用途は限定され、具体的に捉えるほど用途が増えていく。

・この「捉え方が変わると利用方法が変わる」という現実世界の現象は、実はJava仮想世界でもちゃんと再現されている。
　CharacterとWizardクラスを使って、このことを解説していく。
　Wizardは魔法使いとしてattack()やfireball()のメソッドを持っているので、インスタンス化すればattackさせたり
　fireballを使わせたりできる。さて、WizardはCharacterの一種なので、Character型変数に代入することが可能。
　しかし、いざCharacter型に代入してfireballを呼び出そうとするとコンパイルエラーが発生してしまう。
　Character型の変数cに格納されているとはいえ、箱の中身のインスタンスは正真正銘のWizardインスタンス。
　そしてWizardならばfireballが使えるはずなのに、なぜコンパイルエラーになるのだろうか？
　それはCharacter型の変数に代入するということは、中身のインスタンスを(HeroだかWizardだかわからないけど)
　「何かのキャラクター」程度にザックリ捉えることに他ならない。したがって、「箱の中身がWizardである事実を忘れてしまう」のだ。
　つまり、「インスタンスをあいまいに捉えることになり、"厳密には何型のインスタンスだったか"がわからなくなってしまう」のである。
　コードの前半では確かに魔法使いを生み出している。しかしこのあいまいな型の箱にインスタンスを代入することを行った瞬間、
　我々は箱cの中身がHeroなのかWizardなのか、はたまた別の職業のクラスなのかがわからなくなってしまう。
　確実に言えるのは、「この箱に入っているのは、キャラクターの一種である」ことだけ。
　そう考えると、Characterに抽象メソッドとしてあるattack()が呼び出せて
　Wizard特有のfireball()が呼び出せない理由にも説明がつく。

　箱の中身の魔法使いが火の玉を放てなくなったわけではなく彼自身は「火の玉を放って」とお願いされればいつでも放つことができる。
　ただ、我々が彼を「魔法使い」と認識しないと「そもそもお願いできない(しようと思わない)」だけである。
　我々がこのインスタンスを「Character」と捉えている限り(Character型の変数に入っている限り)、
　Characterならできる最低限のことしか命令できない。箱の中身のインスタンスがどんなに多くのメソッドを持っていても、
　外部からはCharacterとして持つメソッドしか呼び出せないのである。

・前項では代入する箱によって呼べるメソッドが変わることを学習した。では次に、もしメソッドが呼べたとしたら、
　その動きはどうなるかについてモンスター関連のクラスを題材に実験してみよう。
　Monsterクラスとその子クラスであるSlimeクラスがあり、Slime s = new Slime(); と Monster m = new Slime();
　のようにしたとする。それぞれにrun()が定義されている場合、s.run()とm.run()はそれぞれどのように動くか。
　これはどちらもSlimeクラスのrun()メソッドが動く。変数sと変数mとは、箱の表面に書かれた「〇〇です」という表記に違いがあるものの、
　両方とも中身はあくまでもスライム。そのため、「逃げろ！」という命令が届きさえすれば当然スライムが逃げる。
　つまり、Slime()のrun()が動作する。このように、実際に動くメソッドの中身はインスタンスの型(中身の型)によって決まる。
　インスタンスが「どんな型の箱に入っているかは関係ない。」最後に箱の型と中身の型についてまとめておくと

　箱の型　→　どのメソッドを「呼べるか」を決定する。
　中身の型　→　メソッドが呼ばれたら、「どう動くか」を決定する。

・Character c = new Wizard(); としたとき、変数cに対してfireballメソッドを呼べなくなることは学習した。
　しかし、本当は中身がWizardだとわかっているのだし、どうしてもこのインスタンスにfireballを使わせたいという場面がまれにある。
　fireballを使えるようにするためには、変数cの中身を「Wizardであると捉えなおす」必要がある。
　そのためには、Wizard w = c; のようにして、インスタンスをWizard型変数に代入すればよいと想像がつくだろう。
　我々開発者はこのインスタンスの経緯を知っている。そのため、もともとWizardインスタンスとして生み出して、
　それをCharacterとみなしたものの、再び元のWizardと見なしてもいいだろう、と考える。
　しかし、コンパイラは基本的に「プログラムを1行ずつ解釈し、翻訳しようとする」ので、このコードだけを見て
　コンパイルエラーにしてしまう。このコードだけに着目すると、Character型の変数cに入っているのは、HeroやThiefの可能性もある。
　万が一、変数cの中身がHeroなのに、それを代入してしまったら、Wizard型の変数にHeroインスタンスが入っている嘘の構図になってしまう。
　このように、コンパイラは変数の中身が代入先の変数の型と一致するとは限らないとは考え、失敗する可能性のある代入を拒否する。

　それでも、どうしても変数cの中身を強制的にWizardとして捉え直したい場合には、以下のように書く。
　Wizard w = (Wizard) c;

　キャスト演算子の再登場となる。この演算子は強制的な型変換をコンパイラに対して明示的に指示する、とても強力な演算子。
　この指示ならコンパイラは文句を言わず、コンパイルを通してくれる。しかし、あいまいな型に入っている中身を厳密な型に代入するキャストは
　「ダウンキャスト」といわれ、失敗の危険が伴う。ダウンキャストは、代入が失敗する可能性を懸念してエラーを出すコンパイラに対し、
　代入をしても矛盾のある状態にはならないから、黙って代入しなさいと頭ごなしに型変換を実行させる命令。前のコードではうまく動くが、
　以下のようなケースはどうだろうか？

　Character c = new Wizard();
　Hero h = (Hero) c;

　このソースのコンパイルは成功する。しかし動作させると、代入しようとした瞬間に「ClassCastException」エラーが発生する。
　このエラーは、キャストによる強制代入の結果、「嘘の構図」になったので強制停止せざるを得なくなった、という意味のエラー。
　ダウンキャストによるClassCastExceptionを確実に回避するには、キャストしても大丈夫かを判定しながらキャストする。
　Javaにはそのための「instanceof演算子」が用意されている。
　変数 instanceof 型名 キャスト後格納変数名 のようにして記述する。
　たとえば、以下のようなコードで、変数cの中身を安全にSuperHero型の変数hに代入できる。

　if (c instanceof SuperHero h) {　←　もしcの中身がSuperHeroと見なして大丈夫なら、キャストしてhに代入する
    h.fly();
}

　また、まずキャスト可能かを判定したうえで、キャストの指示を別にしたい場合は次のように記述する。

　if (c instanceof SuperHero) {　←　もしcの中身がSuperHeroと見なして大丈夫なら…
    SuperHero h = (SuperHero)c;　←　「SuperHero」と見なせ！
    h.fly();
}

　この2つのコードは、全く同じ動作をする。

・ここまで多態性を用いてインスタンスをザックリ捉える方法を学んだ。それにより呼び出せるメソッドが減ることも学んだ。
　これだけを見ると、ザックリ捉えると、利用できるメソッドが減るだけで全くメリットが無いように感じられるが、必ずしもそうではない。
　この節では、多態性を用いてザックリ捉えるメリットについてソースコードを見ながら具体的に紹介していく。

　たとえば、5人のキャラクター(Heroが2人、Thiefが1人、Wizardが2人)が旅をするゲームを考えてみる。
　この5人は1つのパーティ(冒険をするためのチーム)を組んでいる。かれれが宿屋に泊まり、
　全員のHPを50ずつ回復するプログラムを書く場合、p456のようなコードになるだろう。
　このプログラムの宿泊処理には、2つの課題がある。
　1．コードの重複が多い → それぞれのHPを50増やす処理が何度も登場し、煩雑な記述になっている変数名を取り違える可能性あり。
　2．将来的に多くの修正が必要 → パーティの人数が増えた場合、宿泊処理に行を追加する必要がある。
　　 また、インスタンス変数名が変更になったらコードを修正しなければならない。

　しかし、多態性と配列を上手に組み合わせれば、この問題は解決する。p457のコードを見るとわかる。
　ポイントは3行目でCharacter配列を使っている点。従来のやり方で5人のインスタンスを「厳密に」HeroやThiefとして
　扱おうとする限り、それらを一括しては扱えない。しかし、それぞれをCharacterだとザックリみなせば「どれもキャラクター」なので
　5つのインスタンスをCharacter配列にまとめ、ループを回して一括で処理することも可能になる。

・今までのattack()メソッドは、attack(Matango m)のように特定の敵クラスを引数に取っている形だったため、
　attack(Goblin g)やattack(Slime s)などのように敵ごとに処理を分ける必要があったが、これではコードの重複が多くメンテナンスが大変。
　また、将来新たなモンスターが増えるたびにattack()メソッドも増やさなければならない。
　そこで、attack()メソッドをattack(Monster m)のように修正すると、攻撃する相手は「ザックリ捉えてモンスターならなんでも受けつける」
　という表明になる。このようなattack()メソッドであればMonsterクラスを継承しているSlimeやGoblin、そして将来登場する
　モンスターたちも攻撃することができる。

・多態性の真価は、これまで学んだ次の2つを組み合わせた時に発揮される。

　1．ザックリ捉えてまとめて扱う → 厳密には異なるインスタンスをまとめて扱える。
　2．メソッドの動作は中身の型に従う → 格納された箱の型に関わらず自身の型のメソッドが動作する。

　p460のコードのように、指示を出す側(メソッドを呼び出す側)は、それぞれのモンスターに対して同じように
　「とにかく逃げろ」と、いいかげんな指示を繰り返しているだけ。一方、モンスターたちは「逃げろ」と言われたら、
　きちんと独自の方法で逃げる。どう逃げるかは自分で理解しており、その方法(自分のクラスに定義されたrunメソッドの内容)
　を使って逃げるのだ。このように、「呼び出し側は相手を同一視し、同じように呼び出す」のに、
　「呼び出される側は、きちんと自分に決められた動きをする(同じ呼び出し方から、多数の異なる状態を生み出せる)」
　という特性から「多態性」という名前が付けられている。

・これからこの章で学ぶオブジェクト指向三大機能の1つである「カプセル化」は、
　これまでとは逆に、我々ができることを制限するための道具。Javaに備わっている「カプセル化」とは、具体的にはフィールドへの
　読み書きやメソッドの呼び出しを制限する機能。たとえば、「このメソッドはAクラスからは呼び出せるけど、Bクラスからは呼び出せない」
　「このフィールドの内容は、誰でも読めるけど、書き換えは禁止」といった制約を実現できる。

　「大切なモノに対するアクセスは不自由な方が良い」ことを我々は現実世界でもよく知っている。
　軍事施設では登録された人しか立ち入れないように塀に囲まれ、門には守衛がいるなどの制限があるからこそ
　次のようなメリットを享受できる。
　「悪意のある人が軍事施設に入り、ミサイルを発射してしまうことを防げる。」
　「子どもがうっかり軍事施設に入り、ミサイルを発射してしまうことを防げる。」
　「万一、何者かがミサイルを発射した場合、登録された人に犯人を絞り込める。」
　このように、情報へのアクセスや動作の実施について、「誰に何を許すか」を定めて制限することを「アクセス制御」という。
　Javaにおけるカプセル化とは、大切な情報(フィールド)や操作(メソッド)にアクセス制御をかけることにより、
　悪意や間違いによるメンバの利用を防止し、想定しない利用が発生したときには、その原因箇所を特定しやすくするためのしくみ。

・アクセス制御の方法を学ぶ前に、「アクセス制御されないプログラムの怖さ」をRPGの開発プロジェクトを例に考えてみる。
　p469の様々なメソッドを持つHeroクラスのコードを例に考える。この時、敵と戦っていないのに勇者のHPがマイナス100になっている。
　原因は、新入社員Aさんが開発した「宿屋クラス」内の記述ミスだった。h.hp = -100;としてしまったのだ。
　その翌日、今度は冒険中にお城で会話をすると、なぜか勇者が理由もなく休止してゲームオーバーになる、という問題が見つかる。
　原因を調査すると、またもやAさんが作ったコードの「王様クラス」に問題があった。h.bye()を呼ぶつもりが
　h.die()を呼んでしまっていた。誰かに「bye()を呼べ」と指示されたのをdie()と聞き間違えたのか？この一連の不具合は
　Aさんの不注意やスキル不足がきっかけで起こったものの、見方を変えれば「HPをマイナス100に設定できる」
　「王様が会話中に勇者を殺せてしまうこと」にも問題がある。
　もし、プログラムに次のようなアクセス制御が盛り込まれていれば、このような不具合は事前に見つかったはず。

　「Heroクラス以外からは勇者のhpフィールドに値を設定できない。」
　「dieメソッドを呼べるのはHeroクラスだけである。」

　カプセル化はこのようなアクセス制御を実現し、想定外に発生する不具合を未然に防ぐためのしくみである。
　人間は必ずミスをするため、不具合の原因を「人」に求めるのではなく、「ミスを未然に防ぐ仕組みがないこと」に求めるべき。

・Javaではメンバ(フィールドおよびメソッド)に対してアクセス制御の設定を行うことができる。
　しかし、各クラスのメンバに「Aクラス、Dクラス、Rクラスからの利用は許す」「Bクラス、Zクラスからの利用は許す」
　のように細かく指定すると、とても手間がかかってしまうし、わかりにくい。
　そこで、以下のように、4段階からアクセス制御のレベルを選ぶ仕組みになっている。

　private → 指定方法はprivate。自分自身のクラスのみアクセスを許可する。
　package private → 指定方法は何も書かない。自分と同じパッケージに属するクラスのみアクセスを許可する。
　protected → 指定方法はprotected。自分と同じパッケージに属するか、自分を継承した子クラスのみアクセスを許可する。
　public → 指定方法はpublic。全てのクラスにアクセスを許可する。

　privateやpublicなどは「アクセス修飾子」と呼ばれ、フィールドやメソッド宣言の先頭に記述する。

・Heroクラスのhpフィールドをprivateにすると、宿屋クラスのcheckInメソッドでは
　「hpフィールドはprivateなのでアクセスできない」というコンパイルエラーが発生するようになる。
　しかし、勇者のhpフィールドが一切変更できなくなるわけではない点に注意する。privateなフィールドであっても、
　同じクラスのメソッドからであればHeroクラスのsleepメソッドのようにthisを用いて読み書きすることができる。
　宿屋クラスのcheckInメソッドでは、勇者のHPフィールドに直接100を代入できない代わりに、
　sleepメソッドを呼び出すように修正すればよい。

・どのメンバにどのアクセス修飾子を指定すべきか、ほとんどのケースで通用する基本のパターン(定石)が以下となる。

　フィールドは全てprivate
　メソッドは全てpublic

　とりあえずは、このパターンに沿ってアクセス修飾を行う。その後、Heroクラスのdieメソッドのように、
　クラス内部だけで利用するメソッドのみをprivateに指定し直すような微調整をすればよい。

・クラスは特別な理由がない限り、publicで修飾するのが一般的。

・hpフィールドをprivateにしたからといって、外部のクラスからhpフィールドの値を変更できないかというと、そんなことはない。
　外部のクラスからであっても、attack()メソッドを呼べばHPを2減らすことができ、sleepメソッドを呼べばHPを回復できる。
　この時、hpフィールドの値を変化させるには、必ずattack()かsleep()を経由しなければならない点に注目する。
　勇者のHPを増減させるには、このどちらかのメソッドを経由するほかない。つまり、他のクラスの開発者がバグを含んだコードを
　書いたとしても、勇者のHPをマイナス100に設定することは不可能。もし万が一、HPに異常な値が設定される不具合に直面しても、
　そのときはattack()かsleep()のどちらかの処理に間違いがあると簡単に予想できるため、不具合の修正もスムーズにできるだろう。

・Heroクラスには名前を格納したnameというフィールドがある。勇者の名前は、様々な場面で多くのクラスから利用される。
　しかし、Heroクラスの全フィールドをprivateに設定すると、このKingクラスではnameにアクセスできないコンパイルエラーが発生してしまう。
　そこで、Heroクラスに勇者の名前を取得できるようなgetNameメソッドを追加し、Kingクラスではnameフィールドにアクセスしたい部分を
　getName()を呼び出すように修正すれば完成する。このgetNameメソッドはattackメソッドとは異なり、単にnameフィールドの中身を呼び出し
　もとに返すだけの単純なメソッド。このようなメソッドを総称して「getterメソッド」という。
　ある特定のフィールド値を取り出すだけのメソッドは、すべてgetterメソッドといえる。
　このgetterメソッドの書き方にも以下のような定石がある。

　public フィールドの型 getフィールド名() {
    return this.フィールド名;
}

　例外として戻り値がboolean型の場合のみisXxxx()というメソッド名にすることがある。
　たとえば、開発現場で「nameのgetter」といった言葉が飛び交うことがある。これはnameフィールドに対するgetterメソッド、
　つまりgetNameメソッドのことを指している。

・getterメソッドとは逆に、ある特定のフィールドに指定された値を代入するだけのメソッドを「setterメソッド」という。
　setterメソッドも、その記述方法には以下のような定石がある。

　public void setフィールド名(フィールドの型 任意の変数名) {
    this.フィールド名 = 任意の変数名;
}

　なお、このコードの代入式では左辺にthis.を忘れると大事故につながることを再認識しておく。

・getterとsetterは「アクセサ」と総称される。せっかくnameフィールドをprivateにして外部のアクセスから守ったのに、
　またアクセサを用意して外部に開放したらprivateにした意味がないように思えるが、
　そんなことはなくアクセサには重要な存在価値がある。カプセル化を行う前と行った後で、
　どちらもnameフィールドの読み書きができることに違いはない。むしろコードの行数が増えるため、getterやsetterの利用に
　意味を感じられないかもしれない。しかし、getterとsetterには以下のようなメリットがある。

　1．Read Only、Write Onlyのフィールドを実現できる
　　　→ setNameメソッドを削除すれば、nameフィールドを外部から読めるが書き換えられない(Read Only)フィールドにできる。
　　　　実務でも、外部から自由に読めても良いが変更されては困るフィールドが必要になる場面があるが、
　　　　その際に多用されるテクニック。また、あまり使われないが、setterメソッドだけを準備して外部から自由に
　　　　書き換えできるが読めない(Write Only)フィールドも作成可能。

　2．クラスの内部設計を自由に変更できる
　　　→ 例えば将来、何らかの理由でnameというフィールド名をnewNameに変更したくなったとする。
　　　　もしアクセサを準備せず、他のクラスから直接nameフィールドを読み書きしていた場合、他のクラスの全ての開発者に
　　　　「アクセスするフィールド名を変更してもらうお願い」して回らなければならない。
　　　　アクセサを用意していれば、アクセサ内でフィールドを使っている箇所のみ修正するだけで済む。

　3．フィールドへのアクセスを検査できる
　　　→ クラス外部からnameフィールドの値を書き換えるには、setterを使う必要が生じる。つまり、setterを実行せずに
　　　　nameフィールドを書き換えることは不可能。この事実を利用して、設定されようとしている値が妥当かをsetterで
　　　　検査するのもJavaプログラミングの定石。if (name == null) なら処理を中断させるなどのコードを入れて、
　　　　値の妥当性をチェックすることが可能となる。

・「どのように間違っても、どのような悪意を持ったアクセスでも、外部から絶対に不正な値を設定できない」
　安心・安全なクラスを目指して、検査を徹底させた強固なsetterを書くように心がける。

・別パッケージのクラスから見えなくなってしまうpackage privateクラスだが、その代わりにpublicクラスでは許可されない
　以下の2つのことが許される。

　1．クラスの名前はソースファイル名と異なってもよい。
　2．1つのソースファイルに複数のクラスを宣言してもよい。

　これまでは「1つのファイルに1つのクラス」「ファイル名=クラス名」が原則だとしてきたが、
　より正確には「1つのファイルに1つのpublicクラス」「ファイル名=publicクラス名」というルール。
　publicがついていないクラスは、どのソースファイルにいくつ宣言されても構わない。
　なお、ソースファイルにpublicクラスが1つも含まれない場合、ソースファイル名は自由に決めることができる。

・特に重要なメンバのアクセス制御では、特別な理由がない限り、フィールドはprivateとして外部から隠し、
　必ずgetter/setterメソッド経由でアクセスするのが定石。フィールドはメソッドによって守られており、
　外部から直接アクセスできないようにするのだ。p489のように、外部から直接触られないよう、メソッドという殻(カプセル)
　によってフィールドが保護されているように見えることから、このしくみには「カプセル化」という名前がついている。

・なぜメソッドは保護しないのにフィールドは保護するのか？
　それは、メソッドの処理内容はプログラミング段階で決定し、一度コンパイルされればプログラム実行中に変化することはない。
　一方、フィールドの値は、プログラムが動作する間に刻々と変化していく。
　そのため、動作中に異常な値になる危険性も十分にあり得る。不具合の多くは、フィールドに予期しない値が入ってしまうために発現する。
　だからこそプログラムの不具合を減らすには、メソッドよりもフィールドを保護することが重要なのである。
　プログラムの不具合を防止するために、どんどんカプセル化を活用していく方が良い。適切にカプセル化されていれば、
　インスタンスは大切なフィールドを直接外部にさらすことなく、互いに公開したgetter/setterやその他のメソッドを呼びあいながら
　安全に連携できる。

・継承は確かに華やかな機能だが、カプセル化こそがオブジェクト指向の本質を支えている。
　オブジェクト指向の本質を思い出すと、システムやプログラムは突き詰めれば現実世界における何らかの相互作用を自動化するためのもの。
　そして、現実世界の登場人物たちの動きを、そっくりそのまま仮想世界に再現するのがオブジェクト指向の基本的な考え方。
　では、このオブジェクト指向の世界において、バグや不具合とはいったい何だろうか？それは、即ち次の状態にほかならない。

　「不具合とは、現実世界と仮想世界が食い違ってしまうことである。」

　実際の勇者は元気なのに、ゲームではなぜかHPがマイナス100になっている状態や、実際の在庫数は800なのに、
　システムではなぜか80になっている状態が発生してしまうからバグなのだ。しかし、カプセル化を使えば、どのように利用されても
　フィールドに不正な値が入ってしまうことのない「現実の登場人物と矛盾しないクラス」を作ることができる。
　そして、その「現実の登場人物と矛盾しないクラス」を集めてプログラムを作れば、「現実世界と矛盾しないプログラム」になる、
　という考えがカプセル化の本当の狙い。これまでに学んできた継承や多態性に比べれば、カプセル化は比較的簡単で、
　文法や効果にも華やかさはない。しかし、現実世界を忠実にまねるというオブジェクト指向の本質と直結している、
　最も重要な位置づけにある機能の1つだといえる。

・実は、Javaの「全てのクラスがtoString()を持っている」のである。
　「メソッドもフィールドも一切定義していないクラスのtoString()を呼び出せる」のは、
　Javaには次のような仕組みが備わっているから。

　「あるクラスを定義する時、extendsで親クラスを指定しなければ、java.lang.Objectを親クラスとして継承したとみなされる。」

　extendsを指定しなくても必ずObjectクラスを継承するという事実は、「Javaでは親なしのクラスを定義できない」と言うことに他ならない。
　つまり、public class Empty {} のように何もないクラスを作ったとしても実際は public class Empty extends Object {}
　という定義と実質的に同じものである。これまで紹介してきた様々なクラスも、その親クラスを順に辿っていくと、
　最終的にはjava.lang.Objectクラスに到達する。APIリファレンスを調べると、全クラスの祖先であるObjectクラスには、
　次のようなメソッドが定義されているのがわかる。

　equals() → あるインスタンスと自分自身が同じかを調べる。
　toString() → 自分自身の内容の文字列表現を返す。

・全クラスの祖先であるjava.lang.Objectクラスがわざわざ準備してある理由には、次の2つが考えられる。

　1．多態性を利用できるようになるから
　　　→ 全てのクラスがObjectを先祖に持つので、「全てのクラス is-a Object」といえる。
　　　　あらゆるクラスは「ザックリ見れば、どれもObject」として同一視できる。
　　　　これは、Object型の変数にはどんなインスタンスでも代入できることを意味する。
　　　　また、引数としてObject型を用いると、どんなインスタンスでも渡せるメソッドを作ることもできる。
　　　　このようにObject型の変数は、あらゆる参照型のインスタンスを格納できる。
　　　　格納できないのは、基本データ型(intやlongなど)の情報だけ。

　2．全クラスが最低限備えるべきメソッドを定義できるから
　　　→ Javaのクラスであれば、最低限備えておいた方が良い機能がある。
　　　　たとえば、インスタンス同士の内容が同じかをチェックしたり、インスタンスの内容を文字情報として表示したりする機能。
　　　　Objectクラスにequals()やtoString()などが定められているおかげで、我々はクラスの種類を気にすることなく、
　　　　常に同じ方法で内容を比較したり表示したりできる。

・Objectクラスに定義されているtoString()は「型名@英数字」という形式で情報を表示するという極めてシンプルな処理内容になっている。
　toString()を呼ぶだけでそのクラスがどういったクラスなのかを表示したい場合は、
　そのクラスでtoString()をオーバーライドする。

・System.out.println()という命令は、渡されたオブジェクトのtoString()を呼び出して得られえる文字列表現を画面に表示するため、
　クラスの情報を知るために System.out.println(インスタンス変数.toString()); は System.out.println(インスタンス変数);
　としても同様の結果を得ることができる。

・equals()は、2つのインスタンスが同じ内容かを判定する目的で、if (h1.equals(h2) == true) のように用いられる。
　同じかどうかの判定にはif (h1 == h2)という書き方もある。しかし、「==を使った判定とequalsを使った判定では意味が異なること」
　に注意が必要。前者の比較は「等値」であるか、後者は「等価」であるかを判定する。
　等値とは、同一の存在であることを意味する。等価とは、同じ内容であることを意味する。
　イメージはp507の図を参照。

　何の準備もなく自分で作ったクラスのequals()を呼び出しても、上手く動かない。
　例のコードでは内容が同じはずの2つのHeroインスタンスを比較しているが、実行すると画面には
　「違う内容です」と表示されてしまう。実は、Objectクラスから継承されるequals()の処理内容は
　public boolean equals(Object o) { if (this == 0) { return true; } else { return false; } } のようになっている。
　Objectクラスでは、とりあえず等値ならtrueを返すつくりにしてある。そもそも等価かどうかは、機械的に判定できない。
　なぜなら、「何をもって意味的に同じものとみなすかの判断基準はクラスによって異なり、一律には決められないから」である。
　たとえば、名前が「ミナト」の勇者と「ﾐﾅﾄ」の勇者も同じものとみなすかどうかは、作るゲームによって異なるだろう。
　そこで、クラスの開発者は、そのクラスのインスタンスについて、意味的に同じとみなす考え方をequals()のオーバーライドという形で
　指定しなければならない。

・新しくクラスを開発したら、toString()とequals()をオーバーライドする必要性を検討する。
　なお、JavaAPIとして準備された多くのクラスは、適切にtoString()やequals()をオーバーライドしてある。
　たとえば、次の章で学ぶ日付を表すDateクラスはtoString()を適切にオーバーライドしているため、
　System.out.println()などにインスタンスを渡すと、「Wed Jan 17 16:05:55 JST 2024」などの意味の分かる内容で表示される。

・JavaAPIを利用するにあたって、Object型と並んで欠かせないのが、静的メンバに関する知識。
　「静的メンバ」とは、staticキーワードが付けられたフィールドやメソッドのことで、JavaAPIで提供されるクラスでも広く活用されている。
　我々は、オブジェクト指向に基づいて作成するメソッドは、特別な事情が無い限り、staticをつけないと学んだ。
　そしてその事情とは、「インスタンスの独立性」という概念とかかわりがある。
　インスタンスの独立性とは、newによって生成される個々のインスタンスは基本的に独立した存在であるというオブジェクト指向の基本原則。
　この原則によれば、仮想世界に生み出されたそれぞれの勇者インスタンスが持つフィールドhpには、それぞれ別の値を格納できる。
　たとえば勇者3人がパーティを組んで冒険するRPGを作る場合を考える。Heroクラスから生成されるインスタンスでは
　name、hp、moneyフィールドを3人の勇者が別々に持つことになる。しかし、様々なクラスを作成する中で、各インスタンスで共有したい情報が
　登場する場面がある。たとえばRPGなら、パーティを組んで行動しているので、お財布は全員で1つとする方が自然。
　このとき、財布は「インスタンスに1つ」ではなく「Heroクラスに1つ」あればよいことになる。
　同じクラスから生成された複数のインスタンスで1つのフィールドを共有したい場合には、フィールド宣言の先頭に「static」キーワードをつける。
　staticを指定したフィールドは、特に「静的フィールド」と呼ばれ、以下の3つの特殊な効果をもたらす。

　1．フィールド変数の実体がクラスに準備される
　　　→ 通常、フィールドが格納される箱(領域)は個々のインスタンスごとに用意されるが、静的フィールドの箱はインスタンスではなく、
　　　　クラスに対して1つだけ用意される。イメージで考えるならば、「勇者の金型」の上にmoneyの箱が準備される状態になる。
　　　　このHeroクラスに準備された箱(静的フィールド「money」)を読み書きするには Hero.money と記述する。

　2．全インスタンスに、箱の分身が準備される
　　　→ 共通の財産である所持金が格納される変数(Hero.money)は、あくまでも金型に作られる。
　　　　しかし同時に、h1やh2といった各インスタンスにもmoneyという名前で「箱の分身」が準備され、
　　　　金型の箱の別名として機能するようになる。つまり、h1.moneyやh2.moneyという分身の箱に値を代入すれば、本物の箱Hero.moneyにその値が代入される。

　3．インスタンスを生み出さなくても共有が可能になる
　　　→ Hero.moneyは金型に作られる箱である。したがって、まだ1つも実体(インスタンス)が生み出されていなくても利用できる。

　なお、静的フィールドはクラス(金型)にフィールド(箱)が所属するという特徴から、「クラス変数」と呼ばれることもある。
　実際の開発でもあまり頻繁に使われるものではなく、見かけるのは定数と一緒に宣言する使い方。
　フィールドに対するstaticは、finalと共に宣言され、インスタンス間で定数を共有する目的で利用されるのが一般的。
　これをpublic static final コンビネーションという。

・staticキーワードがついているメソッドは、「静的メソッド」または「クラスメソッド」と呼ばれ、
　静的フィールドとあわせて静的メンバと総称される。静的メソッドを宣言すると静的フィールドと同様に以下の3つの効果が現れる。

　1．メソッド自体がクラスに属するようになる
　　　→ 静的メソッドは、その実態が各インスタンスではなくクラスに属するため、クラス名を使って呼び出せるようになる。

　2．インスタンスにメソッドの分身が準備される
　　　→ インスタンスにも分身が作られるため、インスタンス変数名からも呼び出せるようになる。

　3．インスタンスを生み出さなくても呼び出せる
　　　→ 静的フィールドと同様に、1つもインスタンスを生み出していない状況でも、静的メソッドを呼び出せる。

　特に3番目で「newしなくても静的メソッドは呼び出せる」ことがわかる。これでmainメソッドがstaticでなければならない理由に説明がつく。
　それは、mainメソッドが最初に呼び出されて動くときには、まだ仮想世界には1つもインスタンスが存在していないから。

・静的メソッドの利用には重要な制約がある。それは、静的メソッドでは、「staticがついていないフィールドやメソッドは利用できない」ということ。
　静的メソッドsetRandomMoney()の内部で、フィールドnameへアクセスしようとすると、この処理はエラーとなる。
　静的メソッドsetRandomMoney()は、「まだ1つも勇者インスタンスが存在しない状況でも呼び出される可能性があるメソッド」である。
　もし仮想世界に1つも勇者インスタンスが無い状況でこのsetRandomMoney()が呼び出されてしまったら、自分自身のインスタンスのメンバである
　「this.name」をうまく処理できないのは明らか。したがって、静的メソッド内部では、静的メンバしか利用できない決まりになっている。

・静的メンバはオブジェクト指向の基本原則に風穴を開ける仕組みともいえる。そして、重要な原則を崩すからには、様々な代償を伴う。
　静的メソッドの中では静的フィールドしか使えない制約があるばかりでなく、静的フィールドの内容を他のインスタンスから意図せず書き換えられたり、
　同時アクセスで破壊されたりするなどのリスクもある。「勇者が共有する財布」も、Walletクラスを作ってそれぞれの勇者が利用すれば
　わざわざ静的メンバを使う必要はない。そのため、定数宣言やmainメソッド以外では、我々が積極的に静的メンバを用いる機会は多くはないだろう。
　しかし、JavaAPIでは、主に次の2つの理由から静的メンバを備えている場合があるので、その意図を読み解いたうえで利用する必要がある。

　1．newせずに手軽に呼び出すため
　　　→ たとえば「Integer.parselnt()」は、引数として与えられた文字列を数値に解釈して返すAPI。
　　　　このメソッドは、正確にはjava.lang.Integerクラスのメソッドだが、静的メソッドとして準備されているからこそ、
　　　　Integerクラスをnewすることなく呼び出せる。newが不要だと開発者はラクだし、JVMも嬉しい。
　　　　インスタンスの生成はCPUやメモリを多く消費するため。

　2．静的メソッドを使ってインスタンスを生成するため
　　　→ APIクラスの中には、性能上または管理上の理由から、「外部からのインスタンス化を禁止している」クラスがある。
　　　　これらのクラスは、ほとんどのケースでインスタンス生成を担う静的メソッドが準備されており、
　　　　我々はそのメソッドを呼び出してインスタンスを生み出す。

・文字列処理はStringクラスに備わっているメソッドを利用すれば簡単に実現できる。

・文字列の内部から、別の文字列(または文字)を探すためのメソッドも複数準備されているが、
　それらのメソッドは次の2つに分類される。

　1．含まれるか否かだけを判定するもの
　2．「文字列のどこに含まれているか」という位置情報を返すもの

・indexOf()やlastIndexOf()は、引数で指定した文字列(「部分文字列」という)が、ある文字列のどこに登場するかを探すためのメソッド。
　「文字列の先頭位置を0」として、部分文字列が見つかった場合にはその位置を、見つからない場合にはマイナス1を返す。

・文字列の一部を別の文字列(または文字)として切り出すメソッドも準備されている。
　charAtメソッドは、何文字目を切り出すかを引数で指定する。substringメソッドで引数1つを指定した場合、
　指定位置より後ろにあるすべての文字列が返される。引数を2つ指定した場合、2つの指定位置の間にある部分文字列が返される。
　これらのメソッドでも、「先頭位置は0」と指定する点に注意する。

・trimメソッドは、先頭や末尾に付いた余計な空白やタブ文字(\t)を簡単に削除できるため、
　たとえば、ユーザーが入力した文字列から不要な文字を取り除くなどの用途でよく用いられる。
　ただし、「全角スペースは除去されない」点に注意する。

・2つ以上の文字列をつなぐことを、文字列の連結という。もっとも簡単な連結方法は、+演算子を用いる方法。
　しかし、実は+演算子を使う以外にも連結の方法は存在し、しかもその方法のほうが圧倒的に高速である。
　その方法が「StringBuilderクラス」を用いた連結である。StringBuilderインスタンスは、
　内部に連結した文字列を蓄えるメモリ領域(バッファ)を持っている。このクラスを用いた連結は、以下の2つの手順で行うのが一般的。

　1．appendメソッドを読んでバッファに文字列を追加していく(必要に応じた回数を呼び出す)
　2．最後に1回だけtoString()を呼び、完成した連結済みの文字列を取り出す。

・Stringクラスは、あらゆる局面で利用されるクラス。そのためJava言語の開発者は、
　Stringクラスを作る際にいくつかの特別な配慮を行った。たとえば、危険な拡張を防止するためにfinalによる継承の禁止が宣言されている。
　さらにもう1つ、以下のように配慮されている。

　「Stringインスタンスが保持する文字列情報は、インスタンス作成時に初期化され、以後"二度と"変化しない」

　Stringクラスに限らず、インスタンス化の後に内容が絶対に変化しないように設計されたクラスを「不変である」と表現する。
　不変なクラスは、参照やスレッドと言う技術に関連したある種の複雑な不具合が原理的に起こりえないという特徴を持つため、
　プログラムのあらゆる箇所で利用されるStringクラスに採用されている。
　一見Stringインスタンスは中身を書き換えられるように見える。しかし、s = s + "world" を実行すると、
　実際には「古いインスタンスは捨てられて、新しいインスタンスが内部的に生成」され、結成後の情報が格納されている。
　つまり、+演算子による数万回の文字列連結は、内部でnewを数万回行うことを意味する。newによるインスタンス生成は、
　計算などに比べてJVMに大きな負荷がかかる処理なので、全体として極めて遅い処理になる。
　一方のStringBuilderは、「可変」なクラスとして設計されている。appendメソッドの呼び出しのたびに
　newを行うことなく、バッファを拡大しながら新たな文字列を追記していく設計となっているため高速なのである。
　なお、数回程度の文字列連結であれば、どのような方法を用いても性能に大差はない。その場合には、タイピング量が少なく
　コードが読みやすい+演算子を使うとよいだろう。

・APIリファレンスでStringBuilderを調べると、appendメソッドの戻り値が少し特殊であることに気づくだろう。

　メソッド宣言:public StringBuilder append(String s)
　戻り値の開設:このオブジェクトへの参照

　本来、バッファに文字列を追加するだけであれば、戻り値はvoidでよいはず。しかし、このように「自分自身」を戻り値として返すのは、
　以下のような呼び出し方を可能にするため。

　StringBuilder sb = new StringBuilder();
　sb.append("hello").append("java").append("world");

　このように、自身への参照を返すメソッドを連続して呼び出す方法は「メソッドチェーン」と呼ばれる。

・たとえば、プレイヤー名の条件を求めるために「入力チェック判定を行うメソッド」をいざ記述しようとすると、
　if (…) { return false; }を何回も記述しなければならないため、かなり大変な作業であることが分かる。
　しかし、Stringクラスの「matchesメソッド」を用いると、複雑だったメソッドが以下のように非常にシンプルになる。

　public boolean isValidPlayerName(String name) {
    return name.matches("[A-Z][A-Z0-9]{7});
　}

　プレイヤー名が条件に一致しているかの判定は、Stringクラスのmatchesメソッドをたった1度呼び出すだけで完了する。
　引数で与えている"[A-Z][A-Z0-9]{7}"と言う文字列は、「文字列パターン」または単にパターンといわれるもので、
　「文字列の形式的な条件」を「正規表現」という文法に従って記述している。
　また、matchesメソッドのように、文字列がパターンに従った形式を満たしている(マッチしている)かを照合する処理を
　「パターンマッチング」という。

・正規表現は、いくつかの特殊な記号を使って文字列パターンを指定する。
　パターンに含まれる文字にどのような意味があるかを見ていくと、

　通常の文字:その文字でなければならない。
　　→　パターン内に記述されたアルファベットや数字、ひらがな、カタカナ、漢字のような一般的な文字は、
　　　 基本的にそれと同じ文字を表す。たとえば、"ABC"と言うパターンは
　　　 「1文字目がA、2文字目がB、3文字目がCであること」という条件を示している。

　ピリオド:任意の1文字であればよい。
　　→　パターン中にピリオド記号があった場合、その部分には任意の1文字(何でもよいので必ず1文字)があればよい。

　アスタリスク:直前の文字の0回以上の繰り返し
　　→　パターン中にアスタリスク記号が含まれていた場合、その直前の0回以上の繰り返しを意味する。
　　　 たとえば"AB*"というパターンは、「1文字目はA、2文字目以降は0回以上のBの繰り返し」
　　　 という形式を示すので、「A」や「AB」、「ABBBBBBB」などが条件を満たす。

　ピリオド + アスタリスク:任意の1文字の0回以上の繰り返し
　　→　「全ての文字列を許す」という指示になる。

　波カッコ:指定回数の繰り返し
　　→　パターン中に波カッコで囲まれた数字が登場した場合、それは直前の文字の指定回数の繰り返しを意味する。
　　　 たとえば、"HEL{3}O"は、"HELLLO"というパターンと同じ意味。
　　　 そのほか、以下のような方法で様々な繰り返し回数を指定できる。

　　　　{n} → 直前の文字のn回の繰り返し
　　　　{n,} → 直前の文字のn回以上の繰り返し
　　　　{n,m} → 直前の文字のn回以上m回以下の繰り返し
　　　　? → 直前の文字の0回又は1回の繰り返し
　　　　+ → 直前の文字の1回以上の繰り返し

　角カッコ:いずれかの文字
　　→　パターン中に角カッコ記号で囲まれた部分がある場合、角カッコの中のどれか1文字に当てはまることを要求する意味となる。
　　　 たとえば"UR[LIN]"というパターンは、「1文字目がU、2文字目がR、3文字目がLかIかNであること」を意味する。

　角カッコ内のハイフン:指定範囲のいずれかの文字
　　→　角カッコ中にハイフン記号が含まれる場合、その両端にある文字を含む範囲の任意の1文字であることを意味する。
　　　 "[a-z]"というパターンは、a～zのいずれかの文字(つまり全てのアルファベット小文字)とマッチする。
　　　 なお、全ての数字[0-9]など多用されるパターンh、\で始まる次の「文字クラス」としてあらかじめ定義されている。

　　　　\d → いずれかの数字。[0-9]と同じ。
　　　　\w → 英字、数字、アンダーバー。[a-zA-Z_0-9]と同じ。
　　　　\s → 空白文字。スペース、タブ文字、改行文字など。

　ハットとダラー:先頭と末尾
　　→　パターン中のハット記号は文字列の先頭を、ダラー記号は文字列の末尾を表す。

・正規表現パターンを用いて行える処理は、文字列照合だけにとどまらず、「文字列の分割」や「置換」もより効率的に記述できる。
　Stringクラスのsplitメソッドを使うと、1つの文字列を複数に分割できる。String s = "abc,def:ghi" のとき、
　String[] words =  s.split("[,:]")とすれば、words配列にカンマとコロンの場所で区切られた文字がそれぞれ入る。
　replaceaAllメソッドを使うと、文字列中でパターンに一致した箇所を別の文字列に置換できる。

・通常、Javaでは文字列情報をStringインスタンスの形で利用するのが一般的。
　しかし、まれに文字列情報を以下のような形式で扱いたい場合がある。

　char配列 → 文字列に含まれる各文字を1文字ずつに分解し、char型の配列の各要素に格納した状態。
　　　　　　 たとえば、ループを回しながら1文字ずつゆっくり画面に表示したい場合などに利用する。

　byte配列 → 文字列の情報を文字コード対応表を用いてバイト列に変換し、1バイトずつ配列に格納した状態。
　　　　　　 文字列情報を指定した文字コードでファイルに書き込んだりする場合に利用する。

　Stringインスタンスをchar配列やbyte配列に変換するには、toCharArrayメソッドやgetBytesメソッドを利用する。
　逆に、char配列やbyte配列をStringインスタンスに変換するには、new String(data)のようにしてコンストラクタの引数に渡す。

・キャラクターの状態を表示するようなプログラムでは、これまでの方法で表示するとキャラクターの名前や職業などの
　文字列長が違うため、行ごとの表示の桁が揃わない。lengthメソッドを使って自力で空白を入れて桁を揃えるのも不可能ではないが
　かなり大変。幸いStringクラスには、整形した文字列を組み立てるための静的メソッドformat()が準備されている。
　String.format("%d日で%sわかる%s入門",3,"スッキリ","Java")のように記述する。
　formatメソッドの第一引数に指定するのは、組み立てる文字列のひな形を指定する「書式指定文字列」と呼ばれるもので、
　専用の記法を用いて記述する。特に%記号の部分は「プレースホルダ」と呼ばれ、
　第二引数以降で指定した具体的な値が順に流し込まれる場所になる。プレースホルダは以下の文法に従って記述する。

　% 修飾 桁 型

　　　修飾 → 省略可。オプションを指定する。,は3桁ごとにカンマを入れる、0は空き領域を0埋めする、-は左寄せ、+は符号を強制表示。
　　　桁 → 省略可。表示桁数を指定する。n.m形式で指定した場合、全体n桁、小数点以下m桁での表示となる。
　　　型 → 必須。dは整数、sは文字列、fは小数、bは真偽値。

　ただし、プレースホルダは日本語(全角文字)が混ざると崩れてしまうこともあるので注意して使う。
　なお、format()を使って文字列を作ると同時に画面に出力したい場合は、代わりにSystem.out.printfメソッドを使うと便利。
　整形だけしたいならformat、表示までしたいならprintfを使うとよい。

・format()やprintf()には、必要に応じて引数をいくつでも渡せる。これは、「可変長引数」という仕組みを使ってメソッドが宣言されているから。

　public static format(String format, Object... args)

　上記のように引数リストの型の後ろにピリオドを3つ並べると、その方の引数をいくつでも渡せるようになる。
　ただし、1つのメソッド宣言でこの指定を使えるのは1回だけ。
　可変長引数に渡された値は、配列として取り出すことができる。上記の例では、args自体はObject配列として扱われ、
　args[0]やargs[1]として実引数を取得できる。
　しかし、実引数にObject[]やString[]などの配列が渡された場合、複数の引数が一度に与えられたのか、
　1つの配列が与えられたのか、JVMは判別できない。そこで、実引数を1つの配列として渡したい場合には、
　Object型にキャストする決まりになっている。

・どのようなシステムでも、日時情報の取り扱いを避けて通ることはできない。
　Javaでは日時の情報を表すための形式が4つあり、それぞれ用途に合わせて使い分ける必要がある。
　基本となる2つの形式は以下の通り。

　1．long型の数値
　　　→ 基準日時である1970年1月1日0時0分0秒(これを「エポック」という)から経過したミリ秒(1/1000秒)数で
　　　　日時情報を表現する方法。たとえば、1694984000000というlong値は「2023年9月18日5時53分20秒」を意味する。
　　　　このlong型による形式はシンプルであるため、コンピュータにとっては扱いやすく、JVM内部の様々な部分で利用されている。
　　　　たとえば、System.currentTimeMillisメソッドを呼べば、現在日時をlong型で得られるため、p550のようなコードを書けば
　　　　「処理時間の計測」を簡単に行うことができる。しかし人間はこのlong値から「年・月・日・時・分・秒」を読み取ることができない。
　　　　また、long型は日付情報以外の数値の格納にも利用される方なので、必ずしも変数の中身が日時情報だと断定できない。

　2．Date型のインスタンス
　　　→ long型の課題を克服するために広く用いられているのがjava.util.Dateクラス。
　　　　このクラスは、内部でlong値を保持しているだけだが、「Date型の変数であれば、中身は日時情報である」と一目でわかるため、
　　　　「Javaで日時の情報を扱う場合に最も利用される形式」である。Dateインスタンスを生成して利用するには、以下の構文を用いる。

　　　　Date d = new Date(); → 現在日時を持つDateインスタンスの生成
　　　　Date d = new Date(long 値) → 指定時点の日時を持つDateインスタンスの生成

　　　　また、Dateインスタンスの内部に格納されているlong値を取り出すにはgetTime()を、
　　　　long値をセットするにはsetTime()を用いる。これらDateクラスの構文を用いて現在日時を表示するプログラムがp551のもの。

・java.util.Dateと似たクラスとして、java.sql.Dateというクラスがある。これはデータベースを利用したプログラムで利用するもので、
　通常の日時情報の格納には使わない。

・long値もDateクラスも、結局はエポックからの経過ミリ秒数を扱っている事実に違いは無く、人間が日付情報を扱うには
　不便な形である。そこで、人間にとって使いやすい2つの日時形式が以下となる。

　3．人間が指定しやすい「6つのint」形式
　　　→ 前述のSystem.currentTimeMillisメソッドを使うか、Dateクラスをnewすれば現在時刻は簡単に得られる。
　　　　しかし、ある特定の日時情報(たとえば2023年9月18日5時53分20秒)を人間がキーボードやマウスなどで入力する場合には
　　　　「年・月・日・時・分・秒」をそれぞれ整数(int値)として指定するのが一般的。

　4．人間が読みやすいString型のインスタンス
　　　→ 人間が読みやすいのは「2023年9月18日5時53分20秒」のような文字列としての形式。
　　　　画面に時刻を表示する場合、この形式に変換する必要がある。ただし、一口に文字列といっても、
　　　　様々な形式が考えられる点には考慮が必要。たとえば、「2023/9/18 5:53:20」という形式や、「23-09-18 05:53:20AM」
　　　　などの形式が考えられる。

・ここまでで我々は日時を表す4つの形式を学んだ。機械が扱いやすい形式としてのlong型とDate型、
　人間が扱いやすい形式としての文字列型と6つのint値。これら4つの形式を自由に利用するために、「Date型と6つのint値の相互変換」と
　「Date型とString型の相互変換」の2つを学んでいく。

・1つ目の「Date型と6つのint値の相互変換」には、java.util.Calendarクラスが準備されており、構文は以下の通り。

　「6つのint値」からDateインスタンスを生成する
　　　Calendar c = Calendar.getInstance();
　　　c.set(年,月,日,時,分,秒); または c.set(Calendar.～,値);　※～にはYEAR、MONTH、DAY_OF_MONTH、HOUR、SECONDなどを指定。
　　　Date d = c.getTime();

　Dateインスタンスから「6つのint値」を生成する
　　　Calendar c = Calendar.getInstance();
　　　Date d = new Date();
　　　c.setTime(d);
　　　int year = c.get(Calendar.YEAR);
　　　int month = c.get(Calendar.MONTH);
　　　int day = c.get(Calendar.DAY_OF_MONTH);
　　　int hour = c.get(Calendar.HOUR);
　　　int minute = c.get(Calendar.MINUTE);
　　　int second = c.get(Calendar.SECOND);

・Calendarクラスの「月」の取得・設定には、0～11を使用する。2月を設定する場合はc.set(Calendar.MONTH, 1)となる。

・2つ目の「Date型と文字列型の相互変換」には、java.text.SimpleDateFormatクラスが準備されており、構文は以下の通り。

　StringからDateインスタンスを生成する
　　　SimpleDateFormat f = new SimpleDateFormat(書式文字列);
　　　Date d = f.parse(文字列);

　DateインスタンスからStringを生成する
　　　SimpleDateFormat f = new SimpleDateFormat(書式文字列);
　　　date d = new Date();
　　　String s = f.format(d);

　書式文字列には「"yyyy/MM/dd"」や「"yyyy年MM月dd日"」のように、日付の書式を指定する。
　書式文字列に使うことができる主な記号は以下の通り。

　y → 年, M → 月, d → 日, H → 時(0～23), m → 分, s → 秒, K → 時(0～11), E → 曜日, a → 午前/午後

・なお、「Mon Sep 18 05:53:20 JST 2023」のような文字列でもよいならば、DateインスタンスのtoStringメソッドを呼び出すだけで取得できる。

・ここまでに学習したDateクラスやCalendarクラスは、Javaが誕生したばかりの頃から利用可能だった古参のAPI。
　Javaで日時情報をを扱う標準的な手法として長く利用されてきた一方、設計上の問題も多く抱えており、
　「使いにくい」「不具合につながるような使い方をしてしまいやすい」などの課題も指摘されてきた。
　DateやCalendarが抱えている代表的な問題としては以下の通り。

　1．使い方が紛らわしいAPIが存在する。
　　　→ 月の指定値が0～11になっているため、実際の月の数とずれているのはやや不親切な仕様といえる。

　2．並列処理で用いるとインスタンスの内容が壊れることがある。
　　　→ 複数の処理を同時に実行するスレッドというしくみを利用する場合に発生する問題。日付関連の処理は
　　　　さまざまな種類のプログラムのいたるところで記述されるため、無意識にスレッドと組み合わせて使ってしまう
　　　　リスクが比較的高いことが広く懸念されてきた。

　DateやCalendarは一見簡単そうに見えるが、本当に安全に使うのはとても難しい。
　Java開発者の間でDateクラスやCalendarクラスの評判があまりよくない背景には、このような問題以外にもいくつかの理由がある。
　これらのクラスは、日付や時刻を正確かつ便利に扱うために必要な機能を十分に備えておらず、いざ本格的に日時情報を取り扱おうとすると
　開発者は以下のような大きな負担を強いられてしまう。

　「最小でも"ミリ秒"単位でしか時間を扱えない」
　「私たちが日常利用する"あいまいな日時"を表せない」
　「私たちが日常利用する"時間の幅"を表せない」

・上記で挙げた課題を克服するためにJavaに加わったのが、新しい日時関連のクラス群である
　Time API(java.timeパッケージ)である。これら新しいAPIのクラスたちは、従来用いられてきたDateやCalendarと比較して
　直感的にわかりやすいAPI構造となっており、先述のスレッドと併用してもインスタンスの中身が決して壊れないよう設計されている。
　代表的なクラスとしてInstant,ZonedDateTime,LocalDateTime,Duration,Periodの5つがある。
　しかし、中には伝統的なDateとCalendarを使うためTime APIは積極活用しない現場もある。
　実業務の場合はチームの方針を確認したうえで活用するのが望ましい。
　ちなみにTime APIのjava.time.chrono.JapaneseDateクラスを用いれば、
　「令和〇〇年1月23日」のような和暦の情報を取り扱うことができる。

・「Instantクラス」は、新しい日時APIの内で最も基礎となるクラス。Instantは英語で「瞬間」を意味するが、
　その名の通り、エポックからの経過時間をナノ秒数で格納し、この世界における「ある瞬間」を指し示すことができる。
　旧来のAPIにおけるDateとほぼ同じ役割だが、ナノ秒単位で正確に瞬間を表せるのがポイント。
　「ZonedDateTimeクラス」も、Instant同様、ある瞬間を格納できるクラス。ただし、このクラスはエポックからの経過時間ではなく、
　たとえば「東京における西暦2023年8月10日 7時11分9秒 392881ナノ秒」という形式でその瞬間を格納、管理する。
　Calendarクラスの後継のようなクラス。つまり、「ある瞬間」を指し示すために2つの方法がある。なぜ2つの方法があるかと言うと、
　「年・月・日・時・分・秒・ナノ秒」の情報だけでは、この世界のある瞬間を正確に指し示すことはできない。
　なぜなら、同じ「2023年8月1日12時0分0秒0ナノ秒」であっても、東京に住む人とロンドンに住む人では違う瞬間を指すから。
　そこで、ZonedDateTimeは、どの都市の人を基準にするかを明確にするために、「タイムゾーン」と呼ばれる情報を含んでいる。
　タイムゾーンは「Asia/Tokyo」や「Europe/London」などの文字列で表現される情報で、その一覧はIANAという国際標準化団体で管理されている。
　Javaの世界では、タイムゾーン情報は「ZoneId」クラスのインスタンスとして扱う。

・Time APIの多くのクラスではnewが禁止されており、静的メソッドであるnow()やof()を使ってインスタンスを生成する。

・我々の日常生活を考えてみると、「こどもの日はいつか？」と聞かれれば、みんな「5月5日」と答えるだろう。
　しかしそこで、さらに「何年の？」「その日の何時？」と尋ねられると言葉に詰まってしまうはず。
　つまり、「私たちは普段、年・月・日・時・分・秒・ミリ秒などの内、一部の情報が欠落した"あいまいな日時情報"を使って生活している」のである。
　それにもかかわらず、これまでJavaには、私たちが日常的に使う「あいまいな日時」を格納できるクラスが存在しなかった。
　たとえば、DateクラスやCalendarクラスは、内部で「年・月・日・時・分・秒・ミリ秒・タイムゾーン」の全情報を保持する。
　また、TimeAPIで加わったZonedDateTimeも、全情報を厳密に保持する。そのため、私たちが最もよく使う「2023年1月2日3時4分5秒」のようなミリ秒や
　タイムゾーンを含まない日時情報は格納しづらかった。

　ZonedDateTimeやCalendarクラスのタイムゾーン部分にゼロを格納しておけばよい、などの考えが出るかもしれないが、
　オブジェクト指向の本質を思い出すと、タイムゾーン部分がゼロと言うのは、本来「世界標準時から時差ゼロ」、
　つまりロンドンなどのタイムゾーンを意味するものであって、「タイムゾーンを考慮しない」という意味ではない。
　このように、現実世界を正しく再現できない不都合は、数多くの混乱や不具合の原因となってきた。

　そこで登場したのが、「LocalDateTimeクラス」である。このクラスはZonedDateTimeとよく似ているが、タイムゾーン情報だけは格納しない。
　タイムゾーン情報が無いため、LocalDateTimeインスタンス単体では「どの瞬間を指し示しているのか」を確定できない。
　しかし、私たちが日常的に日時情報を格納するには最適なクラスと言えるだろう。

・LocalDateTimeから、さらにいくつかの情報を削ったクラスも提供されている。以下はそのクラス。

　　LocalDate → 年、月、日。誕生日など。
　　LocalTime → 時間。アラーム時刻など。
　　Year → 年。著作発表年など。
　　YearMonth → 年、月。カード有効期限など。
　　Month → 月。決算月など。
　　MonthDay → 月、日。日本の祝日など。

　上記で挙げたクラスは、あいまいさに違いはあるものの、すべて「時間軸上のある時点を指し示す情報を格納するクラス」という点で共通している。
　実際、これらのクラスは全てjava.time.Temporalインタフェースを実装しており、同様の動作をするメソッドには以下の共通の名前を使うように設計されている。

　　now() → 静的メソッド。現在日時からインスタンスを生成する。
　　of()/of～() → 静的メソッド。他の種類から変換してインスタンスを生成する。
　　parse() → 静的メソッド。"2024/4/12"などの文字列からインスタンスを生成する。文字列書式はDateTimeFormatterで指定する。
　　format() → 保持情報を"2024/04/12"のような文字列に変換する。文字列書式はDateTimeFormatterで指定する。
　　get～() → 格納する年や月の情報を取得する。～部分には、Year,Month,DayOfMonth,Hour,Minute,Second,Nanoなどが入る。
　　isAfter() → 引数で指定したインスタンスより未来の日付ならtrueを返す。
　　isBefore() → 引数で指定したインスタンスより過去の日付ならtrueを返す。
　　plus～() → 指定した分だけ未来の時点を返す。～部分には、Years,Months,Days,Hours,Minutes,Seconds,Nanosなどが入る。
　　minus～() → 指定した分だけ過去の時点を返す。～部分には、Years,Months,Days,Hours,Minutes,Seconds,Nanosなどが入る。
　　plus() / minus() → 指定した時間間隔(後述のPeriodやDuration)のぶんだけ未来または過去の時点を返す。

　基本的にnow(),of(),parse()を使ってインスタンスを取得する。newができない点に注意する。

・Javaには長らく「2つの日付の間隔」や「2つの時刻の間隔」を格納する標準的なAPIがなかった。
　そこでTime APIとして加わったのが「Durationクラス」と「Periodクラス」である。
　主に「時・分・秒」の単位で収まる比較的短い間隔を表す場合はDurationを使う。
　一方、サマータイムやうるう年なども考慮しながら日数ベースで期間を管理する必要がある場合は、Periodクラスを使う。
　両クラスとも、静的メソッドbetween()やofDays()、ofMonths()を使ってインスタンスを取得できる。
　また、LocalDateTimeなどのplus()やminus()の引数として利用することもできる。

・配列は「複数のデータを1つにまとめて扱う方法」の代表的なもの。
　このように、ある一定のルールに従ってデータを扱う形式をデータ構造というが、
　配列のように「順序をつけて並べて格納する」データ構造は特に「リスト」と呼ばれている。
　リスト以外には、重複許可・順序保証のList群にArrayList,LinkedList、重複不可・順序非保証のSet群にHashSet,LinkedHashSet,TreeSet、
　ペアの値を格納するMap群にHashMap,LinkedHashMap,TreeMapなどがある。

・ArrayListは配列とよく似た作りで、リスト構造でデータを格納できる入れ物クラス。
　ArrayListの使い方は配列ととても似ている。特筆すべき違いは、以下の3点。

　1．import文を記述する
　　　→ ArrayListクラスをはじめとするコレクションクラスはjava.utilパッケージに属しているので、
　　　　通常はimport文を記述して利用する。

　2．<>記号を使って、格納するインスタンスの型を指定する
　　　→ 文字列を格納する場合、配列では格納する型をString[]と記述していたが、
　　　　ArrayListではArrayList<String>と記述する。この<>記号を使った一風変わった表現は
　　　　「ジェネリクス」と呼ばれるJava文法の一種。<>記号の中身をHeroやDateに変えると、
　　　　ArrayListはどんな種類のインスタンスでも格納できる。
　　　　また、String[]で1つの型(String配列型)を表したように、ArrayList<String>で1つの型を表す。
　　　　ArrayListをインスタンス化する場合も、new ArrayLIst()ではなくnew ArrayLIst<String>
　　　　と記述する。

　3．宣言時のサイズ指定は不要、要素は随時追加できる
　　　→ 配列は宣言する際に、「箱をいくつ準備するか」を指定する必要があり、
　　　　後から箱の数を増やすことはできなかった。一方、ArrayListをはじめとするコレクションクラスは
　　　　宣言時に準備する箱の数を指定しない。なぜなら、「データを追加しようとしたときに
　　　　もし箱が不足していれば、自動的に追加されていく」から。

　配列の方がメモリ効率や性能は高い。しかし「自動的にサイズが増える特性」がとても便利なので、
　実際の開発現場でもArrayListが多く使われている。ArrayListがあるから配列は不要というわけではない。
　ArrayListをはじめとするコレクションフレームワークのクラスたちには、どうしてもできないことが1つだけある。
　コレクションクラスは「どんな型のインスタンスでも格納できるように作られている」のだが、
　「インスタンスでないものは格納できない」のである。
　つまり、「コレクションには、基本データ型の情報を格納することができない」ということである。

・上記から、もしテストの点数のようなint型の情報をArrayListに格納したい場合、そのままでは格納できない。
　そこでAPIには、8つの基本データ型に対応して「基本データ型の情報を中身に保持すること」を責務とする8つのクラスが
　用意されており、「ラッパークラス」と総称されている。たとえば、java.lang.Integerクラスは、
　中身にint型の数値を1つだけ持つインスタンスを使うためのクラス。
　他の基本データ型とラッパークラスの対応は以下の通り。

　byte → java.lang.Byte
　short → java.lang.Short
　int → java.lang.Integer
　long → java.lang.Long
　float → java.lang.Float
　double → java.lang.Double
　char → java.lang.Character
　boolean → java.lang.Boolean

　つまり、ArrayList<int>はダメでも、ArrayList<Integer>にしてIntegerインスタンスを入れればよい。
　しかし、いちいちInteger i = new Integer(35);のようにして、それからArrayListに格納するのは面倒。
　そこでJavaには、Integerなどのラッパークラス型のインスタンスとint型などの基本データ型のデータを
　相互に自動変換する、「オートボクシング」と「オートアンボクシング」という機能が備わっている。
　この機能を使えば、あたかもint型の値をArrayListに格納するような使い方ができる。
　しかし、ArrayListが内部で保持できるのはあくまでもInteger型のインスタンスであり、
　「ArrayList<int>」のような方を使うことはできない。なお、このような自動変換に頼らず、
　明示的に基本型とラッパークラスを変換したい場合、以下のようにvalueOf()や～Value()を使う。

　Integer i1 = Integer.valueOf(16);
　int i2 = i1.intValue;

・ArrayListを宣言するには、以下の構文を利用する。

　ArrayList<～> 変数名 = new ArrayList<～>();

　～の部分にはArrayListに格納するインスタンスの型名を指定する。右辺のインスタンス型名は省略可能。
　ArrayListは要素を操作するための様々なメソッドを備えている。
　その中でも代表的なものは以下の通り。

　追加操作
　　boolean add(〇) → リストの最後に要素を追加
　　void add(int, 〇) → リストのint番目に要素を挿入
　　set(int, 〇) → リストのint番目の要素を上書き

　取得操作
　　get(int) → int番目の要素を取り出す

　調査操作
　　int size() → 格納されている要素数を返す
　　boolean isEmpty() → 要素数がゼロであるかを判定
　　boolean contains(〇) → 指定要素が含まれているかを判定
　　int indexOf(〇) → 指定要素が何番目にあるかを検索

　削除操作
　　clear() → 要素をすべて削除する
　　remove(int) → int番目の要素を削除する

　イテレータ
　　iterator() → 要素を順に処理するイテレータを返す

　※〇はインスタンス型名を示す。

・要素を格納するには、add()またはset()を利用する。add()は渡す引数の数によって動作が変わる。
　追加する要素だけを引数に指定すると、ArrayListの末尾に追加される。0から始まるint値と要素の2つを
　引数として渡すと、int値の位置に要素が挿入される。set()も同様に2つの引数を受け取るが、
　指定位置の要素を上書きして置き換え、「古い要素を戻り値として返す。」

・要素を取り出すには、get()を使う。要素の位置(添え字)の指定が、やはり0から始まる点に注意する。

・配列では要素数を調べるために「.length」を用いたが、コレクションではその代わりにsize()を利用する。
　もし、要素数が0かどうかを判定したい場合には、size()ではなくisEmpty()を用いればコードが読みやすくなるだろう。
　なお、リスト内にある値が「含まれているか否か」だけを調べたい時にはcontains()を利用できるが、
　「何番目の位置に含まれているのか」まで調べたい時には、indexOf()を利用する。

・全ての要素を削除するにはclear()を、指定位置の要素を削除するにはremove()を用いる。
　remove()で要素を削除すると、削除された要素の後ろにあった全ての要素は1つずつ前に詰められる。
　この「削除したら前に詰めてくれる」というのも、配列にはない便利な特性である。

・なお、newの後ろに記述する<>記号の中身は省略可能。この場合、Javaは左辺の<>の記述に基づいて
　右辺の<>の中身を推測してくれる。中身が省略された<>の部分を「ダイヤモンド演算子」と呼ぶことがある。

・リストの中身を先頭から1つずつ取り出して何らかの処理を行うためには、3つの記述方法がある。
　その中でもforを用いる方法をいかに記述する。イテレータは用いた方法を後述。

　for文を用いたリスト要素の取り出し
　　for (int i = 0; i < リスト変数.size(); i++) {
    /* リスト変数.get(i) で要素を読み書き */
}

　拡張for文を用いたリスト要素の取り出し
　　for (リスト要素の型 e : リスト変数) {
    /* e で要素を読み書き */
}

・最後に紹介する方法は「イテレータ」と呼ばれるコレクションクラスの中身を順に
　取り出すための専用の道具を用いた方法である。イテレータとは、「リストに含まれる1つの箱を"ココ！"と指している
　矢印のようなもの」とイメージする。この矢印は「次へ！」と指示されればどんどん次の箱を指すよう移動していくことができる。
　そしてこの矢印に、「まず0番目の値を指せ」→「中身を取り出せ」→「次の箱を指せ」→　…　と言う指示を繰り返して、
　リストの中身を1つずつ取り出すのである。

・Javaでは、ある～型の箱を指すことができる矢印を、java.util.Iterator<～>型のインスタンスとして扱う。
　たとえば、文字列型の箱が並んだArrayList<String>型がある場合、そのリストの箱を指すイテレータとして
　Iterator<String>型を生み出して利用すればよい。ここで、インスタンスを生み出すというとnew演算子が思い浮かぶかもしれない。
　しかし、「イテレータのインスタンスを生み出す場合はnewを使わない。」その代わりにリスト変数自体のiteratorメソッドを
　呼び出すと、リストの先頭を指したイテレータのインスタンスを得ることができる。イテレータの取得は以下の通り。

　Iterator<リスト要素の型> it = リスト変数.iterator();

　イテレータを取得したとき、JVMの内部ではそのリストの「先頭(最初の箱)よりもっと前を指した状態のイテレータが取得」される。
　そして、取得できたイテレータのインスタンスに対して行える操作は、基本的にhasNext()、next()の2つしかない。
　これら2つのメソッドを次のように組み合わせると、ArrayListの要素を先頭から順番に1つずつ取り出すことができる。

　Iterator<リスト要素の型> it = リスト変数.iterator();
　　While (it.hasNext()) {
    リスト要素の型 e = it.next();
    /* 要素eを用いた処理 */
}

　拡張for文を用いた方法と比べると構文はやや複雑だが、イテレータの利用が必要な場面もある。
　リストから要素を順に取り出す3種類の方法は全て利用できるようにしておく。それぞれの長所と短所は以下の通り。

　for文 → 古いJavaでも利用可能。しかし、構文が分かりにくい。
　拡張for文 → 構文が分かりやすく、Setなどでも利用可能。しかし、周回数を取得できない。
　イテレータ → 古いJavaでも利用可能で、Setなどでも利用可能。しかし、構文が分かりにくく、周回数を取得できない。

・コレクションフレームワークには、ArrayListのほかにも「LinkedList」というクラスが準備されている。
　両社はどちらもリスト実現しているクラスであり、備えているメソッドや使い方もほとんど同じ。実際、LinkedListは
　ArrayListのメソッドで挙げたメソッドをすべて持っており、たとえば、過去のコードのArrayListをLinkedListに置き換えても
　同じように動作する。

・ArrayListとLinkedListには、クラス内部の作り(内部実装)に違いがある。ArrayListは配列を応用して作られたものだが、
　LinkedListは「連結リスト」と呼ばれる構造を応用して作られている。「同様の動作を実現するものだが、内部構造が違う」という意味では、
　ガソリン自動車と電気自動車のようなものかもしれない。この2つは「運転する人にとってはほぼ同じもの」である。
　しかし長距離の移動であればガソリン自動車が、エコロジー面では電気自動車が有利なように、
　ArrayListとLinkedListには「内部構造の違いに起因した動作の違い」がある。主な違いは以下の2つ。

　1．要素の挿入や削除に対する違い
　　　→ リストの途中に要素が挿入または削除される処理は、ArrayListがもっとも苦手とする処理である。
　　　　なぜなら途中の要素が削除されると、それより後ろにあった要素を「玉突き方式」で1つずつ前に移動させていく処理が必要になるから。
　　　　もし要素数が10000個であるリストの2番目の要素が削除されたら、9998回の玉突きコピーを行わなければならない。
　　　　一方のLinkedListにとって、要素の挿入や削除は得意な処理である。たとえば、remove()を行う場合、削除対象の1つ前の要素に対して、
　　　　次の箱を示す連結情報を書き換えるだけでよいから。

　2．添え字の指定に対する違い
　　　→ しかし、LinkedListにも弱点がある。連結リスト方式であるため、get()を使った要素の取り出しが苦手である。
　　　　連結リストは単なる「数珠繋ぎの箱」なので、それぞれの箱には「〇番目」という番号は振っていない。
　　　　よって、get()などで「〇番目を取得せよ」と指示された場合、先頭から〇番目まで数えながら辿っていく必要がある。
　　　　たとえば、10000個の箱が数珠つなぎになっているLinkedListの場合、9999番目の要素を取得すると指示されたら
　　　　先頭から順に9998回も辿っていかなければならない。これと同じように、要素数が多いLinkedListで末尾付近の要素を
　　　　add()やremove()するときにも注意が必要。get()同様、要素に辿り着くまで延々と要素を辿る必要があるため、
　　　　結果的にArrayListより遅くなることもある。

・ArrayListとLinkedListは内部構造に違いがあるものの、「ザックリ見れば同じList。」
　実際、両社はともにjava.util.Listインタフェースを実装しており、これまでに紹介したget()やremove()、size()やiterator()などは
　すべてListインタフェースに定義してあるメソッドである。「ArrayList is-a List」かつ「LinkedList is-a List」なので、
　以下のようなソースコードを記述できる。

　List<String> list1 = new ArrayList<String>();
　List<Hero> list2 = new LinkedList<Hero>();

　このコードでは、右辺でnewをするときに具体的なクラス名(ArrayListやLinkedList)を使い、
　左辺の変数の型としてはあいまいなインタフェース名(List)を利用している。
　このように、リストインスタンスを格納する変数や引数・戻り値の型は、極力あいまいな型を用いるのをお勧めする。
　newをする段階ではどの実装を利用するか意識する必要はあるが、その後の利用においては実装の違いを気にする機会は少なく、
　「ざっくりListとして扱う方がメリットが大きい」から。たとえば、あるリストを受け取って、その要素の全てを表示する
　メソッド(printListメソッド)を作る状況を考えてみる。この時、ArrayListだけを受け付けるメソッドとして作ってしまうと、利用する側にとっては
　LinkedListなどほかのリストを渡せなくなってしまう。しかし、このprintListメソッドの仕事は、リストの中身を取り出して1つずつ表示することであり、
　リストの内部構造が配列であるか連結リストであるかを気にする必要はない。このメソッドで引数をList<String>型にすると、ArrayList<String>や
　LinkedList<String>など、どんなリストでも受け取って中身を表示できるようになる。

　インタフェース型の活用
　「引数・戻り値・ローカル変数には、極力あいまいな型(インタフェース型)を利用できないか検討し、積極的に利用する。」

・java.util.Setインタフェースを実装するコレクションクラスの中でもっとも一般的なのが、java.util.HashSetクラスである。
　これらSet関連クラスは「集合(セット)」というデータ構造を実現する。集合は、重複が無く順序を持たない複数の情報を格納できる。
　たとえば、信号に色をひとまとめにして管理することを考える。要素には「赤・青・黄」の3つが含まれ、「赤・赤・黄・黄」などと重複はしない。
　また、3つの色に順番は無く、とにかく「赤」と「青」と「黄」が含まれていればよいはず。
　このように、重複は許さないけれど、その順番は問わないデータの集まりを利用したい場合にSet関連クラスを用いる。

・Set関連クラスには以下のようなメソッドが備わっている。

　追加操作
　　boolean add(〇) → セットに要素を追加

　取得操作
　　なし

　調査操作
　　int size() → 格納されている要素数を返す
　　boolean isEmpty() → 要素数がゼロであるかを判定
　　boolean contains(〇) → 指定要素が含まれているかを判定

　削除操作
　　void clear() → 要素をすべて削除する
　　boolean remove(〇) → 指定した内容の要素を削除する

　イテレータ
　　Iterator<〇> iterator() → 要素を順に処理するイテレータを返す

　※〇は要素を示す。

・SetはListと似た部分もあるが、Listと比較して注意しなければならないのは以下の3点。

　1．重複した値を格納しようとすると無視される
　　　→ add()を呼び出して要素を格納できるが、既に同じもの(equals()で等価と判断されるもの)が
　　　　格納されている場合は無視される。

　2．set()やget()がない
　　　→ リストには「〇番目の要素を取得する」「〇番目に要素を追加する」ためにget()やset()が存在した。
　　　　しかし、要素に順序関係が無いSetには、そもそも「〇番目」と言う概念が無く、添え字を使った操作は行えない。

　3．要素は順不同で取り出される
　　　→ セットの要素には順序が無い。よって拡張for文やイテレータを使ってセットの中身を1つずつ取り出す場合、
　　　　「どのような順序で要素が取り出されるかは一切保証されていない」ことに注意が必要。
　　　　格納した順序とは全く異なる順序で取り出されることもある。また、実行するたびに異なる順序で取り出されるかもしれない。

・上記で解説した通り、基本的にセットというデータ構造では要素同士の順序は管理できず、その順序は保証されない。
　しかし、それでは困るという場合は、次のようなルールに従って順序を保障するTreeSetやLinkedHashSetといった実装を利用できる。

　LinkedHashSet → 値を格納した順序に整列する
　TreeSet → 自然順序付けで整列する

　自然順序付けとは、それぞれのクラス固有の順序のこと。たとえばStringクラスでは辞書順になるよう定義されている。
　Heroなど自分で作成したクラスでは、開発者が自然順序を定める必要がある。

・「マップ」とは、2つの情報を「キー」と「値」の「ペアとして格納するデータ構造」である。
　格納した値は、キーを指定して読み書きできる。とても便利なデータ構造なので、様々なプログラム開発において多用される。
　Javaでは、java.util.Mapインタフェースおよびjava.util.HashMapクラスに代表される各種実装クラスを用いて、
　手軽にマップを活用できる。このとき、「String型のデータを格納するList」をList<String>型と表現したように、
　「String型のキーとInteger型の値のペアを格納するMap」は、Map<String,Integer>型と表現する。

・Mapインタフェースの実装で特に多く利用されるのは、java.util.HashMapクラス。
　HashMapのインスタンス化は次の構文で行う。

　Map<キーの型, 値の型> マップ変数 = new HashMap<キーの型, 値の型>();

　※右辺のインスタンス型名は省略可能。

・HashMapは以下のようなメソッドを持っている。

　追加操作
　　■ put(●,■) → マップに●と■のペアを格納する

　取得操作
　　■ get(●) → キー値●に対応する値を取得(なければnull)

　調査操作
　　int size() → 格納されているペア数を数える
　　boolean isEmpty() → 要素数がゼロであるかを判定
　　boolean containsKey(●) → 指定データがキーに含まれているかを判定
　　boolean containsValue(■) → 指定データが値に含まれているかを判定

　削除操作
　　void clear() → 要素をすべて削除する
　　■ remove(●) → 指定した内容の要素を削除する

　その他
　　Set<●> keySet() → 格納されているキーの一覧を返す

　※●はキーを、■は値を示す

・上記のメソッドの中でも特に、get()とput()による読み書き、remove()による削除、size()によるペア数の取得などがよく利用される。
　なお、Mapでは値の重複は許されるが、「キーの重複は許されない。」よって、同じキーで異なる値をput()すると、
　後から格納した値で上書きされてしまうので注意が必要。

・HashMapに格納されたペアを順に取り出す場合、ListやSetと同様の方法で取り出そうとするとエラーが出てしまう。
　マップに格納されたデータを順に取り出す方法はいくつかあるが、「キーの一覧を取得」→「各キーについて対応する値を取得」の
　2段階の手続きを踏む方法が比較的理解しやすいだろう。マップに格納された情報を1つずつ取り出すコードは以下の通り。

　for (キーの型 key : マップ変数.keySet()) {
    値の型 value = マップ変数.get(key);
    /* keyとvalueを用いて何らかの処理を行う */
}

　なお、HashMapは格納したペア同士の順序を保障しないコレクションなので、毎回同じ順序で取り出せるとは限らない。
　よって、格納順に取り出したい場合はLinkedHashMapを、自然順序で取り出したい場合はTreeMapを利用する。

・List関連とSet関連のクラスは、共通の親インタフェースとしてjava.util.Collectionを持っている。
　このインタフェースは「(重複しているか否かを問わず)何らかの単独データの集まり」を表す、とても抽象度が高いインタフェース。
　Mapは、「ペアデータの集まり」であるため、Collectionインタフェースとは継承関係にない。

・JavaAPIには、コレクションや配列を便利に利用するための命令を集めたクラスが用意されている。
　以下の両クラスに備わる全てのメソッドはstaticなので、インスタンス化することなく利用できる。

　java.util.Collections → コレクション操作関連の便利なメソッド集
　java.util.Arrays → 配列操作関連の便利なメソッド集

・これまでList,Set,Mapに関する様々なコレクションクラスを学んだ。これらのコレクションクラスは、要素として別のコレクションを
　格納することも可能。たとえば、「都道府県別特産物ランキング」を考えてみる。各都道府県に対して、
　順位付けされた複数の特産物データを保持する必要がある。結果としてMapの中にListがネストした構造になるだろう。
　キーは「東京都」でその値が「東京の特産物リスト」といった形である。
　このMapは「文字列」と「文字列リスト」のペアを格納するので、Map<String,List<String>>という型を使う。
　ほかにも、Mapの中にMapを入れたり、Listの中にMapといった構造や、3重以上のネストも可能。

・コレクションクラスは、様々なインスタンスを格納できるとても便利なクラスだが、いくつか注意すべき点がある。
　たとえば、Hero h = new Hero(); としてh.name = "ミナト"; とする。
　その後に、List<Hero> list = new ArrayList<Hero>(); とし、list.add(h) とすればHeroのインスタンスであるhがListに格納される。
　では、この後に h.name = "スガワラ"; としてlist.get(0).name を表示するとどうなるか？それは、「スガワラ」の方が表示されてしまう。

　この現象を理解するためには、「変数hやリストに格納された値が実際には参照である」ということを思い出す必要がある。
　Heroインスタンスが生まれた時点で、そのメモリ上の番地(仮に1234番地)が変数hに代入されている。
　変数hをリストに格納しているが、リストに格納されるのは、この変数hの1234というアドレス情報だから、
　list.get(0)と変数hは全く同一のインスタンスを指す状態になる。したがって、変数hのnameを書き換えれば、
　当然リスト内の要素も書き換わってしまうのである。このように、「コレクションへの格納が終わった変数のインスタンスの中身を書き換えると、
　格納した要素の中身も書き換わる」現象が起きる。同様に、get()で別の変数に取り出したインスタンスに対する内容の変更も、
　格納中のインスタンスに影響を与えてしまう。思わぬ不具合の原因となる場合があるため、格納した要素の参照には注意する。

・IntegerやStringのようなAPIが提供するクラスではなく、自分が開発したクラスのインスタンスをコレクションに格納する場合には
　特別な注意が必要。それは、「HashSetやHashMapに格納するクラスは、equals()およびhashCode()を正しくオーバーライドしていないと
　意図しない動作をする可能性がある」ということ。equals()は、正しい等価判定のためにオーバーライドが必要なメソッド。
　同様にhashCode()もObjectクラスに備わるメソッドで、より効率的な等価判定のために使われる。Hash系コレクションは、要素の検索や削除に
　これらのメソッドを呼び出して効率的な処理を実現しているため、これらを「正しくオーバーライドしていないと意図通りには動作しない」のである。

・Javaでは、ローカル変数の型の指定をある程度簡略化することができる。具体的には、これまでintなどの型名を記述していた部分に
　「var」を記述すると、その変数は代入された値の型として使われる。たとえば、var age = 22; とすればageはint型となり、
　var h = new Hero();とすればhはHero型となり、var list = new ArrayList<String>();とすればlistはArrayList<String>型となる。
　この仕組みを利用するには、varを記述した時点で、その変数の型が明確である必要がある。
　たとえば、var x; var y = null; var scores = {10, 20, 30} などのコードは全てエラーになる。
　また、引数や戻り値、フィールド変数にvarを用いることはできない。あくまでもJVMの型を推測させているだけで、オールマイティに利用できる
　varという型が存在しているわけではないから。
　varは主に、以下のようにコレクションの宣言に用いると、シンプルなコードを記述する手助けをしてくれる。

　HashMap<String,Integer> map = new HashMap<String,Integer>();
　↓
　var map = new HashMap<String,Integer>();

・ある程度の経験を積めば、とりあえず動作するプログラムを作るのは難しくない。本当に難しいのは、
　想定外の事態やユーザーの誤操作などがあっても、エラーを起こさずに正常に動作するプログラムを作ることである。

・プログラムが想定通りに動かない事態を総じて不具合というが、Javaの場合は大きく3つに分類できる。

　1．文法エラー(syntax error)
　　　→ 文法の誤りによりコンパイルに失敗する。代表的なのはセミコロン忘れ、変数名の間違い、外部からのprivateメソッド呼び出しなど。

　2．実行時エラー(runtime error)
　　　→ 実行している最中に何らかの異常事態が発生し、動作が継続できなくなるエラー。
　　　　Javaの文法としては問題が無いためコンパイルは成功し、実行もできるが、
　　　　実行中にエラーメッセージが表示されて強制終了する。配列の範囲外要素へのアクセス、0での割り算、
　　　　存在しないファイルのオープンなどが代表的。

　3．論理エラー(logic error)
　　　→ Javaの文法に問題は無く、強制終了もしない。しかし、プログラムの実行結果が想定していた内容とは異なる。
　　　　たとえば、電卓プログラムを作ったものの計算結果がおかしいなどが考えられる。

　開発者は、これら3種類の不具合に対して、それぞれ異なる対策を行う必要がある。不具合の検出と解決についてまとめたものがp617の図。

・文法エラーと論理エラーは「開発者の過失」であって、「開発者がテストをしっかり行ってコードを修正しておけば、
　本番での発生を予防できるもの」である。しかし、実行時エラーはそうはいかない。そもそも実行時エラーは、プログラム実行中に発生する
　想定外の自体によっておこる。この「想定外の事態」を「例外的状況」また単に「例外」という。
　例外的状況には以下のようなものがある。

　パソコンのメモリが無くなった
　　→ 開発用のコンピュータには十分な容量のメモリがあったが、本番用コンピュータのメモリが少なく、動作中にメモリが足りなくなってしまった。

　存在すべきファイルが見つからない
　　→ 動作中にdata.txtというファイルを読み込んで動くプログラムを開発したが、利用者が誤ってファイルを削除してしまった。

　nullが入っている変数を利用しようとした
　　→ ユーザーの想定外の操作により、本来は変数に代入されない値(nullなど)が入り、その変数を使用するメソッドを呼び出してしまった。

　これらすべての状況に共通するのは、「ソースコードを作成する時点では例外的状況の発生を予防できないこと」である。
　開発者が例外的状況の発生を防ぐのは困難。しかし、私たちは無力ではない。例外が発生したときの対策を用意しておくことは可能。
　たとえば、「もし目的のファイルが見つからなければ、ユーザーに変わりのファイル名を入力してもらう」など、異常事態に備えた代替策を
　準備しておけばよい。このように、例外的状況に備えて対策を準備し、その状況に陥った時に対策を実施することを「例外処理」と呼ぶ。

・C言語のような古いプログラミング言語の例外処理には以下のような問題点がある。

　本来の処理がどの部分なのかわかりづらい。
　命令を呼び出すたびに1つひとつ例外的状況をチェックしなければならない。
　面倒なので例外処理をさぼって書かない恐れがある。

　このような問題が発生するのは、従来画のプログラミング言語が「例外的状況発生の検知と対応に関する全責任を開発者に求めている」から。
　まじめな開発者は責任を果たすために1つひとつの命令からの戻り値をチェックする面倒を引き受けて苦しみ、
　不真面目な開発者は責任を放棄して例外処理をさぼってしまう。

・上記のような従来型例外処理の問題点を解決するために、Javaをはじめとする新しいプログラミング言語では、
　例外処理専用の文法と仕組みが備わっている。Javaでは例外処理にtryとcatchという2つのブロックを使用する。
　(合わせて「try-catch文」と呼ぶ。)tryとcatch、2つのブロックのうち、本来の処理で実行されるのはtryブロックだけで、
　catchブロックの処理は動かない。ただし、「tryブロックを実行中に例外的状況の発生をJVMが検知すると、
　処理は直ちにcatchブロックに移行」する。つまり、catchブロックの中には、
　「例外的な状況が発生したときに実行される処理」を記述しておくのである。
　Javaにおける例外処理の基本パターンは以下の通り。

　try {
    通常実行される文
} catch(…) {
    例外発生時に実行される文
}

・見方を変えれば、tryブロックとは、この部分では例外的状況が発生する可能性があるから、
　その検出を試みながら実行しなさい、という開発者からJVMへの指示ともいえる。命令を実行するたびに例外的な状況が
　発生しているかどうかをチェックする面倒な作業はJVMに任せられるため、開発者が負う責任は軽減される。

・一口に例外的状況と言っても、「ファイルが無い」「メモリが足りない」「変数がnull」など、様々な状況がある。
　それらを同じものとして扱うと、発生した例外的状況に応じた処理を行うことができない。
　そこでJavaでは、発生した例外を区別できるように、「それぞれの例外的状況を表すクラス」が複数準備されている。

・第Ⅱ部で学んだように、オブジェクト指向とは、「現実世界の何か」をオブジェクトとしてJava仮想世界で再現するものだった。
　多くのオブジェクトは、ヒトやモノなど「現実世界で形があるもの」から作り出されるのが一般的。
　しかし「現実世界で形が無いもの」からオブジェクトを作る状況もある。たとえば、イベント運営会社の「イベント情報管理プログラム」
　を開発する場合、本来は形があるものとみなさない「イベント」をEventクラス(フィールドとして開催日や主催者を持つ)
　として作るだろう。同様に、「ファイルが無くて困っている状況」や、「nullが入っていて困っている状況」など
　現実世界の例外的状況(想定外の事態)をクラスにしたものが例外クラス。
　ちなみに、java.io.IOExceptionは「ファイルの読み書きなどの入出力ができなくて困っている状況」のためのクラスであり、
　他にも多くのクラスがAPIとして定義されている。

・APIで提供されている例外クラスは、p625のような継承階層を構成している。
　最下層のクラスについて以下に紹介していく。

　1．Error系例外
　　　→ java.lang.Errorの子孫で、「回復の見込みがない致命的な状況」を表すクラス。代表的なものにOutOfMemoryError(メモリ不足)や
　　　　ClassFormatError(クラスファイルが壊れている)がある。通常、このような状況をキャッチしても打つ手は無いため、
　　　　キャッチする必要はない。

　2．Exception系例外
　　　→ java.lang.Exceptionの子孫(RuntimeExceptionの子孫を除く)で、「その発生を十分に想定して対処を考える必要がある例外的状況」
　　　　を表すクラス。たとえば、IOException(ファイルなどが読み書きできない)やConnectException(インターネットに接続できない)
　　　　といった状況は、ファイルやネットワークを利用する際には当然想定しておくべき事態。

　3．RuntimeException系例外
　　　→ java.lang.RuntimeExceptionクラスの子孫で、「必ずしも常に発生を想定すべきとまではいえない例外的状況」を表すクラス。
　　　　たとえば、NullPointerException(変数がnullである)やArrayIndexOutOfBoundsException(配列の添え字が不正)のように
　　　　いちいち想定していると「きりがない」ものが多く含まれる。

・上記の3種類ある例外クラスの中で、特に注目したいのが2のException系例外。これは「その発生を十分に想定して対処を
　考えておく必要がある状況」を表しているのだから、いざ例外が発生したときに何も対処されない事態はあってはならないはず。
　そのためJavaでは、「Exception系の例外が発生しそうな命令を呼び出す場合、try-catch文を用いて、"例外が発生したときの代替処理"を
　用意しておかないとコンパイルエラー」になる。

・Exception系例外は、コンパイルの時点で例外発生時の対策が用意されているかをチェックされるため、「チェック例外」とも呼ばれる。

・APIに含まれるクラスには、呼び出すと何らかの例外を発生させる可能性があるメソッドを持つものが数多くある。
　特にチェック例外が起きる可能性のあるメソッドを呼び出す場合はtry-catch文で囲まなければならないので、
　「どのメソッドを呼び出したら、どのような例外が発生する可能性があるかをあらかじめ知っておく必要がある。」
　実は、どのクラスのどのメソッドがどのような例外を発生させる可能性があるかは、APIリファレンスに掲載されている。
　メソッドやコンストラクタを呼び出すとException系の例外が発生する可能性がある場合、「引数リストの後に"throws 例外クラス名"が
　表記されている。」たとえば、APIリファレンスに掲載されているFileWriterクラスのコンストラクタでは「throws IOException」と
　書かれているので、「FileWriterのコンストラクタを呼び出す(インスタンスを生成する)ときには、
　IOExceptionをキャッチするtry-catch文が必要になる」と理解できる。

・tryブロック実行中はJVMが例外的状況の発生を監視しながらプログラムを実行する。
　そして、いざ例外が発生すると、JVMは処理をcatchブロックに移行する。このときJVMは、「プログラム中のどこで、
　どのような例外が起きたのか」という「例外的状況の詳細情報が詰め込まれたIOExceptionインスタンスを
　catch文で指定された変数eに代入」する。catchブロックの中では、この変数eに格納された詳細情報を取り出して、
　適切なエラー処理(画面にエラーメッセージとして表示するなど)を行う。

・例外インスタンスに格納されている詳細情報は、その例外の種類によって異なる。
　しかし、全ての例外は「例外的情報の解説文」と「スタックトレース」の情報を必ず持っており、
　それぞれ以下のようにメソッドで取得と表示ができる。

　String getMessage() → 例外的状況の解説文(いわゆるエラーメッセージ)を取得する。
　void printStackTrace() → スタックトレースの内容を画面に出力する。

　e.printStackTrace();のようにして、printStackTraceメソッドをcatchブロックで呼び出すと、
　スタックトレースを画面に表示できる。「スタックトレース」とは、「JVMがプログラムのメソッドを、どのような順序で呼び出し、
　どこで例外が発生したか」という経緯が記録された情報。これは、実行時エラーが発生したときにコマンドプロンプトに
　何行も出てきた内容となる。これが出てきたのは、例外が発生してもtry-catch文でキャッチされなかった場合、
　JVMがプログラムを強制停止してスタックトレースの内容を画面に表示していたから。

・try-catchの基本構文でキャッチできるのは1種類の例外だけ。
　しかし、1つのtry文に対して複数のcatchブロックを記述することもできる。このときJVMは発生した例外の型に対応する
　catchブロックを上から順に検索し、最初にキャッチできたcatchブロックに処理を移す。
　なお、どちらのcatchブロックも同じ処理をする場合、catch (IOException | NullPointerException e) { … } のように
　catchブロックを1つにまとめて記述できる。

・catchブロックの例外クラスは、多態性で学んだ「ザックリ捉えた型」でも指定できる。
　例外クラスの継承階層によれば、IOExceptionもNullPointerExceptionも、ザックリ捉えれどちらもExceptionである。
　したがって、catch (Exception e) { … } のように記述すれば、どちらの例外が発生しても1つのcatchブロックでキャッチできる。
　しかし、この場合はどんな種類の例外が発生しても同じように処理するため、おおざっぱな例外処理になってしまうことに注意。

・ファイルは「開いたら閉じる」のが決まり。あるプログラムがファイルを開いている間は、
　他のプログラムからそのファイルを使えないなどのリソースリークが発生してしまう可能性があるため。
　そこで、たとえば、fw.write("hello");を実行した瞬間、偶然ディスク容量が不足してIOExceptionが発生したとしたら、
　処理はcatchブロックに移動してしまうためその下の行のfw.close()は実行されず、ファイルが開いたままになってしまう。
　catch文の後にfw.close()を記述すればよいと思うかもしれないが、もしtryブロックの中で
　キャッチしようとしている型以外の例外をキャッチすると、例外はキャッチされないためファイルを閉じないまま
　プログラムは強制終了してしまう。fw.close()はIOExceptionを送出する可能性があるため、これもtry-catchで囲まなければならない。
　fw.close()のような「後片付け処理は、例外が発生してもしなくても、たとえ強制終了になったとしても、
　必ず実行されなければならない処理」である。そして、そのような処理をJVMに確実に実行させるために、finallyブロックが準備されている。
　記述方法は以下の通り。

　try {
    本来の処理
} catch (例外クラス 変数名) {
    例外が発生した場合の処理
}　finally {
    例外があってもなくても必ず実行する処理
}

　try-catch-finally構文は、一度JVMが「tryブロックの実行を開始したら、必ず最後にfinallyブロックの内容も実行されることが保証」されている。
　tryブロックにreturn文があってメソッド自体が途中で終了されても、finallyブロックはきちんと実行される。
　開いたファイルを閉じる、開いたデータベースやネットワークとの接続を閉じるなどの「後片付け処理には必ずfinally」を使う。

・finally文でfw.close()をする際には、変数fwのスコープ、fwをnullで初期化、finallyの中でもtry-catchを記述する、
　if (fw != null)としてfwがnullということはファイルのオープンに失敗しているためそもそもcloseする必要はないなど忘れないようにする。

・近年のJavaでは、tryの直後に丸カッコで囲んで複数の文を記述できるようになった。(try-with-resource文)
　ここで開かれたファイルやデータベース接続などは、finallyブロックを記述しなくてもJVMによって自動的にcloseメソッドが呼び出される。
　なお、JVMによって自動的にクローズされるのは、java.lang.AutoCloseableインタフェースを実装しているクラスに限られる。
　ファイル操作者データベース接続、ネットワーク接続に用いるAPIクラスの多くは、AutoCloseableを実装しているため、
　try-with-resource文での簡潔な記述が可能。

・ここまではmainメソッドに注目して例外処理を学んできたが、mainメソッドから呼び出した先のメソッドで例外が発生したらどうなるか？
　以下のプログラムを例に考えてみる。

　mainメソッドの中ではsubメソッドを呼んでいる。
　subメソッドの中ではsubsubメソッドを呼んでいる。
　subsubメソッドでは、処理中に何らかの例外が発生することがある。

　subsubメソッド実行時に例外が発生すると、JVMの内部では以下のように処理される。

　1．まずsubsubメソッドで例外をキャッチしていなければ(try-catch文が無ければ)「subsubメソッドとしては、
　　 この例外的状況に対してお手上げ」となり、呼び出し元のsubメソッドに対応が委ねられる。

　2．subメソッドでもキャッチしないと、その対応はmainメソッドに委ねられる。

　3．mainメソッドで例外をキャッチしなければ強制終了する。

　このように例外はキャッチされない限り、メソッドの呼び出し元まで処理を「たらい回し」にされてしまう。
　この現象を「例外の伝播」と呼ぶ。もちろん呼び出し元のmainメソッドやsubメソッドにcatchブロックが準備されていれば、
　例外の伝播はそこで止まる。

・例外の伝播は、発生した例外が各メソッドでキャッチされず「お手上げ」になるために起こる。
　Exception系例外(チェック例外)の場合は、try-catch文によるキャッチが必須であるため、基本的に例外の伝播は発生しない。
　しかし、メソッドの宣言時に「スロー宣言」を行うと、発生するチェック例外をキャッチせずに呼び出し元へと伝播できる。
　スロー宣言による例外伝播の許可は以下の通り。

　アクセス修飾 戻り値 メソッド名(引数リスト) throws 例外クラス1, 例外クラス2, … {
    メソッドの処理内容
}

　たとえば、以下のように記述する。

　public static void subsub() throws IOException {
    FileWriter fw = new FileWriter("data.txt");
}

　このメソッドの中ではFileWriterをインスタンス化しており、チェック例外であるIOExceptionが発生する可能性がある。
　しかし、この例のように、「スロー宣言を行っていればtry-catch文が無くてもコンパイルエラーにならない。」
　なぜスロー宣言をするとコンパイルエラーにならないのだろうか。スロー宣言とは、そのメソッドが
　「私はメソッド内でチェック例外が発生しても処理しませんが、"私の呼び出し元が処理します"」と表明する宣言だから。
　その一方、スロー宣言が含まれるメソッドを呼び出す側は、このメソッドを呼び出すと、呼び出し先で発生した例外が処理されずに
　「自分に伝播してくる可能性がある」と覚悟しなければならない。

・チェック例外に対する処理方法についてまとめると、全てのメソッドは「チェック例外をどう処理するか」について、
　以下の2つの方針のどちらかを採用し、その方針毎に課せられる義務を果たさなければならない。

　1．チェック例外を自分で処理
　　　→ 自分で例外的状況を解決する。例外が発生してもお手上げはせず、呼び出し元に迷惑をかけない。
　　　　この場合、発生する可能性がある、全てのチェック例外をtry-catch文で処理する義務がある。

　2．チェック例外を処理せず、呼び出し元に委ねる
　　　→ 自分で例外的状況を解決しない。例外が発生したら、呼び出し元に処理をまかせる。
　　　　この場合、メソッド定義にスロー宣言を加え、委ねる例外の種類を表明する義務がある。

・fw.close()のcatch文のように、「ファイルが閉じられないこと」に対してできることはなにもないためcatch文を空文にする、
　などの特殊なケースを除いて空のcatchブロックは極力避けるべき。これはいわば発生した例外をキャッチしながら
　自分では何の処理もせず、上にも報告しない「不祥事のもみ消し」のようなことをやっているため。

・例外的状況が発生したかどうかはJVMが監視する。そして、JVMは例外的状況を検知すると処理をcatchブロックに移すのだった。
　実は、監視をしているJVMに対して、私たち自身が「例外的状況になりました」と知らせることができる。
　例外的状況の発生を報告するには、以下の構文を使う。

　throw 例外インスタンス;

　※一般的にはthrow new 例外クラス名("エラーメッセージ"); と書く。

　監視中のJVMに例外的状況を報告することを、「例外を投げる」または「例外を送出する」と表現する。
　例外が投げられるとJVMはそれを検知し、即座にcatchブロックの実行や例外の伝播に処理を移す。
　つまり、例外の詳細情報が詰め込まれている例外インスタンスを生み出し、それを使って報告するということ。

・スロー宣言で使うthrowsと例外的状況の報告に使うthrowは似ているが、全く違うものなので気を付ける。

・これまで見てきたように、APIにはIOExceptionやIllegalArgumentExceptionなどの多くの例外クラスが備わっている。
　それら既存の例外クラスを使えば、多くのプログラムは問題なく作成できるだろう。
　しかし、独自の例外的状況を表すオリジナルの例外クラスを使いたい場面もある。
　たとえば、音楽プレーヤーソフトを開発していて、「対応していない形式のファイルを再生しようとした」などの例外的状況を表す
　クラス(仮にUnsupprtedMusicFileException)が必要になるかもしれない。そのような場合は、「既存の例外クラスを継承して
　オリジナルの例外クラスを作る」ことができる。継承元になる例外クラスには、チェック例外を表すExceptionや、
　非チェック例外を表すRuntimeExceptionのほか、IOExceptionなど実際に何かの状況を表している例外クラスを用いることができる。
　しかし、ThrowableやErrorの子クラスとしてオリジナル例外を定義することはほとんどないだろう。
　本格的で大規模なプログラムを開発する時には、想定される様々な例外的状況を思い浮かべ、オリジナルの例外クラスとして作成しておけば
　きめ細かい実行時エラーへの対処が可能になる。

・プログラムからコンピュータ内のファイルを読み書きする場合、ファイルの内容を全て一度には読み込まない。
　なぜなら、ファイルがとても大きい場合、一度に読み込むとメモリが足りなくなってしまうから。そこで、Javaをはじめとする
　多くのプログラミング言語では、ファイルを少しずつ読んだり書いたりするための機能を備えている。
　この時用いるのが「ストリーム」という考え方。ストリームとは、情報が流れてくる小川のようなものだと想像する。Javaプログラムは、
　この小川を通してファイルを読み書きする。たとえば、ファイルを読み込む場合は、小川の上流にあるファイルから1文字ずつ流れてくると
　考えて文字を読み込む。

・従来のプログラミング言語では、インターネット上のWebページを取得するためには、ネットワークプログラミングに関する多くの知識と
　プログラミング作業が必要だった。しかし、Javaでは、java.netパッケージのクラスを使って、同じ機能のプログラムをほんの数行で作成できる。

・URLクラスのURLコンストラクタはバージョン20から廃止となった。代わりにURL u = URI("サイトのURL").toURL;といった形式で記述する。

・インナークラスとは、「クラス宣言の中に、更にクラス宣言を書くこと」で、その書かれた内側のクラスのこと。
　書かれるクラス内容によって、以下の3種類に分かれる。

　　メンバクラス
　　ローカルクラス
　　匿名クラス

・メンバクラスはクラスブロックの直下に置く。通常のクラスであればstaticをつけることはできないが、
　「メンバクラスであれば、staticをつけることが許されている。」

・文字ストリームの入出力はReader/Writerクラスが担い、バイトストリームの入出力は
　InputStream/OutputStreamクラスが担う。これら4つのクラスがスーパークラスとなり、
　ファイルに特化した入出力クラスや、バッファ付きの読み書きをサポートするクラスなど
　多くのサブクラスが提供されている。

・byte型に指定できるのは-128～127の値。つまり1バイト内の範囲(256個)である。

・文字コードからそのコードに対応している文字に変換するには
　char ch = (char) 文字コード;　のようにする。

・

=========================================================================================================

ミスやつまずいたこと、わからないこと　※練習問題の解答は719ページ

・javaコマンドは動作するのにjavacコマンドが認識されなかった、パスは通していた
　　→　コマンドプロンプトを新しくしていなかったのが原因？https://www.javadrive.jp/start/install/index4.html
　　　 の通りにその都度コマンドプロンプトを起動し直すと順調にいけた。

・コマンドプロンプトで入力値を変数に入れ、その後表示させるプログラムにて
　どうすればプログラムとコマンドプロンプト間で文字コードを合わせることができるか？
　　→　Scanner(System.in,"Shift-JIS")のように、標準入力の文字コードを指定したら解決。
　　　 コマンドプロンプト(Windows)はShift-JISを使用しているのでこのように指定。

・パッケージでエラーが出る
　　→　パッケージはそのままWindowsのフォルダと考え、その上に.で区切られているのは
　　　 ディレクトリ階層だと考える。つまり、package calcapp.main なら
　　　 calcapp\mainフォルダに配置する必要がある。

・javacコマンドで「パッケージcalcapp.logicsは存在しません」とエラーが出る
　　→　正しいパスに移動してjavacコマンドを使用する。
　　　 javacコマンドは実行したディレクトリ「直下」にあるパスを検索して
　　　 パッケージ名と同じディレクトリがあればそれを辿って目的のファイルを見つける。
　　　 つまり、calcappフォルダ自体でjavacコマンドを使用すると、package calcapp.logics
　　　 となっている文の先頭であるcalcappが直下にないのでパッケージが見つからないエラーとなる。

・importを使用しているのに省略記法ができない
　　→　クラス名は省略できない？commentパッケージのZenhanクラスを使いたいなら
　　　 commentは省略できるが、クラス名であるZenhanはパッケージの前につけなきゃダメそう。

・抽象メソッドをオーバーライドしてるはずなのにできない
　　→　元の抽象メソッドで指定してる引数をしていしていなかった。そりゃできん

・親の親クラスのフィールドにアクセスする方法が無いのなら11章の練習問題において、
　BookクラスやComputerクラスがsuper.nameとしてもAssetクラスのnameフィールドにアクセスできないのでは？
　　→　super.メンバ名は1つ上の親クラスがそのメンバを持っていなければもう1つ親のクラスへ探しに行く。
　　　 superは「見つかるまで探しに行く」という作りになっているため、上記のような心配事は無用。

・配列宣言にfinalを宣言しても、変更できなくなるのは配列のインスタンスであり、
　配列の要素は変更することができてしまう。もし内容を変えられたくない読み取り専用のデータ集合を
　作りたい場合は、ListやMapなどの動的配列を用いなければならない。

・Main.javaと同じディレクトリ内にあるtest.txtが開けない
　　→　throws Exception　を記述するとエラーが無くなったため、これを書いていなかったのが原因か

・if文やswitch文の中でreturnを使いたいが、returnが条件分岐内だけだとエラーが出る
　　→　「コンパイラはすべての条件分岐がもれなく書かれているか否か判断することはできないため、
　　　　実際には到達することがあり得ない条件分岐であっても、形式的に書いておく必要がある」とのこと。
　　　　というか、メソッドの最後にreturn null;として面倒だがそのメソッドを使用する場合は
　　　　nullが返ってきたときの例外処理を行えばよいはず

・

=========================================================================================================

作ってみたいプログラム

・そのクラスのフィールドと親クラスのフィールドを読み込んでアクセサのひな形を自動で作成してくれるプログラム

・TAB譜を打ち込めるプログラム(とりあえず五線譜と数字が書き込めればいい)

・ランダムにひらがな全てを重複なしで表示するタイピングプログラム
　(余裕があればScannerでも使って表示されている順番と
　入力があっているかの確認までできたらなお良い)

・