javaゲーム メモ

・文章が表示される間隔を2秒ぐらいにしたい
　(欲を言えばクリックするごとに表示させたい)

・フィールドで勇者のaction()メソッドを呼び出す感じにする。
　action()メソッドは、どのアクションを行いますか？と表示し
　討伐、探索、休む、マップ移動などを選択肢で表示する。

・while (イベントカウント) {
    action();
    
}

・各フィールドのクリア条件は、討伐と探索を決められた回数クリアしたらにする
　決められた回数クリアしたら強制的にイベントに進ませるのではなく、
　mapActionに「ボス戦」の選択肢を追加する
　「(マップの奥地が解放された！十分な準備をしてからここに進もう」などのテキスト)

・3つあるフィールドはそれぞれ微妙に難易度が違うようにするのか、
　それとも同じようにするのか。

・探索はお宝を得られるチャンスのため、リスクがあった方がおもしろいのでは？
　中ボスを配置するなど

・どうのつるぎ、はがねのつるぎなどはmainプログラムの方で生み出す感じとなる。

・ターン制バトルをどうやって実現する？

・while(勇者のHPが0になるか、敵のHPが0になるか、どちらかが逃げるか) {
    battle();
}

・勇者の最大HPはどのように定義すればよいのか？ → 勇者クラスに専用の変数を定義
　レベルアップの時だけこの変数を呼び出すようにする。

・じゅもんを選択したがやはり違うことをしたいなどといったときに、
　もどれるプログラムもほしい

・レベル上限は20とする

・[進捗]battle()メソッドに渡す敵の引数について、マップごとに敵情報を変えて渡すにはどうすればよいか？
　　　　

・敵を倒した時に1体の敵を倒したときと複数の敵を倒した時の挙動を変えるには？？
　そもそもbattle()メソッドに複数の敵インスタンスを渡したい時にはどうすればよいのか？
　敵の数という情報は配列の形にした方が良い？
　それならbattle(Enemy[] e) とすればその配列の中身が単体でも複数でも想定しているプログラムになるはず
　「e[0].name + "と" e[1].nameをたおした！」のような記述になる
　ただ問題点が1つ、同じモンスターを複数倒した場合に「スライムとスライムをたおした！」ではおかしいので
　equals()のようなメソッドを用いて渡された配列内のモンスター名を等価か判断する必要が出てくる。

    if (配列内のモンスター名が重複していない場合){
        System.out.println(e[0].name + "と" + e[1].name + "をたおした！");
    } else {
        System.out.println(e[0].name + "をたおした！");
    }

　なお、上記のプログラムは2体を想定しているので数が増えればもっと複雑になる
　まあ簡単なゲームなので敵の最大数は3体でもいいし、このゲームはドラクエ1ライクのつもりなので
　なんなら敵は全て単体でもよい

　ちなみにもしこのプログラムを利用するならば、敵が生成される時に配列に入れる順番は
　名前を辞書順で入れると同じモンスターは必ずインデックスが連番で入るので
　それを利用して重複を確かめることにすると楽になるかも

・levelList.addももうちょい見やすく短い方法で記述できたら良い
　for文で決まった数だけ上乗せしていって周回数が一定の回数になったら
　さらに必要経験値を上乗せしていくなど
　この形のようにレベルが上がれば上がるほど必要経験値も上がっていく
　"比例"のようなプログラムを作るにはどうしたらよいのか？
　y(必要経験値) = ( 〇(現在のレベル) * x(定数) )
　上記のような形でいけるか？今回は以下の式を採用

    while (int i < 21;) {
        levelList.add(levelPoint)
        levelPoint = (int)( (levelPoint + this.level) * 1.25);
        i++
    }

・Spell healSpell = new HealSpell();
　Spell attackSpell = new AttackSpell();
　で勇者が持つ呪文インスタンスを2種類に分けて生み出し、使う時は
　brave.healSpell.hoimi();　のようにして呼び出す。

・仮に呪文の上限が5個だとして、(ホイミ(3)、メラ(5)、ベホイミ(9)、メラミ(14)、メラゾーマ(17))
　呪文一覧を表示する際にレベルアップの状況に応じてその時点で習得している呪文を表示するには？
　レベルアップのメソッドに呪文を紐づける必要がある。そして、勇者クラスに呪文一覧表示のフォーマットを
　作成し、レベルアップのときに呪文を表示するフォーマットに習得した呪文を増やすプログラムを書く必要がある。

・経験値とレベルはマップにして対応表みたいな形で扱えばよいのでは？(むずそうなので保留)

・呪文に番号を振る形に決定する。

    switch(spellChoice) {
        case 1:
            healSpell.hoimi();
            break;
        case 2:
            attackSpell.mera();
            break;
        case 3:
            healSpell.behoimi();
            break;
        case 4:
            attackSpell.merami();
            break;
        case 5:
            attackSpell.merazoma();
            break;
        default
            // 想定外の数値が選ばれた場合はもう一度選びなおさせるようにしたい
    }

・呪文表示用のString型フィールドを用意し、「\n%s：2」のようにして呪文表示のフォーマットに追加していく

・レベルがまだ低いときに「つかえるじゅもんがない！」と表示して戦いの選択肢に戻すプログラムも欲しい

・じゅもんやアイテムを選択した後、戻る選択肢は0とし、returnすればbattleメソッドに戻れる

    if (this.level > 2) {
        system.out.println("つかえるじゅもんがない！")
        return;
    }
    if (this.level > 2 && this.level < 5) {
        System.out.println("ホイミ：1")
    }
    if (this.level > 5 && this.level < 9) {
        System.out.println("ホイミ：1\nメラ：2)
    }

・上記のようなプログラムだと、「じゅもん」を選択したときにいちいち計算を行わなければならない。
　その都度計算してそれに対応する物を表示するのではなく、もう用意してあるものをポンと表示したい。
　そうするにはフィールドでフォーマットを持つのが一番良いと思うが、それの上手い扱い方が分からない。
　レベルに応じてフォーマットにどうやって追加していけばよいのか？
　一番想像がつくのはcheckSpellUpに合わせて呪文一覧のフォーマットにも追加していくといった形。

・呪文一覧のフォーマットをレベルごとに合わせて表示するのは恐らく解決したが、
　このままのswitch文でいくとじゅもんをまだ1つしか習得していないのに4を入力すると
　メラミが使えてしまうプログラムになっている
　これを直すにはどうすればよいか？switch文の中でif文やcheckSpellUpの何らかの要素を使って
　判定することはできないか？
　　→　各呪文メソッド内でレベルチェックを行うようにする

・Spellメソッドの中でthis.spell.healSpell.hoimi()のようにはできない、
　なぜならSpell spell = new healSpell();を勇者クラスで行わなければならないから。
　これはmainメソッドで行う予定だが、ではspellメソッドはどうすればよいのか？

・習得したタイミングでそのじゅもんインスタンスをうみだせばよいのでは？
　しかしホイミを習得 → HealSpellインスタンスを生み出すと
　何らかの手違いでベホイミが使えてしまうのではないか？

・敵をランダムにわかせる方法とは？
　そのマップに出現する敵の種類の数だけ乱数を作成して(3種類なら「1～3」を乱数プログラムで作成)
　その値によって出現する敵を変える(1ならスライム、2ならゴブリン…みたいな感じ)
　これを勇者クラスのsearchEnemyでやるのは割と理にかなっているのでは？結構いいかも
　一瞬マップ間で敵の種類数が異なる場合どこで差異をつけるんだ？と思ったが、
　if文の中に乱数生成プログラムがあるなら全く問題なかった

・それぞれのマップに出現する通常敵の数は

　森　→　3種類
　海　→　4種類
　山　→　6種類

　にする

・上記は敵を探すときのプログラムだが、お宝を探すsearchTreasureでも同じように
　マップ属性を使えばいいかんじになるのでは？

・敵アイデア

　森
　　スライム、ウルフ、キラービー
　海
　　ひとくいザメ、かいぞく、
　山
　　デスイーグル、がんせきまじん、マグマゴーレム、

・たとえば、その地のお宝を1つ以上見つけ、敵を4体以上倒せばボス解放。
　ボスフラグを勇者クラスのフィールドに定義する。
　chooseMapActionメソッド内のswitch文にはあらかじめcase 5:も定義しておき、
　そこに記述される仮にbattleBoss()メソッドの先で以下のプログラムを書いておけばよいのではないか？

　if (ボスフラグ == off) {
    return;
} else if (ボスフラグ == on) {
    chooseMapActionで表示する文字列変数 += "ボスとたたかう：5"
}

・マップ間の移動がマップアクションで選べるならば、各マップでボスフラグの進行状況は違う
　仮に森：4(ボス出現)　海：3(ボス未出現)　山：7(ボス出現)だとすると
　森にいる場合は5：ボスバトルが表示され、
　海にいる場合はまだ表示されず、
　山にいる場合は5：ボスバトルが表示される。

　森　　　海　　　山
　this.mapAttributeには現在いるマップ名が格納されている。
　this.forestBossFlagにはボスバトル解放のための行動回数がカウントされている。
　「今いるマップ」のボスフラグをカウントする形にもっていければよい？
　そのマップに初めて訪れる時にそのマップのインスタンスを生成するのはどうか？
　勇者が持つMapフィールドに現在いるMapインスタンスをセットすれば現在いるマップが分かる？
　this.map = new Forest();

　マップクラスはフィールドにEnemyクラスを持てると思うのだがそれはどうか？
　map.enemy = new Slime();

　マップクラスに乱数によってランダムに敵を生成するメソッドを実装するのはどうか？
　そうすれば勇者クラスのsearchEnemyメソッドがもうちょっと見やすくなるのでは？
　public Enemy createEnemy() {
    int enemyNumber = new java.util.Random().nextInt(3);
    switch(enemyNumber) {
        case 0:
            Enemy = new Slime();
            break;
    }
}

switch(this.map.getName) {
    case "森":
        Enemy enemy = this.map.createEnemy;
}

・勇者クラスのmapを現在地にするならば、つまりthis.map.createEnemy()はその現在地の敵を作ることになる？
　ということはsearchEnemyでマップによってswitch文で振り分ける必要がなくなる？
　　→ 結構いい感じにいけそう

・createSpellNameList(呪文名リスト)とcreateGetSpellLevelList(呪文習得レベルリスト)の2つは
　どうにかマップにまとめていい感じにプログラムを簡単にできないか？

・そのマップをクリアしたらマップ名は「森(クリア！)」のようにしたい
　そのため、勇者クラスのthis.map.nameを用いて判別するようなプログラムは
　その変数の名前.equals("森")などにするのではなく、"森"が含まれているかどうかで判別するようにしたい。

・敵の攻撃をどうやって実装すればよいか？勇者クラスでbattleメソッドを実装しているが、
　そうするとe.attack()の引数に勇者インスタンスを持ってこれない
　battleクラスを作るのもアリ、「戦い」は勇者だけのものではなく客観的に見て
　勇者と敵の戦いなのでクラスとして独立していてもおかしくはない、はず
　しかし結局勇者インスタンスの引数をどうすればよいかは解決していない

・勇者クラスは今のところ攻撃力と守備力のみだが、これは自身のステータス + 装備合わせた数値であって
　勇者自身のステータス用の攻撃力(ちから)と守備力(みのまもり)も必要では？
　　→ 追加済み

・このメモもjavagameNote.txtのような形でgithubにあげる

・[進捗]ターン制バトルの実現、勇者クラスで全て行うのではなく
　　　　勇者クラスでなくてもよさそうなもの、または勇者クラスでない方が良い実装については
　　　　順次Eventクラスに実装していく(バトルやマップアクションなど)
　　　　それと勇者クラスと敵クラスにそれぞれ自分のターンを意味する「turnメソッド」を実装する

=========================================================================================================

ゲームのフロー

どのマップに行きますか？(mapChoose) → 選ばせる(return)
↓
選んだ数字に該当するマップを決める(仮に森だとする) → 選んだ答えによって決める(chooseMap,switch文？)
↓
森にやってきた！ → 表示する(system.out.println)
↓
勇者はどうする？(mapAction,while) → 選ばせる(return)
↓
選択肢によって行動が変わる(仮にsearchEnemyとする) → 選んだ答えによって決める(switch → battle)
↓
敵と戦う(Battle) → Battleの中で行動を選ばせる(while内でswitch) → 敵か勇者のHPが0になったら繰り返し終了
↓
戦いが終わる
↓
勇者はどうする？(mapAction,while)
↓
一定の条件をクリアするとマップの奥地(ボス戦)が解放される
↓
勇者はどうする？(mapActionにボス戦が追加されたやつ)
↓
ボス戦を選択
↓
ボスイベント(Forest.bossEvent)
↓
ボスを倒した！
↓
どのマップに行きますか？(mapChoose)

=========================================================================================================

呪文使用のフロー

「じゅもん」を選択(battle)
↓
呪文一覧を番号に対応させた形で表示(printf)
↓
呪文を選択
↓
選択された呪文によって呼び出すメソッドを変える(switch)
↓
その呪文インスタンスを

=========================================================================================================

ミスや引っかかったこと、つまずいたことやわからないこと

・import map;としてもimport文にエラーが出現し、mapパッケージのファイルが読みこめない。
　import map.Mapやimport spell.Spellだとちゃんと認識してくれる。
　だけどいちいちattackspellやhealspellとかもimportで記述しないといけないのは面倒。
　　→ そもそもimport文は「import パッケージ名.クラス名」のようにクラス名まで記述する必要があるため、
　　　import map;のように「import クラス名;」でエラーが出るのは当然。単に基礎知識不足だった。
　　　「import Map.*」や「import spell.*」とすることによって解決。

・