Java Bronze 勉強メモ

https://www.oracle.com/jp/education/certification/ocjp-silver-se8-3494542-ja.html

問題7

・インクリメント演算子と三項演算子に関する問題。int num = 5; としている場合、
　int count = num++; のように後置インクリメントで代入を行っている場合は、先にnumをcountに代入してからインクリメントを行う。
　そのため、この式が終わった時点ではcount = 5, num = 6、となっている。
　int result = ++count; のように前置インクリメントで代入を行っている場合は、先にcountの値をインクリメントしてからresultに代入する。
　そのため、この時点でnum = 6, count = 6, result = 6 のようになる。

　次に、String str = num == count ? num < result ? "ARG" : "BOL" : "CHL"; と三項演算子を用いているが、
　三項演算子はtrueのときに : の左、falseのときに : の右が評価される。

　実際に String str = a > b ? c > d ? "abc" : "def" : "ghi";　を試してみると、
    true,true → abc
    true,false → def
    false,true → ghi
    false,false → ghi
　となった。どういうこと？

　やっとわかった。a > b がtrueの時は「c > d ? "abc" : "def"」が評価されて、falseの時は「"ghi"」が評価される。
　だからa > b がfalseの時は必ず ghi になるのもこれで納得がいく。
　ずっとa > b がtrueになった時にだけ c > d が評価される、みたいな考えをしてしまっていた。コロン3つあることにも面食らった。

・問題8のように、二次元配列を拡張for文で for (char[] ca : chArr) {...} とした場合、ca にはchArrが保有する配列が順番に渡されていく。

・for文などでbreak; の後にプログラムを記述すると到達不能コードとなりエラーが出るので注意する。

・インスタンスメソッドからクラス変数にアクセスすることはできるが、
　クラスメソッド(staticメソッド)からインスタンス変数にアクセスすることはできないので注意する。

・同クラス内のコンストラクタを呼び出すにはthis(); またはthis(引数リスト); と記述するが、「必ずコンストラクタ内の先頭で1回のみ」とする。
　コンストラクタ呼び出し同士がお互いを呼び出していて、循環してしまうような呼び出し方もできない。

・アクセス修飾子は、public > protected > パッケージ・プライベート(アクセス修飾子なし) > private の順で厳しくなることを覚えておく。
　オーバーライドする際はより緩い修飾子にすることは可能だが、厳しい修飾子に変更してオーバーライドすることはできない。

・インタフェースのデフォルト修飾子として、インタフェースではメソッド(default,staticメソッド以外)は暗黙的にはpublic abstract が付加され
　変数(定数)には暗黙的にpublic static final が付加される。そのため、インタフェースでvoid abc(); となっているメソッドを
　それを実装したクラスでvoid abc() {} とすると、クラスは修飾子を省略するとパッケージプライベートになるため、
　より厳しい修飾子でオーバーライドすることになってしまい、コンパイルエラーとなる。

・コンストラクタ場用意されていないクラスには、デフォルトコンストラクタが用意されるが、明示的にコンストラクタが用意されたクラスには
　デフォルトコンストラクタは用意されない。

　コンストラクタ内で、別コンストラクタを呼び出していない場合には、暗黙的にsuper();が追加される

　上記2つのルールから、親クラスに存在しないsuper();を呼び出してエラーになっているような問題に注意する。
　あとはコンストラクタを修正するような問題でも、どっちが正解なんだと迷った場合は、これを意識しなければならない。

・Exceptionクラスのサブクラスの内、RuntimeExceptionクラスのサブクラスは非チェック例外となる。
　Exceptionクラスの全てのサブクラスは復旧可能である。
　catchブロック内のパラメータは全てThrowable型として扱うことができる。

・for文の初期化式; 条件式; 継続式; はどれも省略可能。
　そして、例えばfor(int i = 0; i++ < 5;) {...} のようにi++が条件式にある場合は、条件を判定した後にインクリメントされる。
　つまりfor文内の{...}の時にはインクリメントされていることに注意する。

・配列の要素外にアクセスするのはコンパイルエラーではなく実行時エラーとなるので注意する。
　コンパイルエラーは文法がおかしいときに起こり、実行時エラーは文法的には合っているが実際にプログラムとしておかしい時に起こる。

・「if文やelse文の{}を省略した場合は最初の一行のみが実行される」の意味としては、「最初の一行のみが判定の対象になる」と言った意味である。

if (a > b) {
    a += b;
} else 
    a /= b;
    b += a;

　例えば上記のプログラムでは、仮にa > bがtrueであったとしても、elseの対象は a /= b; のみなので、
　そのあとのb += a; はif文の判定に関わらず必ず実行される。これがif文の「最初の一行だけ実行される」の意味なので注意する。

・コンストラクタで
super();
this();
　のようにしてはならない理由としては、親クラスのコンストラクタが暗黙的に呼び出されることが関係している。
　コンストラクタの先頭には暗黙的にsuper();があるため、上のような例ではthis();の中でまたsuper();が呼び出され、
　親クラスのコンストラクタが2回呼び出されることとなってしまう。

・情報隠蔽とは、抽象化を維持するための設計原則。抽象化することで共通部分にのみ着目すればよくなるため、クラス間の関係はシンプルになる。

・do while(x > 0) {

}

　上記のようなプログラムで全く疑問を抱かずにコンパイルエラーを選択できなかったので、あまり早く早くと急ぎすぎてもよくない。
　ちゃんと問題を見る、そもそもプログラムが正しい記述をしているかを見ること。

・クラス名で使用できる文字は、1文字目以降にUnicode文字、アンダースコア、ドル記号であり、2文字目以降はこれらに加えて数字が使える。

・Javaプログラミング言語には、以下のような特徴がある。

    プラットフォームに依存しない
    アーキテクチャに依存しない
    自動でメモリが解放される
    実行時にコンパイルしながら実行する、「実行時コンパイル方式」を採用している
    マルチスレッドによる並行処理をサポートしている
    セキュリティ性能が高い

・アーキテクチャとはソフトウェアを構成するクラス同士の構造のことで、ソフトウェアの用途や形態によってさまざまなアーキテクチャがある。
　Javaは用途を特定しておらず、特定のアーキテクチャに依存しない。

・継承関係にあっても、privateなフィールドやメソッドとコンストラクタは引き継がれないので注意。

・if文を用いた問題で条件式の等価演算子が「==」ではなく「=」になっていないか注意深く見る。

・オーバーロードできていそうでできていないメソッドに注意する。

    int a(int num) {}
    double a(int num) {}

　戻り値だけが異なるのは、どちらを呼び出すのかがわからない。冷静にオーバーロードできているかを確かめる。

・ダウンキャストによるエラーは「実行時エラー」である。なぜなら、キャスト式自体は記述することに何の問題もないから。
　それがダウンキャストだとプログラム側がわかるのは実行時なので、実行時エラーである。

・while(i++ < 5) の条件式で実際にインクリメントされることに注意する。条件式にインクリメントやデクリメント、代入があった場合は
　条件式の判定だけではなくそれらも実際に行われるので気を付ける。

・クラス内のstaticメソッドからは同じクラス内のstaticフィールド、staticメソッドにしかアクセスできないので注意。

・Javaでは「コンスタントプール」と言う仕組みを使い、同じ文字列リテラルによって生成されるStringのインスタンスを使いまわしている。
　例えば以下のコードで生成されたs1,s2のインスタンスへの参照は同じとなり、s1 == s2 がtrueとなるようになっている。

    String s1 = "abc";
    String s2 = "abc";

・for文は条件式に合っていない場合、その内容が1回も実行されず次のプログラムへ進むことに注意する。

・system.out.println((x + 1) * (i++))　のように後置インクリメントの場合は先にその変数が式の中で使われた後で
　インクリメントされることに注意。ちなみに((x + 1) * (++i)) のように前置インクリメントの場合はインクリメントされてから
　式に使われることを確認済み。前置と後置の違いについてとにかく気を付ける。

・Java SEの主な特徴は以下の通り。

    JVMの提供
    標準クラスライブラリの提供
    各種開発ツールの提供

　Java SEは、「JRE」と「JDK」という2つのパッケージで構成されている。JREはJavaプログラムの実行に必要なライブラリ、JVM、
　その他必要なコンポーネントをまとめて提供している。もう1つのJDKは、JREに加えて開発に必要なコンパイラやデバッガ、
　各種開発ツールが含まれている。

　標準クラスライブラリは、大きく分けて以下の3つの機能を提供している。

    基本ライブラリ
    　→ java.lang,java.utilをはじめとする基本的なパッケージが含まれている。他にもI/Oやシリアライズ、ネットワーク機能、
    　　セキュリティや国際化対応、JVMを監視するためのJMX(Java Management eXtensions)、XMLを扱うためのJAXP(Java API for XML Processing)
    　　、Javaとネイティブアプリケーションの連携を実現するJNI(Java Native Interface)などもこのライブラリに含まれる。

    統合ライブラリ
    　→ データベース連携を実現するJDBC(Java Database Connectivity)、分散アプリケーションを開発するためのRMI(Remote Method Invocation)、
    　　CORBA(Common Object Request Broker Architecture)、RMI-IIOP(RMI over IIOP)、ディレクトリサービス連携を実現する
    　　JNDI(Java Naming and Directory Interface)といった機能が含まれる。

    ユーザーインタフェースライブラリ
    　→ GUIを実現するAWTやSwing、画像処理をするためのJava 2D、印刷サービスやテキスト変換などが含まれている。

・Java EEは、各社が提供するソフトウェアが不足なく機能を提供し、且つ互換性があることを保証するための仕様を定めている。
　さまざまなベンダーが製品を提供しているが、Java EEが規定する仕様を満たす製品であれば、同じ機能が提供され、
　且つ互換性を保って使うことができる。

・Java MEは携帯電話やPDAなどの携帯端末、工業用ロボット、テレビのセットトップボックス、プリンタなど、多種多様なハードウェアを制御する
　ソフトウェアを作るためのエディション。このようなハードウェアは限られたメモリサイズ、狭いディスプレイ、容量が少ないバッテリーなど
　多くの制約がある。コンピュータ向けの応用的な使い方やユーザーインタフェースに関するライブラリは、こうした制約のあるハードウェアを
　制御するためには必要ない。このため、Java MEのライブラリは、Java SEの標準ライブラリから最低限必要なAPIを抜き出した形で
　提供されている。

　Java MEでは、こうしたハードウェアなどの環境に柔軟に対応するために、以下の3つの要素から構成されている。

    コンフィギュレーション
    　→ もっとも基本的なライブラリと仮想マシン

    プロファイル
    　→ 特定のデバイス向けのAPIセット

    オプショナルパッケージ
    　→ 特定の技術をサポートするためのAPIセット

　すべてのハードウェアがコンピュータ用のJVMを実行できるリソースを持つわけではない。ハードウェア要件によっては十分なリソースを
　確保できない場合もあり得る。そこでJava MEでは、JVMの他に「KVM」という小型ハードウェア向けの仮想マシンも用意している。
　KVMのKは、数十キロバイト単位の小さなサイズを扱うということに由来している。

・「整数値を代入できる」という問題にfloatとdoubleがあった場合、この2つは確かに代入はできるが小数点も扱えるため
　「中に必ず整数が代入されている」ことは保証できない。そういった問題では恐らくこれが重要視されているので
　char,int,short,longを選択し、float,doubleは選択しないようにする。

・Javaでは0をfalseとして扱わない。よってboolean x = 0; のような代入はできないので注意。

・アクセス修飾子とstaticキーワードの順番は逆でも問題ない。なので、以下のコードはどちらもOKである。

    public static int x;
    static public int x;

・インスタンスフィールド(クラスのプロパティや配列の要素)を初期化しなかった場合のデフォルト値は以下の通り。

    整数型 = 0
    浮動小数点型 = 0.0
    文字型 = \u0000
    真偽値 = false
    参照型 = null

　ちなみにStringはクラスであり参照型のため、初期値はnullである。

・配列の要素数を取得するには、配列が持つフィールドである「length」を参照する。
　文字列の長さを取得するには、Stringクラスが持つメソッドである「length()」を使用する。
　混ざりやすいので注意する。

・以下のようなコードがあった場合、実行時エラーとなる。

    public static void main(String[] args) {
        System.out.println(args[0]);
    }

　なぜこれが実行時エラーになるのかと言うと、コマンドライン引数を指定しない場合でも、必ず配列インスタンスは生成され、
　その場合は要素数0の配列インスタンスが生成されるから。つまり、上記のプログラムは配列の範囲外にアクセスしてしまう事になるため、
　実行時エラーとなる。

・5 / 2 のように、整数値同士の演算結果は小数点以下が切り捨てられる点に注意する。

・演算子の左オペランドの結果により、右オペランドを評価しない演算子のことを「ショートサーキット演算子(短絡演算子)」という
　(&& や || など)。例えば、 論理積(&&)では、左オペランドの結果がfalseの場合は、右オペランドがtrue,falseのいずれでも条件式の結果は
　falseになるため、右オペランドは評価されない。論理和(||)では、左オペランドの結果がtrueの場合は、右オペランドは評価されない。
　つまり、以下のプログラムの実行結果は以下のようになる。

    int a = 0;
    int b = 0;
    if (++a > 0 || ++b > 0) {
        System.out.print("a=" + a + ",");
        System.out.print("b=" + b);
    }

    a=1,b=0

　論理和で左オペランドの結果がtrueなので右オペランドは評価されず、++bも実行されないことになる。
　この点に注意する。

・switch文の式は、char,byte,short,int,Character,Byte,Short,Integer,String,列挙型のいずれかを戻す式でなくてはならない。
　それ以外の場合はコンパイルエラーが発生する。なぜfloatやdoubleがダメなのかと言うと、switch文の式は == で判定を行うため、
　浮動小数点は誤差丸めのせいで正しい比較ができないケースがあるため。浮動小数点で誤差が発生する理由は、浮動小数は2の乗数で数を表すから。
　たとえば、0.5は2の-1乗、0.75は2の-1乗 + 2の-2乗で表す。そのため、2のn乗の合算値で表せない値には誤差が発生してしまう。

　longがダメな理由としては、確かかどうかわからないが高速化のためらしい。連続値を使用するケースではtableswitch_instructionを用いて
　高速に処理をするが、このテーブルが当時の32bit環境に最適化された構造をしているため4byteに抑えられた、という経緯がある。
　Javaは昔のクラスファイルをそのまま実行できる必要があるため、64bitが当たり前の時代になってもtableswitch_instructionの構造を
　変更できずにlong未対応となってしまった、と記述されている。
　参考サイト　https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q13171670558

・「カプセル化」とは、変更に強いソフトウェアを設計するための「設計原則」の1つ。正しくカプセル化されたモジュールは、
　変更に強く、開発の生産性向上だけでなく、長期間にわたって行われる保守作業の軽減を実現する。

　「設計」とは、開発や運用を効率化し、コスト削減を実現するための作業を指す。その良し悪しは、どれだけコストが削減できたかで
　測ることができる。オブジェクト指向は、ソフトウェアの変更容易性や再利用性を向上させることで、コスト削減効果を追求する設計技法。

　ソフトウェアを設計するにあたって、考えるべきことを要約すると以下の2つに絞られる。

    どのような流れで処理をするのか？
    どのようなデータを扱うのか？

　前者の「処理の流れ」から設計を始めるのが「構造化設計手法」、後者の「扱うデータ」から設計を始めるのが「オブジェクト指向設計手法」
　の特徴である。構造化設計手法と比べてオブジェクト指向設計手法が優れている点は、変更に強い設計ができること。
　ただし、オブジェクト指向を使えば変更に強く「できる」だけであり、必ずしも変更に強くなるという意味ではない。間違った使い方をすれば、
　強くなるどころか、変更のたびに余計な工数がかかってしまう「変更に弱い」設計にもなりかねない。
　そのため、設計者は常に変更に強くなることを心がけて設計しなければならない。

　「変更に強い設計」とは、以下の2つの条件を満たすもの。

    変更発生時にその影響範囲がすぐに特定できること
    変更への対応が工数をかけずにできること

　変更発生時には対象となる部分だけでなく、関係する箇所も変更しなくてはいけない。しかし、その時に次々と変更箇所が広がってしまうような
　設計は変更に強いとは言えない。そのため、変更の影響範囲を明確に切り分けられる設計が求められる。

　変更の影響範囲を特定するには、数多くのモジュールをいかに区別できるかが重要になる。そのためにはモジュールの違いがはっきりとわかる
　設計でなくてはいけない。

　カプセル化は、影響範囲の特定に関わる重要な設計原則である。カプセル化は、「関係するデータ」をまとめ、さらに「そのデータを扱う処理」
　をまとめて、1つのモジュールとして定義することである。適切にカプセル化されたモジュールは、開発者が区別しやすい単位に分割されているため、
　どのモジュールを変更すればよいかを特定しやすくする。

・データ隠蔽の目的はカプセル化の維持。カプセル化を崩す要因は、あるモジュールのデータに他のモジュールからアクセスすること。
　たとえばモジュールAとモジュールBがあった場合に、モジュールAにあるデータを必要とする処理はすべてAになければいけない。
　しかし、モジュールBにモジュールAのデータを必要とする処理があった場合、そのデータに変更が加わった場合の影響について
　モジュールBの影響も調べる必要が生じる。このような事態に陥らないために、データを隠蔽しアクセスを拒否することで
　カプセル化を維持するのである。

・ソフトウェア開発では、ソフトウェアが解決すべきビジネス上の課題のことを「問題領域」と呼ぶ。ソフトウェアが様々な分野で
　活用されるようになるにつれて、問題領域に含まれる要素は増え続け、それらの関係も複雑化していった。そのため、ソフトウェア開発の現場では
　問題領域を単純化する技法を求め、試行錯誤を繰り返してきた。そうして採用されたものが「分割統治」と「抽象化」である。

　「分割統治」は、問題が大きなまま解決を試みるのではなく、問題を小さな単位に分割し、単純化することで個別に解決しながら
　全体の大きな問題を解決していく問題解決技法の1つ。オブジェクト指向は、これにカプセル化で対応する。

　分割統治によって分解され、単純化された問題領域の要素は結合されることで元の問題領域を表現できる。しかし、複雑な問題を単純になるまで
　分解すると、その数は膨大な量となりそれらを結合する部分は累乗的に増えていく。結果として、簡単にするために分解したものを
　1つに戻すために結合すると、余計に複雑になるという事態が発生してしまう。

　この問題を解決するのが「抽象化」である。抽象化は、対象から注目すべき要素を抜き出し、それ以外を無視することによって
　複雑な問題を単純化する方法。単純化すれば全体像をつかみやすくなったり、問題の本質をとらえやすくなったりする効果がある。
　なお、オブジェクト指向では抽象化してオブジェクトを扱うことを「ポリモーフィズム」と呼ぶ。

　抽象化は一般的な思考方法の1つで、たとえばサッカー選手のA,B,Cさんをひとくくりにサッカー選手として扱うのは抽象化である。
　A,B,Cさんという個人の違いは無視し、サッカー選手としての特徴だけに着目するようになる。このように個人の違いを無視することで
　「サッカー選手とはどういう人のことを指すのか？」という本質だけに着目できるようになる。

　抽象化をソフトウェアに置き換えると、共通点があるモジュールをひとまとめにして1つの方で扱い、共通点以外の部分は無視することになる。
　抽象化を使うことで、「分割統治と抽象化のイメージ図.png」にある図のように、複雑に絡み合っていたモジュール間の関係が単純化される。

　抽象化では、共通点を持つオブジェクトをまとめて、それぞれのオブジェクトの違いを無視して1つの型で扱うことで
　モジュールの連携箇所を減らして、ソフトウェアを単純化する。

・Javaのプログラムで、データやインスタンスの「扱い方」を決めているのが変数の「型」である。
　変数の型は、その変数で使うデータの種類を表しており、そのデータをどのように扱うべきかを定義するもの。
　たとえば、3という数値をint型の変数に代入するとint型の値として扱うが、double型の変数に代入すればdouble型の値として扱う。

　また、参照型変数の場合は、データの値ではなく参照(というデータ)が格納されているため、参照の先にあるインスタンスをどのように扱うかを
　変数の型で宣言していることになる。例えば、A a = new B(); といったコードの場合、BのインスタンスをAという型で扱うことになる。

　ここで注意するのが、参照型変数の方は参照の先にあるインスタンスを「どの型で扱うか」を定義するものであるということ。
　「実際に動作するのは型ではなくインスタンスそのもの」であることに注意する。

・「ポリモーフィズム」は、様々な種類のインスタンスを抽象化し、共通の方で扱う。ポリモーフィズムには以下の特徴がある。

    ・どの型で扱っていたとしても、実際に動作するのはインスタンスそのものである
    ・「使う側」のクラスは、「共通化して扱える型」だけを知っていればよく、「使われる側」の具体的な違いを意識することは無い
    ・「使う側」が「使われる側」の変更の影響を受けることは無い
    ・影響を受けるのは、共通化して扱える型が変わった時のみ

・「情報隠蔽」は、抽象化の効果を維持するために必要な設計原則である。

　抽象化によって単純化されたモジュール間の関係が、後々の保守時に崩れ、ソフトウェアの構造が複雑になってしまうと、
　変更コストが大幅に増えてしまう可能性がある。最悪の場合、コストがかかりすぎるために保守不能に陥ることもあり得る。
　このような事態を防ぐためにも、抽象化・単純化された構造が崩れないような設計が求められる。

　単純化された構造が崩れるのは、抽象化によって無視したはずのモジュールが使われてしまうため。たとえば、モジュール群を抽象化し、
　単純化して扱う時、使う側が使われる側の詳細を知っている状況があるとする。「詳細を知っている」というのは、共通の型だけでなく
　具体的にどのクラスのインスタンスが動いているか、各クラスがどのような独自メソッドを持っているかを知っていること。
　このような状況では「便利だから」「楽だから」と言う理由で、無視したはずの独自機能を使おうとする開発者が出てしまう可能性がある。
　その結果、シンプルだったはずの関係が複雑化してしまう。

・情報隠蔽は、公開すべきものと非公開にすべきものを分け、非公開にすべきものを隠蔽するよう設計するという原則。

　Javaでは、公開部分をインタフェースとして定義する。抽象化されたモジュール群はインタフェースを実現するよう実装し、
　ポリモーフィズムによって、実際に動くインスタンスの型を隠蔽する。また、非公開部分への不適切なアクセスを防ぐために
　「パッケージ」や「アクセス修飾子」を使ってアクセスを制御する。

・クラス宣言時に指定できるアクセス修飾子はpublicがデフォルト(パッケージプライベート)しかないが、
　コンストラクタにはそれに加えてprivate,protectedも指定できるため、クラスを非公開にする方法として
　コンストラクタを使ったアクセス制御はより柔軟な制御が可能となる。

・インタフェースには以下のような特徴がある。

    実装を持たないメソッド宣言のリスト
    実装を持たないため、インスタンス化できない
    実装は、インタフェースを実現したクラスが提供する
    メソッドの宣言以外には、定数のみ定義できる

　Javaのプログラムは、コンパイルや実行時に「型」と「実装」に分けて扱われる。インタフェースはこの「型」をあらわしたもの。
　インタフェースを理解するために、まず型と実装が異なる概念であることを覚える。

　Javaのプログラミングでの基本的な単位は、「クラス」である。クラスには、どのように動くべきかという「実装」が記述されている。

　一方、オブジェクト指向設計の基本的な単位は、「型(タイプ)」である。型とは、オブジェクトの「種類」を表したもの。
　オブジェクト指向設計では、どのような種類のオブジェクトがどのような種類のオブジェクトと連携するかを検討することから始める。
　型を使って設計すれば、過度に詳細になりがちな実装を意識しなくてもよいため、ソフトウェアの全体構造を検討できる。
　そのため、オブジェクト指向設計では、全体像(ソフトウェアの構造)を検討してから、詳細な動作(実装)を検討していく。

　このように、オブジェクト指向では型と実装を異なる概念として扱う。実際に動作するもの(実装)と、その扱い方(型)が一致する必要はない。
　そのため、ある実装をそれを持つクラスとは別の方で扱うという、ポリモーフィズムが成り立つのである。

　クラスは、型と実装の両方を持っている。実装を持たず、型だけを定義したものをインタフェースと呼ぶ。「実装を持たない」とは、
　「どのように動作すればよいかと言う具体的な処理を持たない」ということを意味する。そのため、インタフェースはインスタンス化できない。
　実装はインタフェースを実現したクラスが提供する。

　また、型は動作しないため、変わらないものだけを定義できる。変わらないものには、メソッドの宣言と定数がある。
　具体的には、インタフェースにもメソッドの宣言とstaticな定数のみが定義できる。
　インタフェースは、メソッド宣言と定数のリストだと覚えておくのが良い。

・ソフトウェア開発に限らず、何らかの対象を理解するための行動を「分析」と呼ぶ。ソフトウェア開発では、顧客の要求を聞き、
　何を作らなければいけないかを正しく理解するために、要求そのものや背景となる業務の分析は欠かせない。
　古くからある分析のための技法には「分解」と「分類」の2つがある。分解は構造を明らかにし、分類は共通点を体系化する。
　オブジェクト指向によるモデリングでは、この分解と分類と言う技法を取り入れ、ソフトウェアとして表現すべき対象を理解しやすくしている。

　対象となる「ものごと」がどのような要素で成り立っているか「分解」し、ものごとの構成関係を表すのが「has-a関係」である。
　たとえば、自動車がタイヤやエンジン、ハンドルなどで構成されている場合には以下のような関係が成り立つ。

    自動車 has-a タイヤ
    自動車 has-a エンジン
    自動車 has-a ハンドル

　これらの関係は「自動車はタイヤを持っている」や「自動車はタイヤで構成されている」と言い表す。
　このように、ものごとを分解して「全体と部分の関係」で表現するのが「has-a関係」である。

　「持っている」ことをJavaでは、「フィールド」で表現する。たとえば、自動車がエンジンを持っている場合には以下のようなコードで表現する。

    public class Car {
        private Engine engine;
        public void setEngine(Engine engine) {
            this.engine = engine;
        }
    }

　「分類」は、共通点を見つけて体系化することで、全体像を見失うことなく、個別のものごとに分解する分析の技法。
　分解が構造を使った分析方法であるのに対し、分類は意味や役割、本質に着目して分析する方法。
　オブジェクト指向では分類を汎化・特化の関係で表現し、Javaでは継承の関係で表現する。
　なお、インタフェースとそれを実現するクラスとの関係も「is-a関係」にあるといえる。

　たとえば、乗り物を継承した自動車があった時、自動車は乗り物の一種である。このような関係があったとき、「自動車 is-a 乗り物」
　というようにis-aを使って2つの関係を表現する。

　さらに自動車を継承したガソリン車と電気自動車を定義すると、以下のような関係が成り立つ。

    ガソリン車 is-a 自動車
    電気自動車 is-a 自動車

　「自動車 is-a 乗り物」という関係に加えると、ガソリン車は自動車の一種で、自動車は乗り物の一種である関係が成り立つ。
　そのため、「ガソリン車 is-a 乗り物」という関係も成り立つ。同様に、電気自動車も乗り物の一種であることがわかる。

　is-a関係は「サブクラス is-a スーパークラス」または「実装クラス is-a インタフェース」という関係で表現する。

・

=================================================================================================================================

受験申しこみ方法、注意点など

・参考サイト
https://qiita.com/Channel/items/31e50323d2b7ee78f7cc
https://nokonokonetwork.com/certificate/oracle/how-to-apply-for-oracle-master-and-java-certification-exam.html

・