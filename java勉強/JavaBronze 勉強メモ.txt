Java Bronze 勉強メモ

https://www.oracle.com/jp/education/certification/ocjp-silver-se8-3494542-ja.html

問題7

・インクリメント演算子と三項演算子に関する問題。int num = 5; としている場合、
　int count = num++; のように後置インクリメントで代入を行っている場合は、先にnumをcountに代入してからインクリメントを行う。
　そのため、この式が終わった時点ではcount = 5, num = 6、となっている。
　int result = ++count; のように前置インクリメントで代入を行っている場合は、先にcountの値をインクリメントしてからresultに代入する。
　そのため、この時点でnum = 6, count = 6, result = 6 のようになる。

　次に、String str = num == count ? num < result ? "ARG" : "BOL" : "CHL"; と三項演算子を用いているが、
　三項演算子はtrueのときに : の左、falseのときに : の右が評価される。

　実際に String str = a > b ? c > d ? "abc" : "def" : "ghi";　を試してみると、
    true,true → abc
    true,false → def
    false,true → ghi
    false,false → ghi
　となった。どういうこと？

　やっとわかった。a > b がtrueの時は「c > d ? "abc" : "def"」が評価されて、falseの時は「"ghi"」が評価される。
　だからa > b がfalseの時は必ず ghi になるのもこれで納得がいく。
　ずっとa > b がtrueになった時にだけ c > d が評価される、みたいな考えをしてしまっていた。コロン3つあることにも面食らった。

・問題8のように、二次元配列を拡張for文で for (char[] ca : chArr) {...} とした場合、ca にはchArrが保有する配列が順番に渡されていく。

・for文などでbreak; の後にプログラムを記述すると到達不能コードとなりエラーが出るので注意する。

・インスタンスメソッドからクラス変数にアクセスすることはできるが、
　クラスメソッド(staticメソッド)からインスタンス変数にアクセスすることはできないので注意する。

・同クラス内のコンストラクタを呼び出すにはthis(); またはthis(引数リスト); と記述するが、「必ずコンストラクタ内の先頭で1回のみ」とする。
　コンストラクタ呼び出し同士がお互いを呼び出していて、循環してしまうような呼び出し方もできない。

・アクセス修飾子は、public > protected > パッケージ・プライベート(アクセス修飾子なし) > private の順で厳しくなることを覚えておく。
　オーバーライドする際はより緩い修飾子にすることは可能だが、厳しい修飾子に変更してオーバーライドすることはできない。

・インタフェースのデフォルト修飾子として、インタフェースではメソッド(default,staticメソッド以外)は暗黙的にはpublic abstract が付加され
　変数(定数)には暗黙的にpublic static final が付加される。そのため、インタフェースでvoid abc(); となっているメソッドを
　それを実装したクラスでvoid abc() {} とすると、クラスは修飾子を省略するとパッケージプライベートになるため、
　より厳しい修飾子でオーバーライドすることになってしまい、コンパイルエラーとなる。

・コンストラクタが用意されていないクラスには、デフォルトコンストラクタが用意されるが、明示的にコンストラクタが用意されたクラスには
　デフォルトコンストラクタは用意されない。

　コンストラクタ内で、別コンストラクタを呼び出していない場合には、暗黙的にsuper();が追加される

　上記2つのルールから、親クラスに存在しないsuper();を呼び出してエラーになっているような問題に注意する。
　あとはコンストラクタを修正するような問題でも、どっちが正解なんだと迷った場合は、これを意識しなければならない。

・Exceptionクラスのサブクラスの内、RuntimeExceptionクラスのサブクラスは非チェック例外となる。
　Exceptionクラスの全てのサブクラスは復旧可能である。
　catchブロック内のパラメータは全てThrowable型として扱うことができる。

・for文の初期化式; 条件式; 継続式; はどれも省略可能。
　そして、例えばfor(int i = 0; i++ < 5;) {...} のようにi++が条件式にある場合は、条件を判定した後にインクリメントされる。
　つまりfor文内の{...}の時にはインクリメントされていることに注意する。

・配列の要素外にアクセスするのはコンパイルエラーではなく実行時エラーとなるので注意する。
　コンパイルエラーは文法がおかしいときに起こり、実行時エラーは文法的には合っているが実際にプログラムとしておかしい時に起こる。

・「if文やelse文の{}を省略した場合は最初の一行のみが実行される」の意味としては、「最初の一行のみが判定の対象になる」と言った意味である。

if (a > b) {
    a += b;
} else 
    a /= b;
    b += a;

　例えば上記のプログラムでは、仮にa > bがtrueであったとしても、elseの対象は a /= b; のみなので、
　そのあとのb += a; はif文の判定に関わらず必ず実行される。これがif文の「最初の一行だけ実行される」の意味なので注意する。

・コンストラクタで
super();
this();
　のようにしてはならない理由としては、親クラスのコンストラクタが暗黙的に呼び出されることが関係している。
　コンストラクタの先頭には暗黙的にsuper();があるため、上のような例ではthis();の中でまたsuper();が呼び出され、
　親クラスのコンストラクタが2回呼び出されることとなってしまう。

・情報隠蔽とは、抽象化を維持するための設計原則。抽象化することで共通部分にのみ着目すればよくなるため、クラス間の関係はシンプルになる。

・do while(x > 0) {

}

　上記のようなプログラムで全く疑問を抱かずにコンパイルエラーを選択できなかったので、あまり早く早くと急ぎすぎてもよくない。
　ちゃんと問題を見る、そもそもプログラムが正しい記述をしているかを見ること。

・クラス名で使用できる文字は、1文字目以降にUnicode文字、アンダースコア、ドル記号であり、2文字目以降はこれらに加えて数字が使える。

・Javaプログラミング言語には、以下のような特徴がある。

    プラットフォームに依存しない
    アーキテクチャに依存しない
    自動でメモリが解放される
    実行時にコンパイルしながら実行する、「実行時コンパイル方式」を採用している
    マルチスレッドによる並行処理をサポートしている
    セキュリティ性能が高い

・アーキテクチャとはソフトウェアを構成するクラス同士の構造のことで、ソフトウェアの用途や形態によってさまざまなアーキテクチャがある。
　Javaは用途を特定しておらず、特定のアーキテクチャに依存しない。

・継承関係にあっても、privateなフィールドやメソッドとコンストラクタは引き継がれないので注意。

・if文を用いた問題で条件式の等価演算子が「==」ではなく「=」になっていないか注意深く見る。

・オーバーロードできていそうでできていないメソッドに注意する。

    int a(int num) {}
    double a(int num) {}

　戻り値だけが異なるのは、どちらを呼び出すのかがわからない。冷静にオーバーロードできているかを確かめる。

・ダウンキャストによるエラーは「実行時エラー」である。なぜなら、キャスト式自体は記述することに何の問題もないから。
　それがダウンキャストだとプログラム側がわかるのは実行時なので、実行時エラーである。

・while(i++ < 5) の条件式で実際にインクリメントされることに注意する。条件式にインクリメントやデクリメント、代入があった場合は
　条件式の判定だけではなくそれらも実際に行われるので気を付ける。

・クラス内のstaticメソッドからは同じクラス内のstaticフィールド、staticメソッドにしかアクセスできないので注意。

・Javaでは「コンスタントプール」と言う仕組みを使い、同じ文字列リテラルによって生成されるStringのインスタンスを使いまわしている。
　例えば以下のコードで生成されたs1,s2のインスタンスへの参照は同じとなり、s1 == s2 がtrueとなるようになっている。

    String s1 = "abc";
    String s2 = "abc";

・for文は条件式に合っていない場合、その内容が1回も実行されず次のプログラムへ進むことに注意する。

・system.out.println((x + 1) * (i++))　のように後置インクリメントの場合は先にその変数が式の中で使われた後で
　インクリメントされることに注意。ちなみに((x + 1) * (++i)) のように前置インクリメントの場合はインクリメントされてから
　式に使われることを確認済み。前置と後置の違いについてとにかく気を付ける。

第1章　Java言語のプログラムの流れ

・Javaは静的言語である。静的言語の場合は、「変数」や「式」が型情報を持つ。式の型は「コンパイル時」に決定され、
　期待されている型と式の結果が合わない場合には、コンパイルエラーが発生する。

・一般的な並行処理の方法には以下の2つがある。

    マルチプロセス
    　→ 同じアプリケーションを複数実行する。

    マルチスレッド
    　→ 1つのアプリケーションで複数の処理を交互に切り替えて実行する。

　Javaはシングルプロセス、マルチスレッドで並行処理を実現する。しかし、どのスレッドを実行するかはJVMが判断するため、
　プログラムから並行処理を完全に制御できるわけではない。

・コンパイラは、プログラムを実行するコンピュータのOSが理解できるようにするために、OSの種類に応じてソースコードをコンパイルする。
　そのため、プログラムを実行するOSごとにコンパイルの結果は異なる。WindowsようにコンパイルしたプログラムはWindows専用、
　macOS用にコンパイルしたプログラムはmacOS専用となり、これらに互換性は無い。

　このように、ソースコードをあらかじめコンパイルしてから実行する方式のことを「事前コンパイル方式」と呼ぶ。
　この方式のメリットは、対象OS専用のコードに変換されているため高速に実行できること。その反面、専用コードであるために
　対象OS以外では実行できないことがデメリットである。

　それに対し、「インタープリタ方式」と呼ばれる方式は、「インタープリタ」と呼ばれる仲介アプリケーションを使って、
　ソースコードを「実行時にコンパイル」することが特徴。インタープリタ方式では、事前にコンパイルして専用コードに変換しておく
　必要が無いため、理論上は対象OSごとのインタープリタを用意すれば、プログラムをどのようなOSでも実行できる。

　Javaは「Write Once, Run Anywhere」を実現するために、このインタープリタ方式を採用しており、JVMがプログラムの実行時に
　OS専用のコードにコンパイルしながらプログラムを実行する。そのため、OSごとにJVMを用意すれば、Javaのプログラムはどこでも実行できる。

　Javaがインタープリタ方式を採用したのは、以下のような理由から。

    1．特定のプラットフォームやOSに依存しない
    2．ガベージコレクションによってメモリ管理が自動化できる
    3．セキュリティが向上する

　理由1は、インタープリタ方式の特徴そのもの。

　インタープリタ方式の場合、OSがプログラムを直接実行するのではなく、JavaであればJVM、JavaScriptであればブラウザという具合に
　コンパイルしながら実行する仲介アプリケーションが存在する。この仲介アプリケーションが、実行時にどのようにメモリを使用するかを決めたり、
　不要になったメモリは無いかを確認したり、問題のあるコードは無いかをチェックしたりしながらプログラムを実行するため、
　上記の理由2と3のようなメリットが生まれるのである。

・上記で説明した通り、JVMによるインタープリタ方式の実行形態を採用することにより様々なメリットが得られるが、
　その一方でいくつか問題点もある。もっとも顕著な問題が「パフォーマンス」である。

　ソースコードは人間が理解しやすいように記述するものであって、プログラムが実行しやすいかどうか、効率よく実行できるかどうかという
　観点で記述するものではない。そこで、ソースコードから不要なコードを排除し、パフォーマンスが向上するようにコードを変換しておく
　インタープリタ方式の1つが「実行時コンパイル方式」である。

　実行時コンパイル方式では、コンパイラによって実行に最適化されたコードに変換されているため、インタープリタ方式でも
　パフォーマンスが低下しにくいという特徴を持つ。Javaは、この実行時コンパイル方式を採用した「Hotspot VM」という技術を
　JVMに導入している。その結果、Javaは事前にコンパイルしておく言語と比べても遜色ないほどのパフォーマンスを持つことに成功したのである。

　なお、Javaの実行時コンパイル方式では、コンパイラによって変換されたコードを「中間コード」と呼ぶ。
　中間コードは、より効率が良いコードへの最適化だけでなく、変換効率を上げるために2進数で表現されるバイトコードで記述されている。
　「クラスファイル」は、この中間コードが記述されたファイルのことを指す。

・ガベージコレクションは、「ガベージコレクタ」と呼ばれるJVMの機能が実行する。ガベージコレクションは、ガベージコレクタの
　アルゴリズムに従って実行されるため、プログラマーがメモリ開放のタイミングを制御することはできない。

　また、ガベージコレクタにはガベージコレクションによってメモリ領域に空き領域ができた時、細切れになったメモリ領域を整理し、
　空き領域を確保する「コンパクション」と呼ばれる機能もある。Javaは、この機能のおかげで効率的にメモリ領域を使うことができる。

・処理を始めるためのメソッドのことを「エントリーポイント」という。JVMはJavaコマンドで指定されたクラスを読み込み、
　そのクラスに定義されているエントリーポイント空処理を始める。

　Javaでエントリーポイントに適用されるルールは以下の通り。

    publicであること(公開されていること)
    staticであること(インスタンスを生成しなくても実行できること)
    voidであること(戻り値は戻せないこと)
    メソッド名は「main」であること
    引数はString型配列を1つ受け取ること

　つまり、public static void main(String[] args) {} で変更できるのは「args」の部分だけとなる。
　エントリーポイントの引数には、String型配列だけでなく以下のように可変長引数のString型を受け取ることもできる。

    public static void main(String... args) {}

・「ソースファイル」には、publicで修飾されたクラスやインタフェース、列挙型は1つしか記述できない。

・Java SEの主な特徴は以下の通り。

    JVMの提供
    標準クラスライブラリの提供
    各種開発ツールの提供

　Java SEは、「JRE」と「JDK」という2つのパッケージで構成されている。JREはJavaプログラムの実行に必要なライブラリ、JVM、
　その他必要なコンポーネントをまとめて提供している。もう1つのJDKは、JREに加えて開発に必要なコンパイラやデバッガ、
　各種開発ツールが含まれている。

　標準クラスライブラリは、大きく分けて以下の3つの機能を提供している。

    基本ライブラリ
    　→ java.lang,java.utilをはじめとする基本的なパッケージが含まれている。他にもI/Oやシリアライズ、ネットワーク機能、
    　　セキュリティや国際化対応、JVMを監視するためのJMX(Java Management eXtensions)、XMLを扱うためのJAXP(Java API for XML Processing)
    　　、Javaとネイティブアプリケーションの連携を実現するJNI(Java Native Interface)などもこのライブラリに含まれる。

    統合ライブラリ
    　→ データベース連携を実現するJDBC(Java Database Connectivity)、分散アプリケーションを開発するためのRMI(Remote Method Invocation)、
    　　CORBA(Common Object Request Broker Architecture)、RMI-IIOP(RMI over IIOP)、ディレクトリサービス連携を実現する
    　　JNDI(Java Naming and Directory Interface)といった機能が含まれる。

    ユーザーインタフェースライブラリ
    　→ GUIを実現するAWTやSwing、画像処理をするためのJava 2D、印刷サービスやテキスト変換などが含まれている。

・Java EEは、各社が提供するソフトウェアが不足なく機能を提供し、且つ互換性があることを保証するための仕様を定めている。
　さまざまなベンダーが製品を提供しているが、Java EEが規定する仕様を満たす製品であれば、同じ機能が提供され、
　且つ互換性を保って使うことができる。

・Java MEは携帯電話やPDAなどの携帯端末、工業用ロボット、テレビのセットトップボックス、プリンタなど、多種多様なハードウェアを制御する
　ソフトウェアを作るためのエディション。このようなハードウェアは限られたメモリサイズ、狭いディスプレイ、容量が少ないバッテリーなど
　多くの制約がある。コンピュータ向けの応用的な使い方やユーザーインタフェースに関するライブラリは、こうした制約のあるハードウェアを
　制御するためには必要ない。このため、Java MEのライブラリは、Java SEの標準ライブラリから最低限必要なAPIを抜き出した形で
　提供されている。

　Java MEでは、こうしたハードウェアなどの環境に柔軟に対応するために、以下の3つの要素から構成されている。

    コンフィギュレーション
    　→ もっとも基本的なライブラリと仮想マシン

    プロファイル
    　→ 特定のデバイス向けのAPIセット

    オプショナルパッケージ
    　→ 特定の技術をサポートするためのAPIセット

　すべてのハードウェアがコンピュータ用のJVMを実行できるリソースを持つわけではない。ハードウェア要件によっては十分なリソースを
　確保できない場合もあり得る。そこでJava MEでは、JVMの他に「KVM」という小型ハードウェア向けの仮想マシンも用意している。
　KVMのKは、数十キロバイト単位の小さなサイズを扱うということに由来している。

第2章　データ宣言と使用

・「整数値を代入できる」という問題にfloatとdoubleがあった場合、この2つは確かに代入はできるが小数点も扱えるため
　「中に必ず整数が代入されている」ことは保証できない。そういった問題では恐らくこれが重要視されているので
　char,int,short,longを選択し、float,doubleは選択しないようにする。

・Javaでは0をfalseとして扱わない。よってboolean x = 0; のような代入はできないので注意。

・アクセス修飾子とstaticキーワードの順番は逆でも問題ない。なので、以下のコードはどちらもOKである。

    public static int x;
    static public int x;

・型変換には、「広くする型変換」と「狭くする型変換」の2種類がある。広くする型変換は、保持できる値の範囲が狭いデータ型から
　広いデータ型への変換。狭くする型変換は、保持できる値が広いデータ型から狭いデータ型への変換。

　狭くする型変換では、データのビット落ちが発生してしまう可能性がある。このようなコードは、意図したとおりに動作しない可能性が
　あると判断され、コンパイルエラーが発生する。このようなコンパイルエラーを発生させないために、キャスト演算子を使って、
　ビット落ちする危険性を認識していることを明示する。このように変換する意思を明示することから、狭くする型変換を
　「明示的な型変換」と呼ぶ。

　なお、広くする型変換ではビット落ちが発生することが無いため、キャスト演算子を使って型変換を明示する必要はない。
　そのため、広くする型変換のことを「暗黙の型変換」と呼ぶ。

　つまり、float f = 3; や double d = 5; などはそれぞれ3を3.0、5を5.0に暗黙の型変換をし、浮動小数点型の変数へ代入している。
　このように広くする型変換は自動的に行われる。

・インスタンスフィールド(クラスのプロパティや配列の要素)を初期化しなかった場合のデフォルト値は以下の通り。

    整数型 = 0
    浮動小数点型 = 0.0
    文字型 = \u0000
    真偽値 = false
    参照型 = null

　ちなみにStringはクラスであり参照型のため、初期値はnullである。

・配列を初期化子{}で記述する初期化リストは、配列変数の宣言と同時でなければいけないため、以下のようなコードはエラーとなる。

    int[] array;
    array = {3, 5, 1};

・配列の要素数を取得するには、配列が持つフィールドである「length」を参照する。
　文字列の長さを取得するには、Stringクラスが持つメソッドである「length()」を使用する。
　混ざりやすいので注意する。

・以下のようなコードがあった場合、実行時エラーとなる。

    public static void main(String[] args) {
        System.out.println(args[0]);
    }

　なぜこれが実行時エラーになるのかと言うと、コマンドライン引数を指定しない場合でも、必ず配列インスタンスは生成され、
　その場合は要素数0の配列インスタンスが生成されるから。つまり、上記のプログラムは配列の範囲外にアクセスしてしまう事になるため、
　実行時エラーとなる。

第3章　演算子と分岐文

・5 / 2 のように、整数値同士の演算結果は小数点以下が切り捨てられる点に注意する。

・演算子の左オペランドの結果により、右オペランドを評価しない演算子のことを「ショートサーキット演算子(短絡演算子)」という
　(&& や || など)。例えば、 論理積(&&)では、左オペランドの結果がfalseの場合は、右オペランドがtrue,falseのいずれでも条件式の結果は
　falseになるため、右オペランドは評価されない。論理和(||)では、左オペランドの結果がtrueの場合は、右オペランドは評価されない。
　つまり、以下のプログラムの実行結果は以下のようになる。

    int a = 0;
    int b = 0;
    if (++a > 0 || ++b > 0) {
        System.out.print("a=" + a + ",");
        System.out.print("b=" + b);
    }

    a=1,b=0

　論理和で左オペランドの結果がtrueなので右オペランドは評価されず、++bも実行されないことになる。
　この点に注意する。

　ちなみに同じ論理積と論理和でも & と | はショートサーキット演算子ではないため、左オペランドの結果によらず右オペランドも評価される。
　そのため、以下のプログラムの実行結果は以下のようになる。

    int x = 1;
    int y = 10;
    if (++x > 0 | ++y > 1) {
        System.out.println(x + " " + y);
    }

    2 11

　論理和のため、左オペランドがtrueの時点で条件式の結果はtrueになるが、右オペランドも評価されていることが分かる。
　同様に、& で行うと左がfalseでも右オペランドが評価される。
　つまり、& と &&、| と || では右オペランドが評価されるどうか、といった違いがあることに注意する。

・switch文の式は、char,byte,short,int,Character,Byte,Short,Integer,String,列挙型のいずれかを戻す式でなくてはならない。
　それ以外の場合はコンパイルエラーが発生する。なぜfloatやdoubleがダメなのかと言うと、switch文の式は == で判定を行うため、
　浮動小数点は誤差丸めのせいで正しい比較ができないケースがあるため。浮動小数点で誤差が発生する理由は、浮動小数は2の乗数で数を表すから。
　たとえば、0.5は2の-1乗、0.75は2の-1乗 + 2の-2乗で表す。そのため、2のn乗の合算値で表せない値には誤差が発生してしまう。

　longがダメな理由としては、確かかどうかわからないが高速化のためらしい。連続値を使用するケースではtableswitch_instructionを用いて
　高速に処理をするが、このテーブルが当時の32bit環境に最適化された構造をしているため4byteに抑えられた、という経緯がある。
　Javaは昔のクラスファイルをそのまま実行できる必要があるため、64bitが当たり前の時代になってもtableswitch_instructionの構造を
　変更できずにlong未対応となってしまった、と記述されている。
　参考サイト　https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q13171670558

・「カプセル化」とは、変更に強いソフトウェアを設計するための「設計原則」の1つ。正しくカプセル化されたモジュールは、
　変更に強く、開発の生産性向上だけでなく、長期間にわたって行われる保守作業の軽減を実現する。

　「設計」とは、開発や運用を効率化し、コスト削減を実現するための作業を指す。その良し悪しは、どれだけコストが削減できたかで
　測ることができる。オブジェクト指向は、ソフトウェアの変更容易性や再利用性を向上させることで、コスト削減効果を追求する設計技法。

　ソフトウェアを設計するにあたって、考えるべきことを要約すると以下の2つに絞られる。

    どのような流れで処理をするのか？
    どのようなデータを扱うのか？

　前者の「処理の流れ」から設計を始めるのが「構造化設計手法」、後者の「扱うデータ」から設計を始めるのが「オブジェクト指向設計手法」
　の特徴である。構造化設計手法と比べてオブジェクト指向設計手法が優れている点は、変更に強い設計ができること。
　ただし、オブジェクト指向を使えば変更に強く「できる」だけであり、必ずしも変更に強くなるという意味ではない。間違った使い方をすれば、
　強くなるどころか、変更のたびに余計な工数がかかってしまう「変更に弱い」設計にもなりかねない。
　そのため、設計者は常に変更に強くなることを心がけて設計しなければならない。

　「変更に強い設計」とは、以下の2つの条件を満たすもの。

    変更発生時にその影響範囲がすぐに特定できること
    変更への対応が工数をかけずにできること

　変更発生時には対象となる部分だけでなく、関係する箇所も変更しなくてはいけない。しかし、その時に次々と変更箇所が広がってしまうような
　設計は変更に強いとは言えない。そのため、変更の影響範囲を明確に切り分けられる設計が求められる。

　変更の影響範囲を特定するには、数多くのモジュールをいかに区別できるかが重要になる。そのためにはモジュールの違いがはっきりとわかる
　設計でなくてはいけない。

　カプセル化は、影響範囲の特定に関わる重要な設計原則である。カプセル化は、「関係するデータ」をまとめ、さらに「そのデータを扱う処理」
　をまとめて、1つのモジュールとして定義することである。適切にカプセル化されたモジュールは、開発者が区別しやすい単位に分割されているため、
　どのモジュールを変更すればよいかを特定しやすくする。

・データ隠蔽の目的はカプセル化の維持。カプセル化を崩す要因は、あるモジュールのデータに他のモジュールからアクセスすること。
　たとえばモジュールAとモジュールBがあった場合に、モジュールAにあるデータを必要とする処理はすべてAになければいけない。
　しかし、モジュールBにモジュールAのデータを必要とする処理があった場合、そのデータに変更が加わった場合の影響について
　モジュールBの影響も調べる必要が生じる。このような事態に陥らないために、データを隠蔽しアクセスを拒否することで
　カプセル化を維持するのである。

・ソフトウェア開発では、ソフトウェアが解決すべきビジネス上の課題のことを「問題領域」と呼ぶ。ソフトウェアが様々な分野で
　活用されるようになるにつれて、問題領域に含まれる要素は増え続け、それらの関係も複雑化していった。そのため、ソフトウェア開発の現場では
　問題領域を単純化する技法を求め、試行錯誤を繰り返してきた。そうして採用されたものが「分割統治」と「抽象化」である。

　「分割統治」は、問題が大きなまま解決を試みるのではなく、問題を小さな単位に分割し、単純化することで個別に解決しながら
　全体の大きな問題を解決していく問題解決技法の1つ。オブジェクト指向は、これにカプセル化で対応する。

　分割統治によって分解され、単純化された問題領域の要素は結合されることで元の問題領域を表現できる。しかし、複雑な問題を単純になるまで
　分解すると、その数は膨大な量となりそれらを結合する部分は累乗的に増えていく。結果として、簡単にするために分解したものを
　1つに戻すために結合すると、余計に複雑になるという事態が発生してしまう。

　この問題を解決するのが「抽象化」である。抽象化は、対象から注目すべき要素を抜き出し、それ以外を無視することによって
　複雑な問題を単純化する方法。単純化すれば全体像をつかみやすくなったり、問題の本質をとらえやすくなったりする効果がある。
　なお、オブジェクト指向では抽象化してオブジェクトを扱うことを「ポリモーフィズム」と呼ぶ。

　抽象化は一般的な思考方法の1つで、たとえばサッカー選手のA,B,Cさんをひとくくりにサッカー選手として扱うのは抽象化である。
　A,B,Cさんという個人の違いは無視し、サッカー選手としての特徴だけに着目するようになる。このように個人の違いを無視することで
　「サッカー選手とはどういう人のことを指すのか？」という本質だけに着目できるようになる。

　抽象化をソフトウェアに置き換えると、共通点があるモジュールをひとまとめにして1つの方で扱い、共通点以外の部分は無視することになる。
　抽象化を使うことで、「分割統治と抽象化のイメージ図.png」にある図のように、複雑に絡み合っていたモジュール間の関係が単純化される。

　抽象化では、共通点を持つオブジェクトをまとめて、それぞれのオブジェクトの違いを無視して1つの型で扱うことで
　モジュールの連携箇所を減らして、ソフトウェアを単純化する。

・Javaのプログラムで、データやインスタンスの「扱い方」を決めているのが変数の「型」である。
　変数の型は、その変数で使うデータの種類を表しており、そのデータをどのように扱うべきかを定義するもの。
　たとえば、3という数値をint型の変数に代入するとint型の値として扱うが、double型の変数に代入すればdouble型の値として扱う。

　また、参照型変数の場合は、データの値ではなく参照(というデータ)が格納されているため、参照の先にあるインスタンスをどのように扱うかを
　変数の型で宣言していることになる。例えば、A a = new B(); といったコードの場合、BのインスタンスをAという型で扱うことになる。

　ここで注意するのが、参照型変数の方は参照の先にあるインスタンスを「どの型で扱うか」を定義するものであるということ。
　「実際に動作するのは型ではなくインスタンスそのもの」であることに注意する。

・「ポリモーフィズム」は、様々な種類のインスタンスを抽象化し、共通の方で扱う。ポリモーフィズムには以下の特徴がある。

    ・どの型で扱っていたとしても、実際に動作するのはインスタンスそのものである
    ・「使う側」のクラスは、「共通化して扱える型」だけを知っていればよく、「使われる側」の具体的な違いを意識することは無い
    ・「使う側」が「使われる側」の変更の影響を受けることは無い
    ・影響を受けるのは、共通化して扱える型が変わった時のみ

・「情報隠蔽」は、抽象化の効果を維持するために必要な設計原則である。

　抽象化によって単純化されたモジュール間の関係が、後々の保守時に崩れ、ソフトウェアの構造が複雑になってしまうと、
　変更コストが大幅に増えてしまう可能性がある。最悪の場合、コストがかかりすぎるために保守不能に陥ることもあり得る。
　このような事態を防ぐためにも、抽象化・単純化された構造が崩れないような設計が求められる。

　単純化された構造が崩れるのは、抽象化によって無視したはずのモジュールが使われてしまうため。たとえば、モジュール群を抽象化し、
　単純化して扱う時、使う側が使われる側の詳細を知っている状況があるとする。「詳細を知っている」というのは、共通の型だけでなく
　具体的にどのクラスのインスタンスが動いているか、各クラスがどのような独自メソッドを持っているかを知っていること。
　このような状況では「便利だから」「楽だから」と言う理由で、無視したはずの独自機能を使おうとする開発者が出てしまう可能性がある。
　その結果、シンプルだったはずの関係が複雑化してしまう。

・情報隠蔽は、公開すべきものと非公開にすべきものを分け、非公開にすべきものを隠蔽するよう設計するという原則。

　Javaでは、公開部分をインタフェースとして定義する。抽象化されたモジュール群はインタフェースを実現するよう実装し、
　ポリモーフィズムによって、実際に動くインスタンスの型を隠蔽する。また、非公開部分への不適切なアクセスを防ぐために
　「パッケージ」や「アクセス修飾子」を使ってアクセスを制御する。

・クラス宣言時に指定できるアクセス修飾子はpublicがデフォルト(パッケージプライベート)しかないが、
　コンストラクタにはそれに加えてprivate,protectedも指定できるため、クラスを非公開にする方法として
　コンストラクタを使ったアクセス制御はより柔軟な制御が可能となる。

・インタフェースには以下のような特徴がある。

    実装を持たないメソッド宣言のリスト
    実装を持たないため、インスタンス化できない
    実装は、インタフェースを実現したクラスが提供する
    メソッドの宣言以外には、定数のみ定義できる

　Javaのプログラムは、コンパイルや実行時に「型」と「実装」に分けて扱われる。インタフェースはこの「型」をあらわしたもの。
　インタフェースを理解するために、まず型と実装が異なる概念であることを覚える。

　Javaのプログラミングでの基本的な単位は、「クラス」である。クラスには、どのように動くべきかという「実装」が記述されている。

　一方、オブジェクト指向設計の基本的な単位は、「型(タイプ)」である。型とは、オブジェクトの「種類」を表したもの。
　オブジェクト指向設計では、どのような種類のオブジェクトがどのような種類のオブジェクトと連携するかを検討することから始める。
　型を使って設計すれば、過度に詳細になりがちな実装を意識しなくてもよいため、ソフトウェアの全体構造を検討できる。
　そのため、オブジェクト指向設計では、全体像(ソフトウェアの構造)を検討してから、詳細な動作(実装)を検討していく。

　このように、オブジェクト指向では型と実装を異なる概念として扱う。実際に動作するもの(実装)と、その扱い方(型)が一致する必要はない。
　そのため、ある実装をそれを持つクラスとは別の方で扱うという、ポリモーフィズムが成り立つのである。

　クラスは、型と実装の両方を持っている。実装を持たず、型だけを定義したものをインタフェースと呼ぶ。「実装を持たない」とは、
　「どのように動作すればよいかと言う具体的な処理を持たない」ということを意味する。そのため、インタフェースはインスタンス化できない。
　実装はインタフェースを実現したクラスが提供する。

　また、型は動作しないため、変わらないものだけを定義できる。変わらないものには、メソッドの宣言と定数がある。
　具体的には、インタフェースにもメソッドの宣言とstaticな定数のみが定義できる。
　インタフェースは、メソッド宣言と定数のリストだと覚えておくのが良い。

・ソフトウェア開発に限らず、何らかの対象を理解するための行動を「分析」と呼ぶ。ソフトウェア開発では、顧客の要求を聞き、
　何を作らなければいけないかを正しく理解するために、要求そのものや背景となる業務の分析は欠かせない。
　古くからある分析のための技法には「分解」と「分類」の2つがある。分解は構造を明らかにし、分類は共通点を体系化する。
　オブジェクト指向によるモデリングでは、この分解と分類と言う技法を取り入れ、ソフトウェアとして表現すべき対象を理解しやすくしている。

　対象となる「ものごと」がどのような要素で成り立っているか「分解」し、ものごとの構成関係を表すのが「has-a関係」である。
　たとえば、自動車がタイヤやエンジン、ハンドルなどで構成されている場合には以下のような関係が成り立つ。

    自動車 has-a タイヤ
    自動車 has-a エンジン
    自動車 has-a ハンドル

　これらの関係は「自動車はタイヤを持っている」や「自動車はタイヤで構成されている」と言い表す。
　このように、ものごとを分解して「全体と部分の関係」で表現するのが「has-a関係」である。

　「持っている」ことをJavaでは、「フィールド」で表現する。たとえば、自動車がエンジンを持っている場合には以下のようなコードで表現する。

    public class Car {
        private Engine engine;
        public void setEngine(Engine engine) {
            this.engine = engine;
        }
    }

　「分類」は、共通点を見つけて体系化することで、全体像を見失うことなく、個別のものごとに分解する分析の技法。
　分解が構造を使った分析方法であるのに対し、分類は意味や役割、本質に着目して分析する方法。
　オブジェクト指向では分類を汎化・特化の関係で表現し、Javaでは継承の関係で表現する。
　なお、インタフェースとそれを実現するクラスとの関係も「is-a関係」にあるといえる。

　たとえば、乗り物を継承した自動車があった時、自動車は乗り物の一種である。このような関係があったとき、「自動車 is-a 乗り物」
　というようにis-aを使って2つの関係を表現する。

　さらに自動車を継承したガソリン車と電気自動車を定義すると、以下のような関係が成り立つ。

    ガソリン車 is-a 自動車
    電気自動車 is-a 自動車

　「自動車 is-a 乗り物」という関係に加えると、ガソリン車は自動車の一種で、自動車は乗り物の一種である関係が成り立つ。
　そのため、「ガソリン車 is-a 乗り物」という関係も成り立つ。同様に、電気自動車も乗り物の一種であることがわかる。

　is-a関係は「サブクラス is-a スーパークラス」または「実装クラス is-a インタフェース」という関係で表現する。

・「オーバーロード」は「多重定義」と呼ばれ、1つのクラス内に引数の方や数、並び順が異なる同じ名前のメソッドを複数定義すること。
　クラス名や変数名などの識別子は重複が許されていないが、メソッドの場合はメソッド名と引数のセットで識別されるため、
　引数さえ異なれば同名のメソッドが定義可能である。このメソッド名と引数のセットのことを「シグニチャ」と呼ぶ。
　シグニチャには以下の4つが含まれる。

    メソッド名
    引数の数
    引数の型
    引数の順番

・this()は、コンストラクタから、オーバーロードした別のコンストラクタの呼び出しをする際に利用する。

・問題のコードに記述してあるのがクラス名.フィールド名なのか、インスタンス名.フィールド名なのか冷静に見る。

・インスタンス → クラスは参照OK、クラス → インスタンスは参照NG　であることをしっかり覚えておく。
　そして問題がこの2つの内どうなっているのかもしっかり確認する。

・Javaでは、サブクラスのインスタンスを作るときに、スーパークラスのインスタンスも同時に作られる。
　つまり、スーパークラスのインスタンスとサブクラスに定義した差分のインスタンスの2つで1つのインスタンスを表す。
　そのため、コンストラクタの1行目には暗黙にスーパークラスのインスタンスの準備をするためのコンストラクタが呼ばれるのである。

・サブクラスのコンストラクタからスーパークラスのコンストラクタを呼び出しながら各インスタンスを準備する仕組みを
　「コンストラクタチェーン」と呼ぶ。

・オーバーライドが成り立つ条件は以下の3点である。

    メソッドの「シグニチャ」がスーパークラスのものと同じであること
    「戻り値の型」がスーパークラスのメソッドと同じか、サブクラスであること
    メソッドの「アクセス制御」がスーパークラスと同じか、それよりも緩いこと

・オーバーライドしているメソッドのthrows節に関しては、以下のようなルールがある。

    オーバーライドしているメソッドは「throws節」を持たなくてもよい
    もし持つのであれば、オーバーライドしているメソッドに列挙されている例外の型が、スーパークラスのメソッドに列挙されている例外と
    　「同じ型かそのサブタイプ」であること

・インタフェースもextendsキーワードを使用して別のインタフェースを継承することができる。

・インタフェースや抽象クラスに定義した抽象メソッドは、それぞれを実現あるいは継承した具象クラスが実装しなければいけない。
　ただし、このルールに従わなければならないのは「具象クラス」のみ。インタフェースがインタフェースを継承したり、
　抽象クラスがインタフェースや抽象クラスを継承したりする場合には、このルールは適用されない。
　つまり、インタフェースや抽象クラスでメソッドを実装する必要はない。

・ダウンキャストは自動的には行われない。スーパークラスにはサブクラスとしての差分の定義が無いため。
　たとえサブクラスのインスタンスをアップキャストしていて、それを基のサブクラス型に戻したとしてもコンパイルエラーになる。
　これは、コンパイラは「元の型が何であったか」ではなく、「今の型に互換性があるかどうか」だけを確認するから。
　たとえば、以下のようにB型の変数をA型にアップキャストしたあと、元のB型の変数にダウンキャストするとコンパイルエラーが発生する。

    B b = new B();
    A a = b;    // アップキャスト
    b = a;      // ダウンキャスト(コンパイルエラー発生)

　実際に動作しているのはBのインスタンスであり、一見すると問題が無いように見える。しかし、上記のようにコンパイラは
　「今の型に互換性があるかどうか」を見るため、A a = b; の時点で「A型として扱っている」ことになり、それをB型に入れようとすると
　A型にはB型の差分の定義が無いため、コンパイルエラーが起きるのである。

　そこで、このような場合には、プログラマーが「明示的にキャスト式」を記述することで、コンパイラに「互換性の問題は無い」ことを保証する。

    B b = new B();
    A a = b;    // アップキャスト
    b = (B) a;  // ダウンキャスト(実行可能)

・「パッケージ宣言はソースファイルの"1行"目に記述する」は間違っており、「パッケージ宣言はソースファイルの"先頭"行で宣言する」
　じゃないとダメなので注意する。恐らくコメント行が上にあってもパッケージ文は先頭にさえあれば良いので
　1行目ではなくてもいいよということなのだろうか。

・異なるパッケージに所属するクラスを利用する場合、必ずインポート宣言をしなければならないわけではないので注意する。
　完全修飾ドメイン名を記述すれば、パッケージをインポートしなくてもよい。そもそもimport文は、ソースコード中に何度も
　完全修飾ドメイン名が出てくる時などにソースコードを見やすくするために用いるものであり、必須と言うわけではないので注意する。

・各データ型に入れられる値は以下の通り。

    byte = -128 - 127
    short = -32768 - 32767
    int = -2147483648 - 2147483647(-21億～21億)
    long = -9223372036854775808 - 9223372036854775807(-900京～900京)
    float = -32768 - 32767(-21億～21億)
    double = -9223372036854775808 - 9223372036854775807(-900京～900京)
    char = u\0000(0) - u\FFFF(65535)

・インスタンスメソッドをstaticメソッドでオーバーライドすると、コンパイルエラーになるので注意する。

・クラス宣言の修飾子にはpublic,デフォルト(パッケージプライベート),final が使用できる。
　finalを使って宣言したクラスは、サブクラスを作ることができなくなる。たとえば、java.lang.Stringクラスはfinalクラスである。

・Webベースのシステムを開発するにはJava EEを使うのが一般的。Java SEでも開発できないことはないが、非効率的で適していない。
　ただ、「将来的にWebベース」のような記述があった場合はJava SEが答えであることもある。

・どうやらクラスに修飾子として「private」も含んでよいらしい。(インナークラスはprivateで修飾できるため)

・for文内にi++;の処理を記述してある問題もあるため注意する。これが記述してある大体の場合は、反復式のi++は不要となる。

・以下のようなコードに注意する。

    int i = 2;
    System.out.println((i += 2) + (i++));

　まず左の(i += 2)が評価され、i が4となる。右の(i++)が評価される時点で i は4なので最終的には 4 + 4 となる。
　右のiを2のままで考えてしまいミスったので注意する。式の中で代入が行われた場合、その式が評価された後は値が変わることに注意する。

・問題文を見ずに間違えているもったいない問題がいくつかあるので、注意して問題文を見る。
　「正しい選択肢」なのか「誤った選択肢」なのか、「1つ」なのか「2つ」なのかそれ以上なのか、ちゃんと問題文を見る。
　本番で何より大切なのは、「問題文」と「コード」をしっかり見ること。

・

=================================================================================================================================

受験申しこみ方法、注意点など

・参考サイト
https://qiita.com/Channel/items/31e50323d2b7ee78f7cc
https://nokonokonetwork.com/certificate/oracle/how-to-apply-for-oracle-master-and-java-certification-exam.html

・

=================================================================================================================================

Web模擬試験　間違えた設問
1回目
    6,10,15,33,41,51,59,60

2回目

第8章　間違えた設問
1回目
    いっぱい

2回目
    6,57