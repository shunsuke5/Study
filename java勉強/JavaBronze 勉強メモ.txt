Java Bronze 勉強メモ

https://www.oracle.com/jp/education/certification/ocjp-silver-se8-3494542-ja.html

問題7

・インクリメント演算子と三項演算子に関する問題。int num = 5; としている場合、
　int count = num++; のように後置インクリメントで代入を行っている場合は、先にnumをcountに代入してからインクリメントを行う。
　そのため、この式が終わった時点ではcount = 5, num = 6、となっている。
　int result = ++count; のように前置インクリメントで代入を行っている場合は、先にcountの値をインクリメントしてからresultに代入する。
　そのため、この時点でnum = 6, count = 6, result = 6 のようになる。

　次に、String str = num == count ? num < result ? "ARG" : "BOL" : "CHL"; と三項演算子を用いているが、
　三項演算子はtrueのときに : の左、falseのときに : の右が評価される。

　実際に String str = a > b ? c > d ? "abc" : "def" : "ghi";　を試してみると、
    true,true → abc
    true,false → def
    false,true → ghi
    false,false → ghi
　となった。どういうこと？

　やっとわかった。a > b がtrueの時は「c > d ? "abc" : "def"」が評価されて、falseの時は「"ghi"」が評価される。
　だからa > b がfalseの時は必ず ghi になるのもこれで納得がいく。
　ずっとa > b がtrueになった時にだけ c > d が評価される、みたいな考えをしてしまっていた。コロン3つあることにも面食らった。

・問題8のように、二次元配列を拡張for文で for (char[] ca : chArr) {...} とした場合、ca にはchArrが保有する配列が順番に渡されていく。

・for文などでbreak; の後にプログラムを記述すると到達不能コードとなりエラーが出るので注意する。

・インスタンスメソッドからクラス変数にアクセスすることはできるが、
　クラスメソッド(staticメソッド)からインスタンス変数にアクセスすることはできないので注意する。

・同クラス内のコンストラクタを呼び出すにはthis(); またはthis(引数リスト); と記述するが、「必ずコンストラクタ内の先頭で1回のみ」とする。
　コンストラクタ呼び出し同士がお互いを呼び出していて、循環してしまうような呼び出し方もできない。

・アクセス修飾子は、public > protected > パッケージ・プライベート(アクセス修飾子なし) > private の順で厳しくなることを覚えておく。
　オーバーライドする際はより緩い修飾子にすることは可能だが、厳しい修飾子に変更してオーバーライドすることはできない。

・インタフェースのデフォルト修飾子として、インタフェースではメソッド(default,staticメソッド以外)は暗黙的にはpublic abstract が付加され
　変数(定数)には暗黙的にpublic static final が付加される。そのため、インタフェースでvoid abc(); となっているメソッドを
　それを実装したクラスでvoid abc() {} とすると、クラスは修飾子を省略するとパッケージプライベートになるため、
　より厳しい修飾子でオーバーライドすることになってしまい、コンパイルエラーとなる。

・コンストラクタ場用意されていないクラスには、デフォルトコンストラクタが用意されるが、明示的にコンストラクタが用意されたクラスには
　デフォルトコンストラクタは用意されない。

　コンストラクタ内で、別コンストラクタを呼び出していない場合には、暗黙的にsuper();が追加される

　上記2つのルールから、親クラスに存在しないsuper();を呼び出してエラーになっているような問題に注意する。
　あとはコンストラクタを修正するような問題でも、どっちが正解なんだと迷った場合は、これを意識しなければならない。

・Exceptionクラスのサブクラスの内、RuntimeExceptionクラスのサブクラスは非チェック例外となる。
　Exceptionクラスの全てのサブクラスは復旧可能である。
　catchブロック内のパラメータは全てThrowable型として扱うことができる。

・for文の初期化式; 条件式; 継続式; はどれも省略可能。
　そして、例えばfor(int i = 0; i++ < 5;) {...} のようにi++が条件式にある場合は、条件を判定した後にインクリメントされる。
　つまりfor文内の{...}の時にはインクリメントされていることに注意する。

・配列の要素外にアクセスするのはコンパイルエラーではなく実行時エラーとなるので注意する。
　コンパイルエラーは文法がおかしいときに起こり、実行時エラーは文法的には合っているが実際にプログラムとしておかしい時に起こる。

・

=================================================================================================================================