Apache勉強メモ

・The default folder for your your webpages is DocumentRoot "c:/Apache24/htdocs"
　と書いてあるため、公開するwebページはここに置く？

・コマンドプロンプトで「c:\Apache24\bin」に移動し、httpd.exe コマンドを打つとサーバーが開始する。
　http://localhost をブラウザで検索し、It works!のように表示されれば成功。
　ctrl + c でサーバーは閉じることができる。

・windowsにApacheサービスをインストールする時は「httpd.exe -k install」コマンドを使用。

・「services.msc」コマンドでApacheサービスを起動/停止できる。

・「httpd -h」コマンドでヘルプを見ることができる。

バインド

　Apacheが使用するアドレスとポートの設定をする。

・概要

　Apacheは起動時に、ローカルマシンのあるポート及びアドレスに対して接続し、リクエストが来るのを待つ。
　デフォルトではマシンの全てのアドレスに対してListenする。(Listen 80)
　特定のポート、特定のアドレス、またはそれらの組み合わせでListenするように指定したい場合もある。
　異なるIPアドレス、ホスト名、ポートに対してApacheがどのように応答するかを制御する「バーチャルホスト機能」
　と組み合わせてよく使用される。

　「Listenディレクティブ」で特定のポートやアドレス、ポートの組から入ってくるリクエストのみを受け付けるようにできる。
　もしポート番号だけがListenディレクティブで指定された場合は(例:Listen 80)、
　全てのインターフェースの与えられたポート番号に対してListenする。
　Listenディレクティブを複数使ってListenするアドレスとポートをいくつも指定できる。
　サーバは指定されたアドレスやポートからのリクエスト全てに対して応答する。
　例えば、Listen 80 と Listen8000 とした場合、全てのインターフェースのポート80と8000において接続を受け付ける。
　Listen 192.0.2.1:80 と Listen 192.0.2.5:8000 とした場合、
　192.0.2.1インターフェースでは80番ポートで接続を受け付け、192.0.2.5インターフェースでは8000番ポートで接続を受け付ける。
　IPv6アドレスは Listen [2001:db8::a00:20ff:fea7:ccea]:80 のように角かっこで囲まなければいけない。

　Listenディレクティブでバーチャルホストが実装されるわけではない。Listenは単にメインサーバーにどのアドレスとポートを
　Listenすべきかを教えるだけ。<VirtualHost>ディレクティブが使われない場合は、受け入れたリクエスト全てに対して全く同じ挙動をする。
　VirtualHostを実装するには、まず初めに使用したいアドレスとポートに対してサーバがListenしていなければならない。
　そして、その指定したアドレスとポートでのバーチャルホストの挙動を設定するために<VirtualHost>セクションを作成する。
　もしVirtualHostがListenしていないアドレスとポートに対して設定されてしまうと、それにはアクセスできないと言う点に注意する。

設定ファイル

　この文書では、Apache HTTPサーバを設定するのに使用するファイルについて記述している。

・設定ファイルの構文

　Apacheの設定ファイルは1行に1つのディレクティブからなる。バックスラッシュはディレクティブが次の行に継続していることを
　示すために行の最後の文字として使われている可能性がある。#で始まる行はコメント行。
　設定ディレクティブと同一行の末尾にコメントが含まれていてはいけない。
　ディレクティブの前の空行と空白は無視されるため、わかりやすくするためにインデントをしても問題ない。

　設定ファイルの構文エラーは、apachectl configtest かコマンドライン -t を使って調べられる。

・モジュール

　Apacheはモジュール化されたサーバである。コアサーバには最も基本的な機能だけが含まれている。
　拡張機能はApacheにロードされるモジュールとして利用可能。デフォルトでは、コンパイル時にモジュールのBaseセット
　(基本セット)がサーバに含まれる。サーバが動的ロードモジュールを使うようにコンパイルされている場合は、モジュールを別にコンパイルして
　いつでもLoadModuleディレクティブを使って追加できる。そうでない場合は、モジュールん追加や削除をするためには
　Apacheを再コンパイルする必要がある。設定ディレクティブは<IfModule>ブロックに入れることで特定のモジュールが存在するときだけ
　設定ファイルに含まれるようにすることができる。

　コマンドラインオプション-lを使って現時点でどのモジュールがサーバにコンパイルされているかを知ることができる。

・ディレクティブの適用範囲

　メイン設定ファイルにあるディレクティブはサーバ全体に適用される。サーバの一部分の設定だけを
　変更したい場合は、<Directory>,<DirectoryMatch>,<Files>,<FilesMatch>,<Location> 中にある
　ディレクティブの適用範囲を特定のファイルシステムの位置やURLに限定する。細かい設定を可能にするため、
　セクションを入れ子にすることもできる。

　Apacheは同時に多くの違うwebサイトを扱う能力がある。これは「バーチャルホスト」と呼ばれている。
　特定のウェブサイトにのみ適用されるようにするために、ディレクティブは<VirtualHost>セクションの中に置くことでも
　適用範囲を変えることができる。

　ほとんどのディレクティブはどのセクションにでも書けるが、中にはコンテキストによっては意味をなさないものもある。
　例えば、プロセスの作成を制御しているディレクティブはメインサーバのコンテキストにのみ書くことができる。
　どのディレクティブをどのセクションに書くことができるかを知るためには、ディレクティブの「コンテキスト」を調べる。

　上記のように、設定ファイル中のディレクティブはサーバ全体に適用されたり、特定のディレクトリやファイル、ホスト、
　URLにのみ適用されるように制限したりすることができる。

セクションの設定

　設定ファイル中のディレクティブはサーバ全体に適用されたり、特定のディレクトリやファイル、ホスト、URLにのみ
　適用されるように制限したりすることができる。この文書は設定用のセクションのコンテナや.htaccessファイルを使って
　他の設定ディレクティブのスコープを変更する方法を説明する。

・設定用セクションコンテナの種類

　コンテナには2つの基本となる種類がある。ほとんどのコンテナは各リクエストに対して評価される。
　その場合、コンテナ中のディレクティブはコンテナにマッチするリクエストにのみ適用される。
　一方、<IfDefine>,<IfModule>,<IfVersion>コンテナはサーバの起動時と再起動時にのみ評価される。
　起動時に条件が真であれば、コンテナ中のディレクティブは全てのリクエストに適用される。
　条件が偽であれば、コンテナ中のディレクティブは無視される。

　<IfDefine>ディレクティブはhttpdコマンドラインで適切なパラメータが定義されたときにのみ、適用されるディレクティブを囲う。
　例えば以下の設定では、サーバがhttpd -DClosedForNow を使って起動されたときだけ全てのリクエストを別のサイトにリダイレクトする。

　　<IfDefine ClosedForNow>
    Redirect / http://otherserver.example.com/
    </IfDefine>

　<IfModule>は非常に似ているが、代わりにサーバ上でモジュールが使用可能な場合にのみ、適用可能なディレクティブを囲う。
　モジュールはサーバに静的に組み込まれているか、動的に組み込むようになっていて、設定ファイル中でLoadModuleの行が
　前の部分に書かれている必要がある。
　以下の例では mod_mime_magic があるときにのみMimeMagicFilesディレクティブが適用される。

　　<IfModule mod_mime_magic.c>
    MimeMagicFile conf/magic
    </IfModule>

　<IfVersion>ディレクティブは<IfDefine>や<IfModule>とよく似ているが、稼働中のサーバのバージョンが特定のバージョン時にのみ
　適用される。様々なバージョンのhttpdを様々な設定で動作させることになる場合で、テストスイートや巨大なネットワークでの用途を
　想定して、このモジュールは設計されている。例としては以下の通り。

　　<IfVersion >= 2.1>
        # this happens only in versions greater or
        # equal 2.1.0.
    </IfVersion>

　<IfDefine>,<IfModule>,<IfVersion>ディレクティブは ! をつけることで否定の条件を適用することができる。
　また、これらのセクションはより複雑な制限を課すために入れ子にすることができる。

・ファイルシステムとweb空間

　最もよく使われる設定のセクションコンテナは、ファイルシステムやweb空間の特定の場所の設定を変更するものである。
　まず、この2つの違いを理解することが大切。ファイルシステムはOSから見たディスクの内容。例えば、デフォルトのインストールでは
　ApacheはUnixファイルシステムでは/usr/local/apache2に、Windowsファイルシステムではc:/ProgramFiles/Apache Group/Apache2
　に存在する。(ApacheではWindowsでもパスセパレータとして/を使うことに気を付ける)
　対して、web空間はあなたのサイトをwebサーバから配信されるものとして持たもので、クライアントに見えるものである。
　デフォルトのUnix上のApacheのインストールではweb空間の/dir/というパスはファイルシステムの
　/usr/local/apache2/htdocs/dir/というパスに対応する。webページはデータベースや他の場所から動的に生成することもできるので、
　web空間はファイルシステムに直接マップする必要はない。

　ファイルシステムコンテナ

　<Directory>ディレクティブと<Files>ディレクティブ、それらの正規表現版はディレクティブをファイルシステムの
　一部分に対して適用する。<Directory>セクションの中のディレクティブは指定されたディレクトリとそのすべてのサブディレクトリに適用される。
　.htaccessファイルを使うことでも同じ効果を得ることができる(.htaccessファイルは極力使用しないことが推奨されている。)
　例えば、以下の設定では/var/web/dir1 とすべてのサブディレクトリに対してディレクトリインデックスを行う。

　　<Directory /var/web/dir1>
    Options +Indexes
    </Directory>

　<Files>セクションの中にあるディレクティブはどのディレクトリにあるかに関わらず、指定された名前の全てのファイルに適用される。
　例えば、以下の設定ディレクティブが設定ファイルの主セクションに書かれたときには、全ての場所のprivate.htmlという名前の
　ファイルへのアクセスを拒否する。

　　<Files private.html>
    Order allow,deny
    Deny from all
    </Files>

　ファイルシステムの特定の場所にあるファイルを指定するために、<Files>セクションと<Directory>セクションを組み合わせることができる。
　例えば以下の設定では、/var/web/dir1 ディレクトリの下にあるすべてのprivate.htmlへのアクセスを拒否する。

　　<Directory /var/web/dir1>
    <Files private.html>
    Order allow,deny
    Deny from all
    </Files>
    </Directory>

　web空間コンテナ

　一方、<Location>ディレクティブとその正規表現版は、web空間上の内容に対して設定を変更する。
　例えば、以下の設定では/privateで始まるURLパスへのアクセスを制限する。

　　<Location /private>
    Order Allow,Deny
    Deny from all
    </Location>

　<Location>ディレクティブはファイルシステムと関係ある必要が全くない。
　例えば以下の例では、どのようにして特定のURLをmod_statusで提供されているApache内部ハンドラにマップするかを示している。
　ファイルシステムにserver-statusというファイルが存在する必要はない。

　　<Location /server-status>
    SetHandler server-status
    </Location>

　ワイルドカードと正規表現

　<Directory>,<Files>,<Location>ディレクティブでは、C標準ライブラリのfnmatchのように
　shellスタイルのワイルドカードキャラクタが使用できる。*は任意の文字列にマッチし、?は任意の1文字にマッチし、
　[seq]はseqの任意の文字にマッチする。/はどのワイルドカードでもマッチされない。明示的に指定する必要がある。
　これより柔軟なマッチングが必要な場合は、これらのコンテナに正規表現(regex)版である
　<DirectoryMatch>,<FilesMatch>,<LocationMatch>があり、regexセクションを使用することで、ディレクティブの適用が
　どのように変化するかを把握することが重要。
　全ユーザディレクトリの設定を変更する、非regexワイルドカードセクションは以下の通り。

　　<Directory /home/*/public_html>
    Options Indexes
    </Directory>

　以下のようにregexセクションを使用することで、画像ファイルの多くのタイプに対するアクセスを一度に拒否できる。

　　<FilesMatch \.(?i:gif|jpe?g|png)$>
    Order allow,deny
    Deny from all
    </FilesMatch>

　いつ何を使うか

　ファイルシステムコンテナとweb空間コンテナを使い分けるのは、実際には非常に簡単。
　ファイルシステムに依存するオブジェクトにディレクティブを適応する場合は、必ず<Directory>か<Files>を使用する。
　ファイルシステムに依存しないオブジェクト(データベースから生成されるwebページなど)に
　ディレクティブを適用する際には<Location>を使用する。

　ファイルシステム上のオブジェクトへのアクセスを制限するために、<Location>を決して使用しないように注意する。
　同一のファイルシステム位置にマップしている、web空間位置(URL)が多数あり、
　設定した制限を迂回されてしまうかもしれないから。例えば以下の設定を考えてみる。

　　<Location /dir/>
    Order allow,deny
    Deny from all
    </Location>

　http://yoursite.example.com/dir/へのリクエストではうまく動作する。
　しかし大文字小文字を区別しないファイルシステムを使っていたらどうなるだろうか？
　http://yoursite.example.com/DIR/へのリクエストで簡単にアクセス制限を迂回されてしまう。
　これに対して<Directory>ディレクティブを使用すると、どのように呼び出されたかに関わらずその場所から提供される
　内容に適用される。

　※例外としてファイルシステムのリンクがある。シンボリックリンクを使って、同一のディレクトリを複数のファイルシステムに
　設置できる。<Direcory>ディレクティブはパス名をリセットすることなくシンボリックリンクを辿るため、
　高度なセキュリティが要求される場合は、適切にOptionsディレクティブを使用してシンボリックリンクを無効にするべき。

・バーチャルホスト

　<VirtualHost>コンテナは特定のホストに適用するディレクティブを格納する。
　一台のマシンで複数のホストを異なる設定で提供したい時に有用。

・プロクシ

　<Proxy>と<ProxyMatch>コンテナは、特定のURLにマッチするmod_proxyプロクシサーバを経由して
　アクセスしたサイトに対してのみ適用される設定ディレクティブを格納する。
　例えば以下の設定は、cnn.comウェブサイトにアクセスするために用いられるプロクシサーバを制限する。

　　<Proxy http://cnn.com/*>
    Order allow,deny
    Deny from all
    </Proxy>

　プロキシとは、「代理」という意味で、インターネットを接続する際に、ネットワークの内部から
　外部へのアクセスを代理で行うシステムのこと。プロキシサーバとも呼ばれ、企業がサイバー攻撃などに対抗し、
　自社の情報システムを安全に管理する手段として利用されている。プロキシが中継することで、
　企業の端末が直接外部と接触しないため、セキュリティを強化できる。

・どのディレクティブが使えるの？

　どのタイプの設定セクションでどのディレクティブが使用できるかは、ディレクティブのcontextを確認する。
　<Directory>で使用可能なものは全て、同様に<DirectoryMatch>,<Files>,<FilesMatch>,<Location>,<LocationMatch>,
　<Proxy>,<ProxyMatch>セクションで使用可能。しかし以下のようにいくつか例外も存在する。

　　AllowOverrideディレクティブは<Directory>セクションでのみ使用可能。
　　FollowSymLinks と SymLinksIfOwnerMatch の Options は、<Directory>セクションか.htaccessファイルでのみ使用可能。
　　Optionsディレクティブは、<Files>と<FilesMatch>セクションでは使用できない。

・セクションのマージ方法

　マージの順番は以下のようになっている。

　　1.<Directory>(正規表現なし)と.htaccessを同時に(.htaccessが許可されていれば、それが<Directory>を上書きする)
　　2.<DirectoryMatch>(と <Directory ~>)
　　3.<Files>と<FilesMatch>を同時に
　　4.<Location>と<LocationMatch>を同時に

　<Directory>以外は、それぞれのグループは設定ファイルに現れた順番に処理される。
　<Directory>(上のグループ1)はディレクトリが短いものから長いものへと処理される。
　例えば、<Directory /var/web/dir1>は<Directory /var/web/dir/subdir>の前に処理される。
　複数の<Directory>セクションが同じディレクトリに適用される場合は、設定ファイル中の順番に従って処理される。
　Includeによって挿入された設定は挿入しているファイルのIncludeディレクティブの位置にあったかのように扱われる。

　<VirtualHost>セクション中のセクションはバーチャルホストの定義の外側の対応するセクションの後に適用される。
　これによりバーチャルホストがメインのサーバ設定を上書きできるようになる。

　mod_proxyでリクエストが処理される場合は、処理順番の内、<Directory>コンテナの部分が<Proxy>コンテナにとってかわられる。

　後のセクションのディレクティブが前のセクションのものを上書きする。

　[技術メモ] 実際には、名前を変換する段階(URLをファイル名にマップするためにAliasやDocumentRootが使用されるところ)
　の直前に<Location>/<LocationMatch>が行われる。これらを適用した結果は変換が終わった後に完全に捨てられる。

　以下はマージの順番を示すための恣意的な例になっている。リクエスト全てに適用されるとして、本例のディレクティブは
　A -> B -> C -> D -> E の順番に適用される。

　　<Location />
    E
    </Location>

    <Files f.html>
    D
    </Files>

    <VirtualHost *>
    <Directory /a/b>
    B
    </Directory>
    </VirtualHost>

    <DirectoryMatch "^.*b$>
    C
    <DirectoryMatch>

    <Directory /a/b>
    A
    </Directory>

　もっと具体的な以下の例を考えてみる。<Directory>セクションに設置されたアクセス制限に関わらず、
　<Location>セクションが最後に評価されて、サーバへのアクセスは制限されない。
　このような結果から分かるように、マージの順番は重要なため、注意して使用する。

　　<Location />
    Order deny,allow
    Allow from all
    </Location>

    # Woops! This <Directory> section will have no effect
    <Directory />
    Order allow,deny
    Allow from all
    Deny from badguy.example.com
    </Directory>

・Caching Guide

・Three-state RFC2616bHTTP caching

　HTTPキャッシュにはFresh,Stale,Non Existentの3つの状態がある。

・ApacheはHTTP/1.1の規格に記述されているコンテントネゴシエーションをサポートしている。
　ブラウザにより提供されたメディアタイプ、言語、文字セット、エンコーディングの優先傾向に基づいて、
　最適なリソースの表現を選択できる。また、不完全なネゴシエーション情報を送ってくるブラウザからの
　リクエストをもっと賢く取り扱えるよう、いくつか機能も実装してある。

　コンテントネゴシエーションはmod_negotiationモジュールによって提供されていて、
　デフォルトで組み込まれている。

コンテントネゴシエーション

　ApacheはHTTP/1.1の規格に記述されているコンテントネゴシエーションをサポートしている。
　ブラウザにより提供されたメディアタイプ、言語、文字セット、エンコーディングの優先傾向に基づいて、
　最適なリソースの表現を選択できる。また、不完全なネゴシエーション情報を送ってくるブラウザからのリクエストを
　もっと賢く取り扱えるよう、いくつか機能も実装してある。

　コンテントネゴシエーションはmod_negtiationモジュールによって提供されていて、デフォルトで組み込まれている。

・コンテントネゴシエーションについて

　リソースは、いくつか異なった表現で利用できる場合がある。例えば、異なる言語や異なるメディアタイプ、
　またはそれらの組み合わせで利用できるかもしれない。もっとも適した選択をする方法の1つには、インデックスページをユーザに見せて
　ユーザに選んでもらう方法がある。しかし、サーバが自動的に選ぶことができる場合が多くある。これはブラウザがリクエストごとに、
　どの表現を嗜好するかと言う情報を送ることで動作している。例えばブラウザは、可能ならフランス語で情報を見たい、
　不可能ならその代わりに英語でもよいと、自分の嗜好を知らせることができる。ブラウザはリクエストのヘッダで
　自分の優先傾向を知らせる。フランス語のみの表現を要求する場合は、ブラウザは以下を送る。

　　Accept-Language: fr

　この優先傾向は、選択可能な表現が存在して、言語によって様々な表現がある場合にのみ適用されることに注意する。

　もっと複雑なリクエストの例を挙げましょう。このブラウザはフランス語と英語を受け付けるが、フランス語を好む、そして様々な
　メディアタイプを受け付けるが、プレインテキストや他のタイプよりはHTMLを好む、他のメディアタイプよりはGIFやJPEGを好む、
　しかし最終手段として他のメディアタイプも受け付ける、と設定されている。

　　Accept-Language: gr; q=1.0, en; q=0.5
    Accept: text/html; q=1.0, text/*; q=0.8, image/gif; q=0.6, image/jpeg;
    q=0.6, image/* q=0.5, */*; q=0.1

　ApacheはHTTP/1.1規格で定義されている'server driven'コンテントネゴシエーションをサポートしている。
　Accept,Accept-Language,Accept-Charset,Accept-Encodingリクエストヘッダを完全にサポートしている。
　Apacheは'transparent'コンテントネゴシエーションもサポートしているが、これはRFC2295とRFC2296で定義されている
　試験的なネゴシエーションプロトコル。これらのRFCで定義されている'feature negotiation'はサポートしていない。

　「リソース」とはURIで特定される概念上のもののこと(RFC2396)。ApacheのようなHTTPサーバは、その名前空間の中でのリソースの表現への
　アクセスを提供する。それぞれの表現は定義されたメディアタイプ、文字セット、エンコーディングなどの付属したバイト列の形式である。
　それぞれのリソースはある時点で0個、1個、それ以上の表現と関連付けられる可能性がある。複数の表現が利用できる場合は、
　リソースは"ネゴシエーション可能"であるとされ、個々の表現はvariantと呼ばれる。ネゴシエーション可能なリソースのvariantが異なる、
　その状態を指して、ネゴシエーションの「次元」と呼ぶ。

・Apacheにおけるネゴシエーション

　リソースをネゴシエーションするためには、サーバはvariantそれぞれについての情報を知っておく必要がある。
　これには以下の2つの方法のどちらかで行われる。

　　1．タイプマップ(すなわち*.varファイル)を使う方法。これはvariantを明示的に挙げているファイルを指定する。
　　2．Multiviewsを使って、サーバが暗黙の裡にファイル名にパターン称号を行ってその結果から選択する方法。

　type-mapファイルを使う

　タイプマップはtype-mapハンドラ(もしくは、古いApacheの設定と下位互換であるMIMEタイプ application/x-type-map)
　に関連付けられたドキュメントである。この機能を使うためには、あるファイルの拡張子をtype-mapとして定義するようなハンドラを、
　設定ファイル中に置く必要があることに注意する。これは AddHandler type-map .var をサーバ設定ファイル中に書くことが一番良い方法。

　タイプマップファイルは記述するリソースと同じ名前を持っていて、利用可能なvariantそれぞれのエントリを持っている必要がある。
　そして、このエントリは連続したHTTPのヘッダ行で構成される。異なるvariantのためのエントリは空行で区切られている。
　エントリ中に空行が複数あってはいけない。習慣的には、マップファイルは全体を結合したもののエントリから始まる(しかしこれは必須ではなく、
　あったとしても無視されるもの)。以下に例を示す。このファイルはリソースfooを記述しているので、foo.var と言う名前になる。

　　URI: foo

    URI: foo.en.html
    Content-type: text/html
    Content-language: en

    URI: foo.fr.de.html
    Content-type: text/html;charset=iso-8859-2
    Content-language: fr, de

　たとえMultiViewsを使用するようになっていたとしても、ファイル名の拡張子よりタイプマップの方が優先権を持つということにも注意する。
　variantの品質が違う時は、以下のように(JPEG,GIF,ASCIIアート)メディアタイプの"qs"パラメータで指定される。

　　URI: foo

    URI: foo.jpeg
    Content-type: image/jpeg; qs=0.8

    URI: foo.gif
    Content-type: image/gif; qs=0.5

    URI: foo.txt
    Content-type: text/plain; qs=0.01

　qs値の範囲は 0.000 から 1.000 である。qs値が0.000のvariantは決して選択されないことに注意する。
　qs値が指定されていないvariantはqs値1.0を与えられる。qsパラメータはクライアントの能力に関係なく、他のvariantと比較したときの
　variantの相対的な「品質」を示す。例えば、写真を表現しようとしている時はJPEGファイルの方が普通はASCIIファイルよりも高い品質になる。
　しかし、リソースがもともとASCIIアートで表現されている時は、ASCIIファイルの方がJPEGファイルよりも高い品質になる。
　このように、qsは表現されるリソースの性質によってvariantごとに特有の値を取る。

　認識されるヘッダの一覧は mod_negotiation ドキュメントにある。

　Multiviews

　MultiViewsはディレクトリごとのオプションで、httpd.confファイルの<Directory>,<Location>,<Files>セクション中や、
　(AllowOverrideが適切な値に設定されていると).htaccessファイルでOptionsディレクティブによって設定することができる。
　Options AllはMultiViewsをセットしないことに注意する。明示的にその名前を書く必要がある。

　MultiViwesの効果は以下のようになる:サーバが/some/dir/foo へのリクエストを受け取り、/some/dir でMultiViewsが有効であって、
　/some/dir/foo が存在しない場合、サーバはディレクトリを読んでfoo.* に当てはまる全てのファイルを探し、事実上それらのファイルを
　マップするタイプマップを作る。そのとき、メディアタイプとコンテントエンコーディングは、そのファイル名を直接指定したときと
　同じものが割り当てられる。それからクライアントの要求に一番合うものを選ぶ。

　サーバがディレクトリの索引を作ろうとしている場合、MultiViewsはDirectoryIndexディレクティブで指定されたファイルを探す過程にも
　適用される。設定ファイルに DirectoryIndex index が書かれていて、index.htmlとindex.html3 が両方存在していると、サーバはその中から
　どちらかを適当に選ぶ。もしその両方が存在せずにindex.cgiが存在していると、サーバはそれを実行する。

　もしディレクトリを呼んでいる際に、文字セット、コンテントタイプ、言語、エンコーディングを指定するためのmod_mimeで認識できる
　拡張子を持たないファイルが見つかると、結果はMultiViewsMatchディレクティブの設定に依存する。このディレクティブはハンドラ、フィルタ、
　他のファイル拡張子タイプのどれがMultiViewsネゴシエーションで使用できるかを決定する。

・ネゴシエーション方法

　Apacheはリソースのvariantの一覧を、タイプマップファイル化ディレクトリ内のファイル名からかで取得した後、
　「最適な」variantを決定するために2つの方法のどちらかを起動する。Apacheのコンテントネゴシエーションの機能を使うために、
　どのようにしてこの調停が行われるか詳細を知る必要はない。しかしながら、この文書の残りでは関心のある人のために、
　使用されている方法について説明している。

　ネゴシエーション方法は以下の2つがある。

　　1．通常は「Apacheのアルゴリズムを用いた Server driven negotiation」が使用される。Apacheのアルゴリズムは後に詳細に説明されている。
　　　 このアルゴリズムが使用された場合、Apacheはより良い結果になるように、特定の次元において品質の値を「変える」ことができる。
　　　 Apacheが品質の値を変える方法は後で詳細に説明されている。

　　2．RFC2295で定義されている機構を用いてブラウザが特に指定した場合、「transparent content negotiation」が使用される。
　　　 このネゴシエーション方法では「最適な」variantの決定をブラウザが完全に制御することができる。ですから、結果はブラウザが使用している
　　　 アルゴリズムに依存する。Transparent negotiation の処理の過程で、ブラウザはRFC2296で定義されている
　　　 remote variant selection algorithm を実行するように頼むことができる。

　ネゴシエーションの次元

　メディアタイプ
　　→ ブラウザはAcceptヘッダフィールドで優先傾向を指定する。アイテムそれぞれは関連した品質数値を持つことができる。
　　　variantの説明も品質数値を持つことができる(qsパラメータを確認)

　言語
　　→ ブラウザはAccept-Languageヘッダフィールドで優先傾向を指定する。要素それぞれに品質数値を持たせることができる。
　　　varianthは0か1つかそれ以上の言語と関連付けることができる。

　エンコーディング
　　→ ブラウザはAccept-Encodingヘッダフィールドで優先傾向を指定する。要素それぞれに品質数値を持たせることができる。

　文字セット
　　→ ブラウザはAccept-Charsetヘッダフィールドで優先傾向を指定する。要素それぞれに品質数値を持たせることができる。
　　　variantはメディアタイプのパラメータとして文字セットを指定することもできる。

　Apacheネゴシエーションアルゴリズム

　ブラウザに返す「最適な」variantを(もしあれば)選択するようにApacheは次のアルゴリズムを使うことができる。
　このアルゴリズムを設定により変更することはできない。以下のように動作する。

　　1．まずはじめに、ネゴシエーションの次元それぞれについて適切なAccept*ヘッダフィールドを調べ、variantそれぞれに品質を割り当てる。
　　　 もしある次元のAccpet*ヘッダでそのvariantが許容できないことが示されていれば、それを削除する。
　　　 variantが1つも残っていなければ、ステップ4に行く。

　　2．消去法で「最適な」variantを選ぶ。以下のテストが順番に適用される。テストで選択されなかったvariantは削除されていく。
　　　 テスト後variantが1つだけ残っていれば、それを最適なものとしてステップ3に進む。複数variantが残っていれば、次のテストに進む。

　　　1．variantのメディアタイプの品質数値とAcceptヘッダの品質数値との積を計算して、最高値のvariantを選ぶ。
　　　2．言語品質数値が最高のvariantを選ぶ。
　　　3．(もしあれば)Accept-Languageヘッダの言語順か、(もしあれば)LanguagePriorityディレクティブの言語順で最適な言語のvariantを選ぶ。
　　　4．最高「レベル」のメディアパラメータ(text/html メディアタイプのバージョンを考えるために使われる)を持つvariantを選ぶ。
　　　5．Accept-Charsetヘッダ業で与えられている最高の文字セット メディアパラメータを持つvariantを選ぶ。
　　　　 明示的に除外されていない限り、ISO-8859-1 が許容されるようになっている。text/* メディアタイプであるけれども
　　　　 特定の文字セットに明示的に関連付けられているわけではないvariantは ISO-8859-1 であると仮定される。
　　　6．ISO-8859-1 ではない文字セットメディアパラメータと関連付けられているvariantを選ぶ。
　　　　 そのようなvariantが無い場合は、代わりに全てのvariantを選ぶ。
　　　7．最適なエンコーディングのvariantを選ぶ。もしuser-agentが許容するエンコーディングがあれば、そのvariantのみを選ぶ。
　　　　 そうではなく、もしエンコードされたものとそうでないvariantが混ざって存在していたらエンコードされていないvariantのみを選ぶ。
　　　　 variantが全部エンコードされているかvariantが全部エンコードされていないという場合は、全てのvariantを選ぶ。
　　　8．内容の最も短いvariantを選ぶ。
　　　9．残っているvariantの最初のものを選ぶ。タイプマップファイルの最初にリストされているか、
　　　　 variantがディレクトリから最初に読み込まれる時にASCII順でソートしてファイル名が先頭になったか、のどちらか。

　　3．アルゴリズムを使って1つの「最適な」variantを選んだので、それを応答として返す。ネゴシエーションの次元を指定するために
　　　 HTTPレスポンスヘッダVaryが設定される(リソースのキャッシュをするときに、ブラウザやキャッシュはこの情報を使うことができる)。
　　　 以上でvariantを選択するアルゴリズムは終了となる。

　　4．ここに来たということは、variantが1つも選択されなかった(ブラウザが許容する物がなかったため)ということである。
　　　 406ステータス("No Acceptable representation"を意味する)が、利用可能なvariantのリストの付いたHTMLドキュメントと共に返される。
　　　 相違の次元を示すHTTP Varyヘッダも設定される。

・品質の値を変える

　上記のApacheネゴシエーションアルゴリズムの厳格な解釈で得られるであろう値から、Apacheは品質数値を時々変える。
　これは、このアルゴリズムで完全ではない、あるいは正確でない情報を送るブラウザ向けにより良い結果を得るために行われる。
　かなりポピュラーなブラウザで、もしないと間違ったvariantを選択する結果になってしまうようなAcceptヘッダ情報を送るものもある。
　ブラウザが完全で正しい情報を送っていれば、この数値変化は適用されない。

　メディアタイプとワイルドカード

　Accept: リクエストヘッダはメディアタイプの優先傾向を指定する。これはまた、image/ や */* といったワイルドカードメディアタイプを
　含むことができる。ここで*は任意の文字列にマッチする。そのため Accept: image/*, */* を含むリクエストはimage/で始まるタイプ全てを
　許容できる、そして他のどんなタイプも許容できる(この場合初めのimage/*は冗長になる)ことを示す。扱うことのできる明示的なタイプに加えて、
　機械的にワイルドカードを送るブラウザもある。例えば、

　　Accept: text/html, text/plain, image/gif, image/jpeg, */*

　上記のようにする狙いは、明示的にリストしているタイプが優先されるけれども、異なる表現が利用可能であればそれでも良い、ということ。
　しかしながら、↑の基本的なアルゴリズムでは、*/*ワイルドカードは他の全てのタイプと全く同等なので優先されない。
　ブラウザは*/*にもっと低い品質(優先)値をつけてリクエストを送るべき。例えば、

　　Accept: text/html, text/plain, image/gif, image/jpeg, */*; q=0.01

　明示的なタイプには品質数値が付けられていないので、デフォルトの1.0(最高値)の優先になる。
　ワイルドカード*/*は低い優先度0.01を与えられているので、明示的にリストされているタイプに合致する
　variantが無い場合にのみ他のタイプが返される。

　もしAccept: ヘッダがq値を含んでいなければ、望みの挙動をするために、Apacheは*/*があれば0.01のq値を設定する。
　また、type/* の形のワイルドカードには0.02のq値を設定する(ですからこれらは*/*のマッチよりも優先される)。
　もしAccept:ヘッダ中のメディアタイプのどれかがq値を含んでいれば、これらの特殊な値は適応されず、
　正しい情報を送るブラウザからのリクエストは期待通りに動作するようになる。

　言語ネゴシエーションの例外処理

　Apache2.0では新たに、言語ネゴシエーションが適合するものを見つけるのに失敗したときに、優雅にフォールバックできるような
　ネゴシエーションアルゴリズムがいくつか追加された。

　サーバのページをクライアントがリクエストしたけれども、ブラウザの送ってきたAccept-Languageに合致するページが
　1つも見つからなかった場合に、サーバは"No Acceptable Variant"か"Multiple Choices"レスポンスをクライアントに返す。
　これらのエラーメッセージを返さないように、このような場合にはApacheがAccept-Languageを無視して、
　クライアントのリクエストに明示的には合致しないドキュメントを提供するように設定できる。
　ForceLanguagePriorityディレクティブは、これらのエラーの1つか両方をオーバーライドするために使用できて、
　LanguagePriorityディレクティブの内容を使ってサーバの判断を代行するようにできる。

　サーバは他に適合するものが見つからなければ、言語サブセットで適合するものを試そうともする。
　例えばクライアントが英国英語であるen-GB言語でドキュメントをリクエストした場合、サーバはHTTP/1.1規格では、
　単にenとマークされているドキュメントをマッチするものとすることは通常は許されていない。(英国英語は理解できるけど
　一般的な英語は理解できないという読み手は考えられないので、Accept-Languageヘッダでen-GBを含んでenを含まないのは
　ほぼ確実に設定の間違いである、と言うことに注意する。しかし不幸なことに多くのクライアントではデフォルトでこのような設定になっている。)
　しかしながら、他の言語にはマッチせず、No Acceptable Varianths エラーを返したり、LanguagePriorityにフォールバックしようとしている時は
　サブセット指定を無視して、en-GBをenにマッチする。Apacheはクライアントの許容言語リストに暗黙に非常に低い品質地の親言語を加えることになる。
　しかし、クライアントがen-GB; q=0.9, fr; q=0.8 とリクエストして、サーバがenとfrと設計されたドキュメントを持っている場合は
　frドキュメントが返されることに注意する。このような処理は、HTTP1.1規格との整合性を維持して、適切に設定されたクライアントとも
　きちんと動作するために必要である。

　より高度なテクニック(Coolieや特殊なURLパス等)においてもユーザの言語選択をサポートするため、Apache2.0.47からは、
　mod_negotiation が環境変数 prefer-language を認識するようになった。この変数が存在して、適切な言語タグが代入されているのであれば、
　mod_negotiation は合致するvariantを選択しようとする。合致するものが無ければ、通常のネゴシエーション手順が適用される。
　例としては以下の通り。

　　SetEnvIf Cookie "language=(.+)" prefer-language=$1
    Header append Vary cookie

・Transparent Content Negotiation の拡張

　Apacheはtransparent content negotiation プロトコル(RFC 2295)を次のように拡張している。
　特定のコンテントエンコーディングのみが利用可能であるvariantに印をつけるために、新たに{encoding ..}要素をvariantリスト中に使っている。
　リスト中のエンコードされたvariantは、どれでも候補variantとして使用するように、RVSA/1.0アルゴリズム(RFC 2296)の実装が拡張された。
　RVSA/1.0の実装では、最適なvariantが見つかるまで、計算した品質数値は小数点以下5桁まで丸めない。

・リンクと名前の変換に関する注意点

　言語ネゴシエーションを使っている場合は、ファイルが1つ以上の拡張子を持てて、拡張子の順番は通常は考慮されない
　(詳細はmod_mimeを参照)ので、いくつかの異なる名前の変換を選べることになる。

　典型的なファイルでは、MIMEタイプ拡張子(例えばhtml)を持っていて、エンコーディング拡張子(例えばgz)を持っているかもしれなくて、
　このファイルに異なる言語variantを用意していれば、もちろん言語拡張子(例えばen)を持っているだろう。以下は例。

　　foo.en.html
    foo.html.en
    foo.en.html.gz

　以下は上記のようなファイル名に対して、使えるリンクと使えないリンクの例である。

　　foo.html.en →    使える(foo , foo.html)                 使えない(なし)
    foo.en.html →    使える(foo)                            使えない(foo.html)
    foo.html.en.gz → 使える(foo , foo,html)                 使えない(foo.gz , goo.html.gz)
    foo.en.html.gz → 使える(foo)                            使えない(foo.html , foo.html.gz , foo.gz)
    foo.gz.html.en → 使える(foo , foo.gz , foo.gz.html)     使えない(foo.html)
    foo.html.gz.en → 使える(foo , foo.html , foo.html.gz)   使えない(foo.gz)

　上の表を見て、拡張子なしのリンク(例えばfoo)がいつでも使えることに気が付くだろう。
　この利点は、ドキュメントとして応答するファイルの実際のファイルタイプを隠ぺいして、リンクの参照を変更することなく
　後からファイルを変更できる、例えばhtmlからshtmlに、あるいはcgiに変更できる点である。

　リンクにMIMEタイプを使い続けたい(例えばfoo.html)時は、言語拡張子は(エンコーディング拡張子もあればそれも含めて)
　MIMEタイプ拡張子の右側になければならない(例えば foo.html.en)。

・キャッシュに関する注意事項

　キャッシュが1つの表現を保存している時は、リクエストURLと関連付けられている。次にそのURLがリクエストされたときに、
　キャッシュは保存されている表現を使用できる。しかし、リソースがサーバでネゴシエーション可能であれば、
　最初のリクエストでキャッシュされて続くキャッシュヒットでは間違った応答を返してしまうということになりかねない。
　これを防ぐために、Apacheはコンテントネゴシエーションの後に返された応答全てに、
　HTTP/1.0クライアントではキャッシュ不可能の印をつける。また、ネゴシエーションされた応答のキャッシュを可能にする
　HTTP/1.1プロトコルの機能もApacheはサポートする。

　HTTP/1.0準拠のクライアントからのリクエストに対しては、(ブラウザであろうとキャッシュであろうと)ネゴシエーションを受けた
　応答のキャッシュを許すために、CacheNegotiatedDocsディレクティブを使用できる。このディレクティブは、サーバ設定ファイルや
　バーチャルホストに書くことができ、引数を取らない。HTTP/1.1クライアントからのリクエストには効力を持たない。

　HTTP/1.1クライアントに対しては、レスポンスのネゴシエーション次元を示すためにVary HTTPレスポンスヘッダを送る。
　キャッシュはこれを使って後続のリクエストに対してローカルコピーで応答できるかどうかを決定できる。
　ネゴシエーション次元とは関係なしにローカルコピーの使用を優先するには、force-no-vary環境変数を設定する。

動的共有オブジェクト(DSO)サポート

　Apache HTTPサーバはモジュール化されたプログラムで、管理者がモジュールを選択することでサーバに組み込む機能を選ぶことができる。
　モジュールはサーバがビルドされる時にhttpdバイナリに静的に組み込むことができる。もしくは、httpdバイナリとは別に存在する
　動的共有オブジェクト(Dynamic Shared Object:DSO)としてコンパイルすることもできる。DSOモジュールはサーバがビルドされる時に
　コンパイルしたり、Apache拡張ツール(apxs)を使って後でコンパイルして追加したりできる。

　この文書はDSOモジュールの使い方と、仕組みについて説明する。

・実装

　個々のApacheモジュールをロードするためのDSOサポートは mod_so というモジュールの機能に基づいている。
　このモジュールはApacheのコアに静的に組み込まれている必要がある。それは core.c 以外ではDSOにできない唯一のモジュールである。
　事実上、他の全てのApacheのモジュールは、インストールの文書で説明されているように、configureの--enable-module=sharedオプションで
　それぞれをDSOビルドにすることにより、DSOモジュールにすることができる。mod_foo.soのようなDSOにモジュールがコンパイルされれば、
　httpd.confファイル中で mod_so の LoadModule ディレクティブを使うことでサーバの起動や再起動時にこのモジュールをロードするようにできる。

　Apacheモジュール用の(特にサードパーティモジュールの)DSOファイルの作成を簡単にするために、APXS(APache eXtenSion)という
　新しいサポートプログラムがある。Apacheのソースツリーの外でDSOモジュールをビルドするために使うことができる。発想は単純。
　Apacheのインストール時のconfigure,make install のときにApacheのCヘッダをインストールし、DSOビルド用のプラットフォーム依存の
　コンパイラとリンカのフラグをapxsプログラムに追加する。これにより、ユーザがApacheの配布ソースツリーなしで、さらにDSOサポートの
　ためのプラットフォーム依存のコンパイラやリンカのフラフをいじることなくApacheのモジュールのソースをコンパイルできるようになる。

・使用法の概要

　Apache2.xのDSO機能の概略を知ることができるための、短く簡潔な概要である。

　1．配布されているApacheモジュール、仮にmod_foo.c として、それDSOmod_foo.so にビルド、インストール

　　./configure --prefix=/path/to/install --enable-foo=shared
    make install

　2．サードパーティApacheモジュール、仮にmod_foo.c として、それをDSOmod_foo.so にビルド、インストール

　　./configure --add-module=module_type:/path/to/3rdparty/mod_foo.c\ --enable-foo=shared
    make install

　3．共有モジュールの後々のインストールのためにApacheを設定

　　./configure --enable-so
    make install

　4．サードパーティApacheモジュール、仮にmod_foo.c として、それをapxsを使ってApacheソースツリーの外でDSOにビルド、インストール

　　cd /path/to/3rdparty
    apxs -c mod_foo.c
    apxs -i -a -n foo mod_foo.la

　どの場合においても、共有モジュールをコンパイルした後で、httpd.confでLoadModuleディレクティブを使って
　Apacheがモジュールを使用するようにしなければならない。

・背景

　最近のUnix系のOSには動的共有オブジェクト(DSo)の動的リンク/ロードという気の利いた機構が存在する。
　これは、実行時にプログラムのアドレス空間にロードできるような特別な形式でプログラムをビルドすることを可能にする。

　このロードは2つの方法で行うことができる。実行プログラムが起動されたときにld.so というシステムプログラムにより
　自動的に行われる方法と、実行プログラム中から、システムコールdlopen()/dlsym() によるUnixローダへのプログラムシステムの
　インタフェースを使って手動で行う方法とがある。

　最初の方法ではDSOは普通は共有ライブラリやDSOライブラリと呼ばれていて、DSOの名前はlibfoo.soやlibfoo.so.1.2にようになっている。
　これらはシステムディレクトリ(通常/usr/lib)に存在し、実行プログラムへのリンクはビルド時に-lfooをリンカに指定することで確立される。
　これによりライブラリへの参照が実行プログラムのファイルに書き込まれて起動時にUnixのローダが/usr/libや、
　リンカの-Rのようなオプションによりハードコードされたパス、環境変数LD_LIBRAR_PATHにより設定されたパス、の中から
　libfoo.soの場所を見つけることができる。それから、実行プログラム中の(まだ未解決の)シンボルをDSOにあるシンボルで解決する。

　普通は実行プログラム中のシンボルはDSOからは参照されない(DSOは一般的なコードによる再利用可能なライブラリですので)。
　ですから、さらなるシンボルの解決は必要ない。シンボルはUnixローダにより完全な解決が行われるので、実行ファイル自身は何もする必要が無い。
　(実際のところ、静的でない方法でリンクされている全ての実行プログラムに組み込まれている開始用のコードの一部にld.soを起動するコードが
　含まれている)。よく使われるライブラリの動的ロードの利点は明らかである。ライブラリのコードはシステムライブラリにlibc.soのようにして
　一度保存するだけでよく、プログラムのために必要なディスクの領域を節約することができる。

　2つ目の方法ではDSOは普通は共有オブジェクトやDSOファイルと呼ばれていて、任意の拡張子をつけることができる(ただし、標準的な名前はfoo.so)
　これらのファイルは通常はプログラム専用のディレクトリに置かれ、これらを使う実行プログラムへのリンクは自動的にはされない。
　そのため、実行プログラムはdlopen()を使って実行時に手動でDSOをプログラムのアドレス空間にロードする必要がある。
　この時点では実行プログラムに対してDSOのシンボルの解決は行われない。しかし、その代わりにUnixのローダがDSOの(まだ未解決の)シンボルを
　実行プログラムによりエクスポートされたシンボルと既にロードされたDSOライブラリによりエクスポートされたシンボル(特に、どこにでもある
　libc.soの全てのシンボル)で自動的に解決する。こうすることで、DSOは最初から静的にリンクされていたかのように、実行プログラムのシンボルを
　知ることができる。

　最後に、DSOのAPIを利点を生かすために、プログラムは後でディスパッチテーブルなどでシンボルを使うことができるように、dlsym()を使って
　いくつかのシンボルを解決する。すなわち実行プログラムは必要なすべてのシンボルを手動で解決しなければならない。この機構の利点は
　プログラムのオプショナルな部分は必要になるまでロードする必要が無い(だからメモリも消費しない)ことである。必要ならば、基本プログラムの
　機能を拡張するためにこれらの部分を動的にロードすることができる。

　このDSO機構は簡単なように見えるが、少なくとも一つ難しい点がある。プログラムを拡張するためにDSOを使っている時に、DSOが実行プログラムから
　シンボルを解決する点である(2番目の方法)。これはなぜだろうか？それは、DSOのシンボルを実行プログラムのシンボルから「逆解決」するというのは
　ライブラリの設計(ライブラリはそれを使用するプログラムのことは何も知らない)に反していて、この機能は全てのプラットフォームにあるわけではなく、
　標準化もされていないからである。実際には実行プログラムのグローバルなシンボルは再エクスポートされることはあまりなく、
　DSOから使うことができない。リンカにグローバルシンボル全てをエクスポートするようにさせる方法を見つけることが、
　実行時にプログラムを拡張するためにDSOを使う時の一番の問題である。

　共有ライブラリのアプローチが普通の方法である。DSO機構はそのために設計されたものですから。したがって、その方法はオペレーティングシステムが
　提供するほとんどすべての種類のライブラリで使われている。一方、プログラムの拡張のために共有オブジェクトを使用する、
　という方法はあまり使われていない。

　1998年の時点で、実行時に実際に機能拡張のためにDSO機構を使っているソフトウェアパッケージは少しだけだった。
　Perl5(XS機構とDnaLoaderモジュールによるもの)、Netscapeサーバなど。Apacheは既にモジュールの概念を使って機能拡張をしていて、
　内部的にディスパッチリストに基づいた外部モジュールのApacheコア機能へのリンクを行っていましたので、
　バージョン1.3から、ApacheもDSO機構を使う仲間になった。Apacheは実行時にDSOを使ってモジュールをロードするように既に運命づけられていたのです。

・利点と欠点

　上記のDSOに基づいた昨日は以下の利点がある。

　　1．実際のサーバプロセスを組み立てるために、ビルド時にconfigureのオプションを使う代わりに実行時にhttpd.confの設定用コマンドLoadModuleを
　　　 使うことができるので、サーバパッケージの柔軟性が高まった。たとえば、1つのApacheのインストールから違う構成のサーバ
　　　 (標準版とSSL版、最小構成と拡張版[mod_perl,PHP3など])を実行することができる。

　　2．インストールの後であっても、サーバのパッケージをサードパーティモジュールで簡単に拡張できるようになった。
　　　 これは、Apacheコアパッケージと、PHP3,mod_perl,mod_fastcgiなどの追加のパッケージを作成できるので、
　　　 少なくともベンダのパッケージ管理者にとって大きな利点がある。

　　3．Apacheモジュールの開発が簡単になる。これはDSOとapxsの組み合わせにより、Apacheソースツリーの外で作業でき、開発中のモジュールの新しい
　　　 バージョンを実行中のApacheサーバに組み込むためにapxs -i と apachectl restart を行うだけでよくなるからである。

　DSOには以下の欠点がある。

　　1．すべてのオペレーティングシステムがプログラムのアドレス空間にコードを動的ロードすることをサポートしているわけではないので、
　　　 プラットフォームによってはDSO機構は使えない。

　　2．Unixのローダがシンボルの解決をする必要ができたので、そのオーバヘッドによりサーバの起動時間が約20%遅くなっている。

　　3．位置飛依存コード(PIC:Position Independent Code)は、相対アドレスのために複雑なアセンブラのトリックが必要なことがあり、
　　　 それは必ずしも絶対アドレスと同じくらいの速度が出るわけではないので、プラットフォームによってはサーバの実行速度が約5%遅くなる。

　　4．DSOモジュールは全てのプラットフォームで他のDSOに基づいたライブラリに対してリンクできる(ld -lfoo)というわけではないので
　　　 (たとえば、a.outのプラットフォームではこの機能はないが、ELFのプラットフォームにはある)、全ての種類のモジュールにDSO機構を
　　　 使えるわけではない。言い換えると、DSOファイルとしてコンパイルされたモジュールの使えるシンボルは、Apacheのコアのシンボル、
　　　 Cライブラリ(libc)とApacheコアが使っているほかの全ての静的なライブラリと動的ライブラリのシンボル、PICによる静的なライブラリ
　　　 (libfoo.a)のシンボルのみに制限される。そのほかのコードを使う方法は、Apacheコア自身が既にそのコードへの参照があるようにするか、
　　　 dlopen()を使ってコードを自分自身でロードするかのどちらかしかない。

Apacheの環境変数

　Apache HTTPサーバは環境変数と呼ばれる、名前の付いた変数に情報を記憶する仕組みを提供している。この情報をログ収集やアクセス制御などの
　いろいろな動作を制御するために使うことができる。これらの変数はCGIスクリプトなどの外部プログラムと通信するためにも使われる。
　この文書はそれらの変数の操作方法と使用方法をいくつか紹介する。

　これらの変数は環境変数と呼ばれていますが、オペレーティングシステムによって制御されている環境変数と同じではない。
　実際は、これらの変数はApacheの内部構造の中に記憶され、操作されている。それらは、CGIやSSIスクリプトに渡されたときだけ、
　実際のオペレーティングシステムの環境変数になる。サーバ自身が実行されているオペレーティングシステムの環境を操作したい場合は、
　オペレーティングシステムのシェルが提供している標準の環境変数の操作方法を使わなければならない。

・環境変数の設定

　基本的な環境の操作

　Apacheにおいて環境変数を設定する一番基本的な方法は、無条件に環境変数を設定するSetEnvディレクティブを使用すること。
　PassEnvディレクティブにより、Apacheが起動されたシェルの環境変数を渡すこともできる。

　リクエストごとに条件に基づいて設定する

　より柔軟性を高めるために、mod_setenvifで提供されているディレクティブを使用することで、リクエストの特性に基づいて
　環境変数を設定することができる。例えば、特定のブラウザ(User-Agent)のリクエストや特定のReferer(※正しい綴りはreferrerだが、
　HTTPの仕様ではRefererとなっている)ヘッダが見つかった時のみ変数を設定することができる。mod_rewriteのRewriteRuleディレクティブにおいて
　環境変数を設定する[E=...]オプションを使用することで、より柔軟な設定を行うことができる。

　一意な識別子

　mod_unique_idは、非常に限られた条件の下で「すべて」のリクエストについて、
　一意であることが保障されている値を環境変数UNIQUE_IDに設定する。

　標準CGI変数

　Apacheの設定ファイルで設定された環境変数とシェルから渡される環境変数に加えて、CGIスクリプトとSSIページには「CGIの仕様」ページで
　要求されている、リクエストのメタ情報を持った環境変数の組が提供される。

　いくつかの注意

　　1．環境を操作するディレクティブを使って標準CGI変数を上書きしたり変更したりすることはできない。

　　2．CGIスクリプトを起動するためにsuexec が使用されている場合、CGIスクリプトが起動するために、環境変数は安全な環境変数の組に整理される。
　　　 この安全な環境変数のの集合は、コンパイル時にsuexec.cで定義される。

　　3．移植性のために、環境変数の名前はアルファベット、数字とアンダースコア(_)だけから成る。さらに、最初の文字は数字であってはいけない。
　　　 この制限に合わない文字はCGIスクリプトとSSIページに渡される時にアンダースコアに置換される。

　　4．SetEnv はリクエスト処理の段階の中でも遅くに実行される。
　　　 つまりSetEnvIf や RewriteCondなどからは変数がそこで設定されていることが分からない。

・環境変数の使用

　CGIスクリプト
　　→ 環境変数の主な利用法の1つは、CGIスクリプトに情報を伝えること。CGIスクリプトに渡される環境変数はApacheの設定により
　　　設定される変数に加えて、リクエストの標準のメタ情報を含んでいる。

　SSIページ
　　→ mod_includeのINCLUDESフィルタで処理されるserver-parsed(SSI)ドキュメントでは、echo要素を使用すると環境変数が出力される。
　　　また、ページのある部分がリクエストの性質に応じて変更されるように、環境変数をフロー制御要素で使うことができる。

　アクセス制御
　　→ allow from env=ディレクティブとdeny from env=ディレクティブを使用して、サーバへのアクセスを環境変数の値で制御することができる。
　　　SetEnvIfディレクティブを組み合わせることで、クライアントの特性に基づいてサーバへのアクセス制御を柔軟に行うことができるようになる。
　　　例えば、これらのディレクティブを使用して、特定のブラウザ(User-Agent)からのアクセスを拒否することができる。

　条件付きログ記録
　　→ LogFormatディレクティブのオプション %e を使用することで、環境変数をアクセスログに記録することができる。
　　　さらに、CustomLogディレクティブの条件分岐式を使用することで、環境変数の値によってリクエストをログに記録するかどうかを
　　　決めることができる。SetEnvIfディレクティブを組み合わせることで、どのリクエストをログに記録するかを柔軟に制御することが可能になる。
　　　たとえば、gifで終わるファイル名へのリクエストはログに記録しない、違うサブネットからのクライアントからのリクエストだけを
　　　ログに記録する、という選択が可能である。

　条件付き応答ヘッダ
　　→ Headerディレクティブは環境変数の存在や不在によってクライアントへの応答に特定のHTTPヘッダをつけるかどうかを決めることができる。
　　　これにより、例えば、クライアントからのリクエストにあるヘッダがある場合にのみ特定の応答ヘッダを送る、というようなことができる。

　URLの書き換え
　　→ RewriteCondディレクティブで評価文字列として%{ENV:...}式を指定することで、mod_rewriteの書き換えエンジンが環境変数に基づいて
　　　条件分岐を行うことができる。mod_rewriteが使用可能な変数でENV:が前についていない変数は、
　　　実際は環境変数ではないということに注意する。それらは他のモジュールからは使用できないmod_rewrite用の特別な変数である。

・特別な目的の環境変数

　互換性の問題を解決するために、特定のクライアントと通信している時はApacheの動作を変更できる機構が導入された。
　できるだけ柔軟にするために、これらの機構は環境変数を定義することで呼び出される。普通は、BrowserMatchディレクティブを使うが、
　たとえばSetEnvディレクティブやPassEnvディレクティブも使用することができる。

　downgrade-1.0
　　→ これを指定することで、リクエストがHTTP/1.0より新しいプロトコルの場合でも、HTTP/1.0として扱われる。

　force-gzip
　　→ DEFLATEフィルタが使用するように設定されている時に、この環境変数はブラウザのaccept-encodingの設定を無視して
　　　常に圧縮された出力を送るようにする。

　force-no-vary
　　→ 応答ヘッダがクライアントに送られる前にVaryフィールドを取り除く。クライアントの中にはこのフィールドを正しく解釈しないものがある。
　　　この変数を設定することでその問題を回避することができる。この変数を設定すると、force-response-1.0が設定されたことになる。

　force-response1.0
　　→ これが設定されていると、HTTP/1.0リクエストを発行するクライアントに対しては常にHTTP/1.0で応答するようになる。
　　　この機能は、もともとはAOLのプロキシの問題のために実装された。HTTP/1.0クライアントの中には、HTTP/1.1の応答を返されると
　　　正しく動作しないものがあるかもしれない。この機能を使用することで、そのようなクライアントとの間の互換性問題を解決できる。

　gzip-only-text/html
　　→ これが1に設定されると、この変数はtext/html以外のコンテントタイプに対する、mod_deflate提供のDEFLATE出力フィルタを無効にする。
　　　また、静的に既に圧縮されたファイルを使用したい場合、(gzipだけでなく、identiti と異なる全てのエンコードに対して)
　　　mod_negotiationも変数を評価する。

　no-gzip
　　→ セットされると、mod_deflateのDEFLATEフィルタがオフになる。そしてmod_negotiationはエンコードされたリソースを送らないようにする。

　nokeepalive
　　→ これが設定されている場合は、KeepAliveを使用しないようにする。

　prefer-language
　　→ mod_negotiationの挙動に影響を与える。(en,ja,x-klingonといった)言語タグが格納されていれば、その言語のvariantoを送信しようとする。
　　　そのようなvariantが無い場合は、通常のネゴシエーション処理が適用される。

　redirect-carefully
　　→ これはクライアントへのリダイレクトの送信をサーバが注意深く行うようにする。これは通常、リダイレクトに際してクライアントに問題が
　　　あることが分かっている場合に使われる。この機能は元々はマイクロソフトのwebフォルダのソフトがDAVメソッドによるディレクトリの
　　　リソースへのリダイレクトの扱いに問題があり、それを回避するために実装された。

　suppress-error-charset(Apache2.2以降で利用可能)
　　→ クライアントのリクエストに対する応答としてリダイレクトを送信する際、レスポンスにはリダイレクトが自動的に行えない(行われない)
　　　場合に表示するテキストが含まれる。通常、このテキストに合致したキャラクタセット、ISO-8859-1でラベル付けをする。

　　　しかし、リダイレクト先が別の文字セットを使っている場合、ある問題のあるブラウザのバージョンでは、リダイレクト先の実際の文字セットの
　　　代わりに、リダイレクト元の文字セットを使ってしまうことがある。その結果、例えば変な描画が行われたりして、読めなくなったりする。

　　　この環境変数を設定することで、リダイレクションテキストに対するキャラクタセットの指定を除去するので、それら問題のあるブラウザでも
　　　リダイレクト先の文字セットを正しく使うようにできる。

　　※セキュリティ
　　　→ 文字セットを指定せずにエラーページを送信すると、クロスサイトスクリプティング(XSS)攻撃の危険性が出てくる。
　　　　HTTP/1.1仕様に準拠していなくて、コンテンツの中身から文字セットを"推測"仕様とするブラウザ(MSIE)が実際にあるからである。
　　　　そのようなブラウザはUTF-7文字セットを使って簡単にだますことができる。クロスサイトスクリプティング攻撃を防ぐために実装されている
　　　　通常のエスケープ機構が、入力データ中にあるUTF-7でエンコードされたコンテンツ(リクエストURIなど)にはうまく動作しないから。

　　force-proxy-request-1.0,proxy-nokeepalive,proxy-sendchunked,proxy-sendcl
　　　→ これらの指示子はmod_proxyの挙動を変更する。詳細はmod_proxyのドキュメントを参照。

・例

　おかしな挙動をするクライアントに対してプロトコルの動作を変更する

　古いバージョンのApacheでは、クライアントの問題に対応するためにhttpd.confニ次の行を加えるよう推奨されていたが、
　今となっては、問題としていたくらい案tのは実際には見かけることは無くなってきたので、この設定はもはや必要ないかもしれない。

　　BrowserMatch "Mozilla/2" nokeepalive
    BrowserMatch "MSIE 4\.0b2;" nokeepalive dwngrade-1.0 force-response-1.0

　画像へのリクエストをアクセスログに記録しない

　以下の例では、画像へのリクエストがアクセスログに現れないようにする。これを変更することで、特定のディレクトリのログ収集をやめたり、
　特定のホストからのリクエストのログ収集をやめたりすることが簡単にできる。

　　SetEnvIf Request URI \.gif image-request
    SetEnvIf Request URI \.jpg image-request
    SetEnvIf Request URI \.png image-request
    customLog logs/access_log common env=!image-request

　「画像の盗用」を防ぐ

　以下の例は、別のサーバにいる人が、あなたのサーバにある画像をinline画像として使用することを防ぐ。
　これは推奨されている設定ではないが、ある限定された状況では有効。ここでは、全ての画像は/web/imagesというディレクトリにあると仮定する。

　　SetEnvIf Referer "^http://www\.example\.com/" local_referal
    SetEnvIf Referer "^$" local_referal
    <Directory /web/images>
        Order Deny,Allow
        Deny from all
        Allow from env=local_referal
    </Directory>

ログファイル

　webサーバを効果的に管理するためには、サーバの活動やパフォーマンス、今発生しているかもしれない問題に関するフィードバックを
　得ることが必要である。Apache HTTPサーバには非常に包括的で柔軟なロギング機能がある。この文書はロギング機能の設定の仕方と、
　ログに何が書かれているかを理解するための方法を説明する。

・セキュリティに関する警告

　Apacheがログファイルを書いているディレクトリに書き込める人は、ほぼ確実にサーバが起動されたuidへのアクセスを手に入れることができる。
　そして、それは通常はrootユーザである。ちゃんと結果を考えることなく、そのディレクトリへの書き込み権限を与えないでください。
　詳しくは https://httpd.apache.org/docs/current/misc/security_tips.html を確認する。

　加えて、ログファイルにはクライアントからの情報がそのまま、エスケープされることなく書かれている。そのため、悪意のあるクライアントが
　ログファイルに制御文字を挿入することができる。生のログを扱う時は注意する。

・エラーログ

　ErrorLogディレクティブにより名前と場所が決まるサーバのエラーログは、一番重要なログファイルである。Apacheの診断情報はここに送られ、
　リクエストを処理している時に発生したエラーはすべてここに記録される。サーバを起動したときや、サーバの動作に問題が起こった時は
　一番最初に調べるべきところである。間違いの詳細や修正方法がそこに書かれていることが良くある。

　エラーログは普通はファイルに書かれる(通常Unixシステムではerror_log,WindowsとOS/2ではerror.log)。
　Unixシステムではエラーをsyslogやパイプでプログラムに送ることができる。

　エラーログの書式は比較的自由度の高いもので、説明的に書かれている。ただし、いくつかの情報はほとんどのエラーログのエントリにある。
　例えば、代表的なものに以下のようなメッセージがある。

　　[Wed Oct 11 14:32:52 2000] [error] [client 127.0.0.1] client denied by server configuration: /export/home/live/ap/htdocs/test

　ログエントリの最初の項目はメッセージの日付と時刻。2つ目の項目は報告されているエラーの重要度。
　3つ目の項目はエラーを発生させたクライアントのIPアドレス。残りはメッセージで、この場合はサーバがクライアントのアクセスを
　拒否するように設定されている、と言うことを示している。サーバはリクエストされた文書の(webのパスではなく)
　ファイルシステムのパスを報告する。

　非常に広範囲のメッセージがエラーログに現れる。たいていのものは上の例のような感じである。
　エラーログにはCGIスクリプトのデバッグ出力も書かれる。CGIスクリプトがstrerrに書いた全ての情報は直接エラーログにコピーされる。

　情報を追加したり削除したりしてエラーログをカスタマイズすることはできない。しかし、リクエストに対するエラーログのエントリは、
　対応するエントリが「アクセスログ」にある。例えば、上の例のエントリはアクセスログのステータスコード403のエントリに対応する。
　アクセスログはカスタマイズ可能なので、そちらを使うことによりエラーの状況に関する情報をより多く手に入れることができる。

　テストの最中は、問題が発生しているかどうかを観るために、常にエラーログを監視するのが役に立つ場合が良くある。
　Unixシステムでは以下のものを使うことができる。

　　tail -f error_log

・アクセスログ

　サーバアクセスログはサーバが処理した全てのリクエストを記録する。アクセスログの場所と内容はCustomLogディレクティブにより決まる。
　ログの内容の選択を簡潔にするためにLogFormatディレクティブを使用することができる。このセクションはアクセスログに情報を記録するための
　サーバの設定方法を説明する。

　もちろん、アクセスログに情報を蓄積することはログ管理の始まりに過ぎない。次の段階は有用な統計を取るためにこの情報を解析すること。
　一般的なログ解析はこの文書の範囲外で、webサーバ自身の仕事と言うわけでもない。この話や、ログ解析を行うアプリケーションの情報を得るには
　何か自分で調べる。(記載されていたページが表示されなかった)

　いろんなバージョンのApache httpdがmod_log_config,mod_log_agent,TransferLogディレクティブと言った、他のモジュールや
　ディレクティブを使ってアクセスのロギングを制御してきた。今では、CustomLogが全ての古いディレクティブの機能を含むようになっている。

　アクセスログの書式は非常に柔軟な設定が可能である。書式はCのprintf(1)フォーマット文字列に非常に似た「フォーマット文字列」により
　指定される。いくつか次の節で例を示す。

　Common Log Format

　アクセスログのよくある設定に以下のものがある。

    LogFormat "%h %l %u %t \"%r\" %>s %b" common

　これは、ニックネームcommonを定義し、ログのフォーマット文字列の1つと関連付ける。フォーマット文字列は%ディレクティブからなり、
　それぞれの%ディレクティブはサーバにどの情報をロギングするかを指示する。フォーマット文字列に文字をそのまま入れることもでき、
　それらはログの出力に直接コピーされる。そこに引用文字(")を書くときは、フォーマット文字列の最後として解釈されることを防ぐために
　バックスラッシュでエスケープする必要がある。フォーマット文字列には改行用の\n、タブ用の\tという特別な制御文字も含めることができる。

　CustomLogディレクティブは既に定義されたニックネームを使って新しいログファイルを設定する。アクセスログのファイル名は
　スラッシュで始まらない限り、ServerRootからの相対パスとして扱われる。

　上の設定はCommon Log Format(CLF)と呼ばれる形式でログエントリを書く。この標準の形式は異なるwebサーバの多くが生成することができ、
　多くのログ解析プログラムが読み込むことができる。CLFにより生成されたログファイルのエントリは以下のようになる。

    127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326

        127.0.0.1 (%h)
        　→ これはサーバへリクエストをしたクライアント(リモートホスト)のIPアドレス。HostnameLookupsがOnの場合は、
        　　サーバはホスト名を調べて、IPアドレスが書かれているところに記録する。しかし、この設定はサーバをかなり遅くするので、
        　　あまりお勧めできない。そうではなく、logresolveのようなログの後処理を行うプログラムでホスト名を調べるのが良い。
        　　ここに報告されるIPアドレスは必ずしもユーザが使っているマシンのものであるとは限らない。ユーザとサーバの間にプロキシサーバ
        　　があれば、このアドレスは元のマシンのものではなく、プロキシのアドレスである。

        - (%l)
        　→ 出力中の - は要求された情報が手に入らなかったということを意味する。この場合、取得できなかった情報はクライアントのマシンの
        　　identdにより決まるRFC1413のクライアントのアイデンティティである。この情報はあまり信用することができず、しっかりと管理された
        　　内部ネットワークを除いては使うべきではない。ApacheはIdentityCheckがOnになっていない限り、この情報を得ようとすらしない。

        frank (%u)
        　→ これはHTTP認証による、ドキュメントをリクエストした人のユーザID。CGIスクリプトには通常同じ値がREMOTE_USER環境変数として
        　　与えられる。リクエストのステータスコードが401であった場合に限り、ユーザは認証に失敗しているので、この値は信用できない。
        　　ドキュメントがパスワードで保護されていない場合は、この部分は前のものと同じように - になる。

        [10/Oct/2000:13:55:36 -0700] (%t)
        　→ サーバがリクエストを受け取った時刻。書式は [day/month/year:hour:minute:second zone] である。
        　　ログのフォーマット文字列に%{format}t を指定することで、別の形式で時刻を表示させることもできる。
        　　このとき、formatはCの標準ライブラリのstrftime(3)の形式になる。

        "GET /apache_pb.gif HTTP/1.0" (\"%r\")
        　→ クライアントからのリクエストが二重引用符の中に示されている。リクエストには多くの有用な情報がある。
        　　まず、この場合クライアントが使ったメソッドはGETである。次に、クライアントはリソース/apache_pb.gifを要求した。
        　　そして、クライアントはプロトコルHTTP/1.0 を使用した。リクエストの各部分を独立にログ収集することもできる。
        　　例えば、フォーマット文字列"%m %U%q %H" はメソッド、パス、クエリ文字列、プロトコルをログ収集し、
        　　結局%rと全く同じ出力になる。

        200 (%>s)
        　→ サーバがクライアントに送り返すステータスコード。この情報は、リクエストが成功応答(2で始まるコード)であったか、
        　　リダイレクション(3で始まるコード)であったか、クライアントによるエラー(4で始まるコード)であったか、
        　　サーバのエラー(5で始まるコード)であったか、を表すため、非常に大切である。ステータスコードの完全なリストは
        　　「https://www.w3.org/Protocols/rfc2616/rfc2616.txt」にある。

        2326 (%b)
        　→ この最後の部分はクライアントに送信されたオブジェクトの、応答ヘッダを除いたサイズを表す。
        　　コンテントがクライアントに送られなかった場合は、この値は - になる。
        　　コンテントが無い場合に 0 をログ収集するには、%b ではなく %B を使用する。

　Combined Log Format

　もう1つのよく使われる書式はCombined Log Format と呼ばれている。以下のようにして使うことができる。

    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"" combined
    CustomLog log/access_log combined

　この書式の最初の方はCLFと全く同じで、最後に2つ追加のエントリがある。追加のエントリは%ディレクティブ %{header}i を使っている。
　ここでheaderはHTTPリクエストヘッダのどれかである。この書式によるアクセスログは以下のような感じになる。

    127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache.pb.gif HTTP/1.0" 200 2326 "http://www.example.com/start.html"
     "Mozilla/4.08 [en] (Win98; I ;Nav)"

        "http://www.example.com/start.html" (\"%{Referer}i\")
        　→ Referer HTTPリクエストヘッダ。これはクライアントが報告してくる参照元のサイトを表す。(この場合は、/apache_pb.gifに
        　　リンクしているか、それを含んでいるページである。)

        "Mozilla/4.08 [en] (Win98; I ;Nav)"
        　→ User-Agent HTTPリクエストヘッダ。これはクライアントのブラウザが自分自身のことを報告してくる情報である。

　複数のアクセスログ

　複数のアクセスログは単に設定ファイルに複数のCustomLogディレクティブを書くことで作成される。
　例えば、以下のディレクティブは3つのアクセスログを作る。最初のものは基本的なCLFの情報で、2つ目と3つ目はrefererとブラウザの情報。
　最後2つのCustomLogはReferLogディレクティブとAgentLogディレクティブの効果をまねる方法を示している。

    LogFormat "%h %l %u %t \"%r\" %>s %b" common
    CustomLog logs/access_log common
    CustomLog logs/referer_log "%{Referer}i -= %U"
    CustomLog logs/agent_log "%{User-agent}i"

　この例はLogFormatでニックネームを定義する必要が無い、と言うことも示している。
　ニックネームの代わりに、CustomLogディレクティブに直接ログの書式を指定することができる。

　条件付きログ

　クライアントのリクエストの特徴に基づいてアクセスログにエントリの一部をロギングしない方が便利なことがある。
　これは環境変数の補助により簡単に実現できる。まず、リクエストが何らかの条件にあるということを表すために環境変数が設定される必要がある。
　これは通常はSetEnvIfにより行われる。そして、CustomLogディレクティブのenv=節を使って環境変数が設定されているリクエストを含めたり
　排除したりすることができる。いくつか以下に例を挙げる。

    # Mark requests from the loop-back interface
    SetEnvIf Remote_Addr "127\.0\.0\.1" dontlog
    # Mardk requests for the robots.txt file
    SetEnvIf Request_URI "^/robots\.txt$" dontlog
    # Log what remains
    CustomLog logs/access_log common env!=dontlog

　他の例として、英語を話す人からのリクエストとそれ以外の人からのリクエストを分けたい、と言う場合を考えてみる。

    SetEnvIf Accept-Language "en" english
    CustomLog logs/english_log common env=english
    CustomLog logs/non_english_log common env=!english

　ここまででは条件付きロギングが非常に強力で柔軟であることを示してきたが、それがログの内容を制御する唯一の方法と言うわけではない。
　ログファイルはサーバの活動の完全な記録である方がより役に立つ。単純にログファイルを後処理して、
　考慮したくないログを削除する方が簡単であることが良くある。

・ログの交替

　普通の負荷のサーバでさえ、ログファイルに保存される情報の量は膨大になる。アクセスログのファイルは普通10,000リクエストごとに
　1MB以上増える。そのため、既存のログを移動したり、削除したりして、定期的にログを交替させることが必要になる。
　これはサーバの実行中には行えない。というのは、Apacheはファイルがopenされている間はずっと古いログファイルに書き続けるため。
　新しいログファイルをopenできるように、ログファイルが移動されたり削除された後に、サーバを再起動する必要がある。

　再起動(apachectl graceful)を行うことで、サーバは既存のコネクションや処理待ちのコネクションを失うことなく新しいログファイルを
　openさせることができる。しかし、これを実現するためにサーバは古いリクエストを扱っている間は古いログファイルに書き続ける必要がある。
　そのため、再起動の後ではログファイルの処理を始める前にしばらく待たなければならない。
　単にログを交替させて、ディスクの節約のために古いログを圧縮する普通の設定は以下の通り。

    mv access_log access_log.old
    mv error_lg error_log.old
    apachectl graceful
    sleep 600
    gzip access_log.old error_log.old

　ログの交代をするもう1つの方法は「パイプ経由のログ」を使うもので、次節で説明。

・パイプ経由のログ

　Apache httpdはエラーログとアクセスログをファイルに直接書く代わりに、パイプを通して別のプログラムに書き出すことができる。
　この機能により、主サーバにコードを追加することなくロギングの柔軟性が非常に高まっている。パイプにログを書くためには、単にファイル名を
　パイプ文字 | に置き換え、その続きに標準入力からログのエントリを受け取る実行プログラムの名前を書くだけである。Apacheはパイプ経由の
　ログ用のプロセスをサーバの起動時に実行し、サーバの実行中にそのプログラムがクラッシュしたときはそれを再び実行する。(この最後の機能が
　「信頼性のあるパイプ経由のロギング」と呼ばれている理由。)

　パイプ経由のログ用のプロセスはApache httpdの親プロセスから起動され、そのプロセスのユーザIDを継承する。これは、パイプ経由のログ用の
　プログラムは普通rootとして実行されることを意味する。そのため、プログラムを簡単で安全に保つことが非常に重要である。

　パイプ経由のログの重要な利用法は、サーバの再起動なしでログの交替をすることである。Apache HTTPサーバにはこのためのrotatelogs
　と呼ばれる簡単なプログラムが付属している。たとえば、24時間ごとにログを交替させるには、以下のものを使うことができる。

    CustomLog "|/usr/local/apache/bin/rotatelogs var/log/access_log 86400" commmon

　パイプの先で呼ばれるコマンド全体が引用符で囲まれていることに注目する。この例はアクセスログを使っているが、
　エラーログにも同じ技術を使うことができる。

　これと似たものに、よりずっと柔軟な cronolog と言うログ交替用のプログラムが外部のサイトにある。

　条件付きロギングと同様、パイプ経由のログは非常に強力な道具だが、オフラインの後処理のような、より簡単な解決方法があるときは
　使わない方が良いだろう。

・バーチャルホスト

　多くのバーチャルホストのあるサーバを実行している時は、ログファイルの扱い方にいくつかの方法がある。まず、単独のホストのみの
　サーバと全く同じようにログを使うことができる。ロギングディレクティブを主サーバのコンテキストの<VirtualHost>セクションの外に
　置くことで、全てのログを同じアクセスログとエラーログにログ収集することができる。この手法では個々のバーチャルホストの統計を
　簡単にとることはできない。

　CustomLogやErrorLogディレクティブが<VirtualHost>の中に置かれた場合は、そのバーチャルホストへの全てのリクエストやエラーが
　そこで指定されたファイルにのみログ収集される。ロギングディレクティブのないバーチャルホストは依然としてリクエストが主サーバの
　ログに送られる。この手法は少ないバーチャルホストに対しては非常に有用だが、ホストの数が非常に多くなると管理が大変になる。
　さらに、「ファイル記述子の限界」の問題を起こすことがある。
　「https://httpd.apache.org/docs/current/vhosts/fd-limits.html」を参照。

　アクセスログには非常にいい妥協案がある。バーチャルホストの情報をログのフォーマット文字列に加えることで、全てのホストへの
　リクエストを同じログにログ収集して、後でログを個々のファイルに分割することができる。たとえば、以下のディレクティブを見ると、

    LogFormat "%v %l %u %t \"%r\" %>s %b" comonvhost
    CustomLog logs/access_log commonvhost

　%vがリクエストを扱っているバーチャルホストの名前をログ収集するために使われている。そして、split-logfileのようなプログラムを使って
　アクセスログを後処理することで、バーチャルホストの毎のファイルにログを分割することができる。

　残念ながら、エラーログには同様の手法は無い。そのため、全てのバーチャルホストを同じエラーログの中に混ぜるか、
　バーチャルホストごとにエラーログを使うかを選ばなければならない。

・他のログファイル

　実際に送受信したバイト数のログ

　mod_logioは、ネットワーク上で実際に送信した数をログする2つのフィールド(%Iと%O)をLogFormatディレクティブに追加する。

　Forensicログ

　mod_log_forensicはクライアントリクエストのforensicログを取る。ログはリクエスト処理前と処理後に行われるので、
　1リクエストに対して2行のログが出力される。forensicロガーはとても厳密でカスタマイズできない。デバッグやセキュリティ用のツールとして
　有効かもしれない。

　PIDファイル

　起動時に、Apacheは親httpdのプロセスのプロセスIDをlogs/httpd.pidに保存する。このファイル名はPidFileディレクティブを使って
　変更することができる。プロセスIDは管理者が親プロセスにシグナルを送ることでデーモンを再起動したり終了させるときに使用する。
　Windowsでは、代わりに-kコマンドオプションを使う。詳しい情報は「終了と再起動」のページを見る。

　スクリプトログ

　デバッグの補助のために、ScriptLogディレクティブはCGiスクリプトの入力と出力を記録するようにできる。これはテスト用にのみ使用して、
　通常のサーバでは使用しないようにする。詳しい情報はmod_cgiの文書にある。

　リライトログ

　mod_rewriteの協力で複雑な機能を使っている時は、ほぼいつもデバッグを簡単にするためにRewriteLogの使用が必要だろう。
　このログファイルにはリライトエンジンがリクエストを書き換える方法の詳細な解析が出力される。詳しさの度合いはRewriteLogLevelで制御できる。

URLからファイルシステム上の位置へのマップ

　この文書はApacheがリクエストのURLから送信するファイルのファイルシステム上の位置を決定する方法を説明する。

・DocumentRoot

　リクエストに対してどのファイルを送信するかを決定する時のApacheのデフォルトの動作は、リクエストのURL-Path(URLのホスト名と
　ポート番号の後に続く部分)を取り出して設定ファイルで指定されているDocumentRootの最後に追加する、というものである。
　そのため、DocumentRootの下のディレクトリやファイルがwebから見える基本のドキュメントの木構造をなす。

　Apacheにはサーバが複数のホストへのリクエストを受け取るバーチャルホストの機能もある。この場合、それぞれのバーチャルホストに対して違う
　DocumentRootを指定することができる。また、mod_vhost_alisaモジュールにより提供されるディレクティブを使って、送信するための
　コンテンツの場所をリクエストされたIPアドレスやホスト名から動的に決めることもできる。

・DocumentRoot外のファイル

　ファイルシステム上の、厳密にはDocumentRootの下にはない部分へのwebアクセスを許可する必要がある場合が良くある。
　Apacheはこのために複数の方法を用意している。Unixシステムでは、ファイルシステムの他の部分をシンボリックリンクを使ってDocumentRootの下に
　持ってくることができる。セキュリティ上の理由により、Apacheは該当するディレクトリのOptionsの設定にFollowSymLinks か SymLinksIfOwnerMatch
　がある場合にのみシンボリックリンクをたどる。

　代わりの方法として、Aliasディレクティブを使ってファイルシステムの任意の部分をwebの空間にマップできる。例えば以下の

    Alias /docs /var/web

　という設定の時は、URL http://www.example.com/docs/dir/file.html には/var/web/dir/file.html が送信される。
　ScriptAliasも、対象となっているパスがCGIスクリプトとして扱われるという追加の効果以外は同じように動作する。

　もっと柔軟な設定が必要な状況では、AliasMatchディレクティブやScriptAliasMatchディレクティブを使って強力な正規表現に基づいた
　マッチと置換を行うことができる。たとえば以下の

    ScriptAliasMatch ^/~([a-zA-Z0-9] +) /cgi-bin/ (.+) /home/$1/cgi-bin/$2

　は http://example.com/~user/cgi-bin/script.cgi へのリクエストを /home/user/cgi-bin/script.cgi と言うパスへマップし、
　このマップの結果としてのファイルをCGIスクリプトとして扱う。

・ユーザディレクトリ

　伝統的にUnixシステムではユーザuserのホームディレクトリを~user/ として参照できる。mod_userdirモジュールはこの概念をwebに拡張して
　それぞれのユーザのホームディレクトリのファイルを以下のようなURLを使ってアクセスできるようにする。

    http://www.example.com/~user/file.html

　セキュリティの観点から、webからユーザのホームディレクトリへ直接アクセスできるようにすることは適切ではない。
　そのため、UserDirディレクティブにはユーザのホームディレクトリの下の、webファイルの置かれているディレクトリを指定する。
　デフォルトの設定のUserDir public_htmlを使うと、上のURLは /home/user/public_html/file.html というようなファイルにマップされる。
　ここで、/home/user は /etc/passwd で指定されているユーザのホームディレクトリである。

　UserDirには、/etc/passwd にホームディレクトリの位置が書かれていないシステムでも使うことのできる他の形式もある。

　中にはシンボル ~ (%7eのように符号化されることが多い)を格好が悪いと思って、ユーザのディレクトリを表すために別の文字列の使用を
　好む人がいる。mod_userdirはこの機能をサポートしていない。しかし、ユーザのホームディレクトリが規則的な構成の時は、AliasMatchを使って
　望みの効果を達成することができる。たとえば、http://www.example.com/upages/user/file.html が /home/user/public_html/file.html に
　マップされるようにするには、以下のようにAliasMatchディレクティブを使う。

    AliasMatch ^/upages/([a-zA-Z0-9]+) /?(.*) /home/$1/public_html/$2

・URLリダイレクション

　上の節で説明した設定用のディレクティブはApacheにファイルシステムの特定の場所からコンテンツを取ってきてクライアントに
　送り返すようにする。ときには、その代わりにクライアントにリクエストされたコンテンツは別のURLにあることを知らせて、クライアントが新しい
　URLへ新しいリクエストを行うようにする方が望ましいことがある。これは「リダイレクション」と呼ばれていて、Redirectディレクティブにより
　実装されている。たとえば、DocumentRootの下のディレクトリ /foo/ が新しいディレクトリ /bar/ に移動したときは、以下のようにして
　クライアントが新しい場所のコンテンツをリクエストするように指示することができる。

    Redirect permanent /foo/ http://www.example.com/bar/

　これは、/foo/ で始まる全てのURL-pathを、www.example.comサーバの /bar/ が /foo/ に置換されたものにリダイレクトする。
　サーバは自分自身のサーバだけでなく、どのサーバにでもクライアントをリダイレクトすることができる。

　Apacheはより複雑な書き換えの問題のために、RedirectMatchディレクティブを提供している。たとえば、サイトのホームページを違う
　サイトにリダイレクトするけれど、他のリクエストはそのまま扱う、というときは以下の設定を使う。

    RedirectMatch permanent ^/$ http://www.example.com/startpage.html

　あるいは、一時的にサイトの全てのページを他のサイトの特定のページへリダイレクトするときは、以下を使う。

    RedirectMatch temp .* http://othersite.example.com/startpage.html

・リバースプロキシ

　Apacheは遠隔地にあるドキュメントをローカルのサーバのURL空間に持ってくることもできる。この手法はリバースプロキシと呼ばれている。
　webサーバが遠隔地のドキュメントを取得してクライアントに送り返すのがプロキシサーバの動作のように見えるからである。
　クライアントにはドキュメントがリバースプロキシサーバから送られてきているように見える点が通常のプロキシとは異なる。

　以下の例では、クライアントが/foo ディレクトリの下にあるドキュメントをリクエストすると、サーバがinternal.example.com の/bar 
　ディレクトリから取得して、さもローカルサーバからのドキュメントのようにしてクライアントに返す。

    ProxyPass /foo/ http://internal.example.com/bar/
    ProxyPassReverse /foo/http://internal.example.com/bar/
    ProxyPassReverseCookieDomain internal.example.com public.example.com
    ProxyPassReverseCookiePath /foo/ /bar/

　ProxyPassディレクティブはサーバが適切なドキュメントを取得するように設定し、ProxyPassReverseディレクティブはinternal.example.com
　からのリダイレクトがローカルサーバの適切なディレクトリを指すように書き換える。同様に、ProxyPassReverseCookieDomain と
　ProxyPassReverseCookiePath でバックエンド側サーバの発行したCookieを書き換えることができる。

　ただし、ドキュメントの中のリンクは書き換えられない、ということは知っておく。そのため、internal.example.comへの絶対パスによるリンクでは、
　クライアントがプロキシサーバを抜け出してinternal.example.comに直接リクエストを送る、ということになる。
　サードパーティ製モジュールのmod_proxy_html は、HTMLとXHTML中のリンクを書き換えることができる。

・リライトエンジン

============================================================================================================================

エラーやミス、わからないことなど

・httpd -k install コマンドでwindowsにapacheサービスをインストールしたとき、以下のようなエラーが出た。

　　C:\Windows\System32>httpd -k install
　　Installing the 'Apache2.4' service
　　The 'Apache2.4' service is successfully installed.
　　Testing httpd.conf....
　　Errors reported here must be corrected before the service can be started.
　　AH00558: httpd: Could not reliably determine the server's fully qualified domain name, 
　　using fe80::bb83:36d0:35ca:b0dc. Set the 'ServerName' directive globally to suppress this message

　→ 恐らく、httpd.confの設定をしていなかったため、このエラーが出たのだと思われる。

============================================================================================================================

パート応募システムに活かせそうな知識

・